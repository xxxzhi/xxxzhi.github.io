<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="侯志">
<meta property="og:url" content="http://houzhi.me/page/2/index.html">
<meta property="og:site_name" content="侯志">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="侯志">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://houzhi.me/page/2/"/>





  <title>侯志</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">侯志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/06/02/android-sourcecode-adapter-activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/02/android-sourcecode-adapter-activity/" itemprop="url">Android源码适配器模式---Activity类结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-02T00:00:00+08:00">
                2016-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实适配器模式在Android源码中非常多，而从整体的源码角度上来看Activity的结构就是一种适配器模式。从这个角度上面看Activity，对Activity和应用层框架会有更加深入的理解。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个接口转换为用户需要的另外一个接口，适配器模式使得原本由于接口不兼容不能一起工作的那些类可以一起工作。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p>适配器模式有两种模式，UML分别如下:</p>
<p><img src="http://xxxzhi.github.io/images/adapter1.png" alt="http://xxxzhi.github.io/images/adapter1.png"></p>
<p><img src="http://xxxzhi.github.io/images/adapter2.png" alt="http://xxxzhi.github.io/images/adapter2.png"></p>
<p>第一种是直接继承已经有的接口适配目标接口，而第二种是引用已有的接口适配目标接口。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">interface Target&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Adaptee&#123;</div><div class="line">    public void specialRequest()&#123;</div><div class="line">        System.out.println(&quot;special from adaptee&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Adapter extends Adaptee implements Target&#123;</div><div class="line">    public void request()&#123;</div><div class="line">        //do something to implements request</div><div class="line">        specialRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static final void main(String args[])&#123;</div><div class="line">    Target target = new Adapter();</div><div class="line">    target.request();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是第一种适配器模式的简单代码示例，通过继承已有的类来适配，另外一种组合的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">interface Target&#123;</div><div class="line">    void request();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Adaptee&#123;</div><div class="line">    public void specialRequest()&#123;</div><div class="line">        System.out.println(&quot;special from adaptee&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Adapter implements Target&#123;</div><div class="line">    private Adaptee adaptee ;</div><div class="line">    public void Adapter(Adaptee adaptee)&#123;</div><div class="line">        this.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line">    public void request()&#123;</div><div class="line">        //do something to implements request</div><div class="line">        adaptee.specialRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static final void main(String args[])&#123;</div><div class="line">    Target target = new Adapter(new Adaptee());</div><div class="line">    target.request();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两种方式类适配器和对象适配器。</p>
<h2 id="Activity与适配器模式"><a href="#Activity与适配器模式" class="headerlink" title="Activity与适配器模式"></a>Activity与适配器模式</h2><p>Activity是Android的核心组件，它是负责应用UI的组件，可以说是Android四大组件中最重要，使用最多，最复杂的组建。它的源码也相当地庞大。从适配器的角度上来看，Activity适配了多个接口，先看一下它的类结构图：<br><img src="http://xxxzhi.github.io/images/adapter-activity.png" alt="此处输入图片的描述"></p>
<p>将Activity看成是适配器模式初看可能会有点牵强。但是ContextThemeWrapper是表示主题的环境类，Context可以翻译为应用环境,但是对于需要显示UI的一个应用组建除了应用环境外，还需要适应其他的内容信息，比如Window，比如KeyEvent等等。</p>
<p>拿窗口系统举例。Android中有Window管理系统，但是窗口系统需要与的Window.Callback接口，但是现在是有了Context，组建需要Window.Callback接口，这样创建Activity(这个是Adapter)实现Window.Callback接口，并且继承ContextThemeWrapper，将ContextWrapper与Window.Callback协作，让Context与Window一起工作。Window.Callback只是Activity适配的其中一个接口，下面分别介绍类结构的每一个部分。</p>
<h3 id="ContextThemeWrapper"><a href="#ContextThemeWrapper" class="headerlink" title="ContextThemeWrapper"></a>ContextThemeWrapper</h3><p>这是一个包含主题的Context装饰器，本身ContextWrapper是一个装饰器模式，在Android中，四大组建都是ContextWrapper的子类，四大组建都需要应用环境。关于这部分可以看我这篇文章<a href="http://blog.csdn.net/xxxzhi/article/details/51152751" target="_blank" rel="external">Android源码装饰模式—ContextWrapper</a>。需要理解的是Context是一个应用环境类型，Context包含了各种跟应用环境相关的信息，可以用来与应用系统打交道的。</p>
<h3 id="Window-Callback-Window-OnWindowDismissedCallback"><a href="#Window-Callback-Window-OnWindowDismissedCallback" class="headerlink" title="Window.Callback, Window.OnWindowDismissedCallback"></a>Window.Callback, Window.OnWindowDismissedCallback</h3><p>Window.Callback 这个接口包含了很多接口函数，上面的UML图中只包含了部分接口，全部的接口类可见下面的Outline截图：</p>
<p><img src="http://xxxzhi.github.io/images/window-callback.png" alt="此处输入图片的描述"></p>
<p>这个接口是窗口的回调接口，主要分为屏幕事件触发，按键事件触发，Panel相关的View创建与Prepare,Menu的回调，Window的变化回调，SearchRequest的回调，以及ActionMode的回调。</p>
<p>Window.OnWindowDismissedCallback是一个hide类，是无法通过API调用的，是当窗口消失（Window系统移除）的时候的回调接口。Activity的实现也很简单，直接finish掉自己。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Called when the main window associated with the activity has been dismissed.</div><div class="line"> * @hide</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void onWindowDismissed() &#123;</div><div class="line">    finish();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Callback,OnWindowDismissedCallback是Window与Activity交互的回调接口。</p>
<p>初始部分代码为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//Activity.java</div><div class="line">    final void attach(Context context, ActivityThread aThread,</div><div class="line">            Instrumentation instr, IBinder token, int ident,</div><div class="line">            Application application, Intent intent, ActivityInfo info,</div><div class="line">            CharSequence title, Activity parent, String id,</div><div class="line">            NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</div><div class="line">        attachBaseContext(context);</div><div class="line"></div><div class="line">        mFragments.attachHost(null /*parent*/);</div><div class="line"></div><div class="line">        mWindow = new PhoneWindow(this);</div><div class="line">        mWindow.setCallback(this);</div><div class="line">        mWindow.setOnWindowDismissedCallback(this);</div><div class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>但实际上一个Window并不是只和一个Activity关联，而是一个Window和一个Callback关联，Activity也是Context，Android中Dialog里面也包含了Window，Dialog也实现了Callback接口。一个应用环境中(Context)可能包含多个Window，也就会有多个Callback，只是Activity这种应用环境本身就实现了Callback接口。</p>
<h3 id="KeyEvent-Callback"><a href="#KeyEvent-Callback" class="headerlink" title="KeyEvent.Callback"></a>KeyEvent.Callback</h3><p>对应着Key事件的回调接口，当按下按键的时候，会回调该接口。主要是为了适配输入系统。</p>
<h3 id="ComponentCallbacks2"><a href="#ComponentCallbacks2" class="headerlink" title="ComponentCallbacks2"></a>ComponentCallbacks2</h3><p>它是ComponentCallbacks的子接口，CompoentCallbacks包含下面两个接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void onConfigurationChanged(Configuration newConfig);</div><div class="line"></div><div class="line">void onLowMemory();</div></pre></td></tr></table></figure>
<p>ComponentCallbacks2新增了<code>onTrimMemory</code>接口。<br>ComponentCallbacks是专门为Android组件使用的回调接口，Android组件都会实现该接口(目前变成了ConponentCallbacks2)，当配置信息变化，内存变化的时候，这些接口会被调用。调用这些接口的是ActivityThread(消息循环中，收到变化消息时)，ViewRootImpl（在Window有变化的时候，ViewRootImpl负责与WindowManagerService通信）等。该接口是为了适配系统信息管理部分。</p>
<p>这里有两个跟内存相关的接口，这其实是为帮应用应对Android内存满负荷，提醒应用程序做一些释放内存处理，如果占用内存过大，应用将会更容易被杀死。具体可以看LowMemoryKiller的介绍。</p>
<h3 id="OnCreateContextMenuListener"><a href="#OnCreateContextMenuListener" class="headerlink" title="OnCreateContextMenuListener"></a>OnCreateContextMenuListener</h3><p>Android上下文菜单: 当给一个View注册了上下文菜单后，对这个View长按2秒，会弹出一个浮动的菜单。OnCreateContextMenuListener 它只有一个接口函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当View的Context menu被创建的时候，该接口的会被调用，用于获取Menu(作为实现改接口的Activity来讲，是设置Menu)。在Activity中，与这个接口函数对应的函数是onContextItemSelected，而该函数是继承自Window.Callback接口的onMenuItemSelected函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public boolean onMenuItemSelected(int featureId, MenuItem item) &#123;</div><div class="line">    CharSequence titleCondensed = item.getTitleCondensed();</div><div class="line"></div><div class="line">    switch (featureId) &#123;</div><div class="line">        case Window.FEATURE_OPTIONS_PANEL:</div><div class="line">            if(titleCondensed != null) &#123;</div><div class="line">                    EventLog.writeEvent(50000, 0, titleCondensed.toString());</div><div class="line">            &#125;</div><div class="line">            if (onOptionsItemSelected(item)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        ...</div><div class="line">        case Window.FEATURE_CONTEXT_MENU:</div><div class="line">            if(titleCondensed != null) &#123;</div><div class="line">                EventLog.writeEvent(50000, 1, titleCondensed.toString());</div><div class="line">            &#125;</div><div class="line">            if (onContextItemSelected(item)) &#123; //这里</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return mFragments.dispatchContextItemSelected(item);</div><div class="line"></div><div class="line">        default:</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们平时监听普通的Menu的函数<code>onOptionsItemSelected</code>也是由<code>onMenuItemSelected</code>调用的。</p>
<p>另外一边View中显示ContextMenu的函数是showContextMenu:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean showContextMenu() &#123;</div><div class="line">    return getParent().showContextMenuForChild(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewGroup的showContextMenuForChild为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean showContextMenuForChild(View originalView) &#123;</div><div class="line">    return mParent != null &amp;&amp; mParent.showContextMenuForChild(originalView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getParent()</code>最终会到DecorView，DecorView中创建了ContextMenu。然后调用View的<code>createContextMenu</code>方法，最终使用mOnCreateContextMenuListener获取Menu:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void createContextMenu(ContextMenu menu) &#123;</div><div class="line">    ContextMenuInfo menuInfo = getContextMenuInfo();</div><div class="line"></div><div class="line">    // Sets the current menu info so all items added to menu will have</div><div class="line">    // my extra info set.</div><div class="line">    ((MenuBuilder)menu).setCurrentMenuInfo(menuInfo);</div><div class="line"></div><div class="line">    onCreateContextMenu(menu);</div><div class="line">    ListenerInfo li = mListenerInfo;</div><div class="line">    if (li != null &amp;&amp; li.mOnCreateContextMenuListener != null) &#123;</div><div class="line">        li.mOnCreateContextMenuListener.onCreateContextMenu(menu, this, menuInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Clear the extra information so subsequent items that aren&apos;t mine don&apos;t</div><div class="line">    // have my extra info.</div><div class="line">    ((MenuBuilder)menu).setCurrentMenuInfo(null);</div><div class="line"></div><div class="line">    if (mParent != null) &#123;</div><div class="line">        mParent.createContextMenu(menu);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DecorView在PhoneWindow中，Menu其实会由Window统一管理，响应Item的点击事件的接口是一致的(<code>Window.Callback.onMenuItemSelected</code>)，另外ContextMenu实际上显示出来的就是一个Dialog。但由于ContextMenu是跟View对应的，所以有了OnCreateContextMenuListener接口，它是用于当View需要创建ContextMenu的时候，方便指定ContextMenu的内容。</p>
<h3 id="LayoutInflater-Factory2"><a href="#LayoutInflater-Factory2" class="headerlink" title="LayoutInflater.Factory2"></a>LayoutInflater.Factory2</h3><p>这个接口只有一个接口函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public View onCreateView(View parent, String name, Context context, AttributeSet attrs);</div></pre></td></tr></table></figure></p>
<p>它继承自Factory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Factory &#123;</div><div class="line">     /**</div><div class="line">      * Hook you can supply that is called when inflating from a LayoutInflater.</div><div class="line">      * You can use this to customize the tag names available in your XML</div><div class="line">      * layout files.</div><div class="line">      *</div><div class="line">      * &lt;p&gt;</div><div class="line">      * Note that it is good practice to prefix these custom names with your</div><div class="line">      * package (i.e., com.coolcompany.apps) to avoid conflicts with system</div><div class="line">      * names.</div><div class="line">      */</div><div class="line">     public View onCreateView(String name, Context context, AttributeSet attrs);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>用于跟LayoutInflater系统交互，为了适配LayoutInflater系统。实现改接口，可以在Inflater的时候，解析XML中自定义的Tag。该接口为LayoutInflater调用，而LayoutInflater的实现为PhoneLayoutInflater。对于Window和LayoutInflater结构可以看这篇<a href="http://blog.csdn.net/xxxzhi/article/details/51189013" target="_blank" rel="external">Android源码抽象工厂—IPolicy</a>。</p>
<p>除了Activity外，Application和Service都实现了ComponnentCallbacks接口，继承了ContextWrapper，其实都可以用类适配器模式看待。</p>
<h2 id="设计思考"><a href="#设计思考" class="headerlink" title="设计思考"></a>设计思考</h2><p>本身应用组件都应该是一种应用环境（Context)，但是又需要满足Window等系统的回调需求，我们平时可能直接单独实现Window.Callback接口，但是将Activity实现Window.Callback接口，那么Activity会更加具有整体性，不过设计意图在这里思考过多感觉有点太牵强。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从Android应用层源码整理来看，Activity的类结构完全可以看成是一种适配器模式，在基于应用环境(Context)的情况下，去满足LayoutInflater系统（LayoutInflater.Factory2），Window系统（Window.Callback，Window.OnWindowDismissedCallback），输入系统（KeyEvent.Callback）的接口需求，另外ComponnentCallbacks更是ActivityThread和ViewRootImpl需要的接口。通过适配器模式来看Activity，对于Activity，对于Activity与其他部分的交互，对于应用层框架会有更好的理解。另外再有装饰模式看Context，对于整个应用层结构会更清晰。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/29/android-parcel-bitmap-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/29/android-parcel-bitmap-2/" itemprop="url">Android4.0之后Parcel传输Bitmap源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-29T00:00:00+08:00">
                2016-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很久之前就看到有网友遇到用Parcel传Bitmap的时候，会遇到因为图片太大而报错，都在讨论传输Bitmap的时候的大小限制，但是实际上应该只有在4.0之前会有限制，4.0之后图片传输的方式有变化，它采用了Blob来传输，最终会使用ashmem来传递占用内存大的数据。下面分别介绍4.0前后Parcel对图片传输的异同。</p>
<h2 id="Parcel写入读取"><a href="#Parcel写入读取" class="headerlink" title="Parcel写入读取"></a>Parcel写入读取</h2><p>先简单介绍一下Parcel的写入读取模式，Parcel是Android中跨进程数据传递的中介，跨进程数据使用Parcel传递效率会比Serializable。Parcel提供了很多接口，比如writeInt,writeFloat,writeString，readInt,readFloat,readString等等，用这些接口可以读取写入数据.而实际上，Parcel里面有一个mData变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void* mData;</div></pre></td></tr></table></figure>
<p>这个变量是一个指针类型，那些写入的接口都是将数据写入到这个指针变量指向的区域，读取也是从mData中读，写入和读取的数据相互对应。然后再将这个mData传入到Binder，或者是从Binder中读取出来。</p>
<h2 id="2-3源码"><a href="#2-3源码" class="headerlink" title="2.3源码"></a>2.3源码</h2><p>在2.3中，Android Parcel传输图片是有大小限制的，实际上的限制应该是Binder对传输的数据大小的限制。Bitmap会对应的native层Parcel传输函数是Bitmap_writeToParcel，先看源码是怎么传输的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,</div><div class="line">                                     const SkBitmap* bitmap,</div><div class="line">                                     jboolean isMutable, jint density,</div><div class="line">                                     jobject parcel) &#123;</div><div class="line">    if (parcel == NULL) &#123;</div><div class="line">        SkDebugf(&quot;------- writeToParcel null parcel\n&quot;);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line"></div><div class="line">    p-&gt;writeInt32(isMutable);</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;config());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;width());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;height());</div><div class="line">    p-&gt;writeInt32(bitmap-&gt;rowBytes());</div><div class="line">    p-&gt;writeInt32(density);　//这些都是写入到Parcel的mData</div><div class="line"></div><div class="line">    if (bitmap-&gt;getConfig() == SkBitmap::kIndex8_Config) &#123;</div><div class="line">        SkColorTable* ctable = bitmap-&gt;getColorTable();</div><div class="line">        if (ctable != NULL) &#123;</div><div class="line">            int count = ctable-&gt;count();</div><div class="line">            p-&gt;writeInt32(count);</div><div class="line">            memcpy(p-&gt;writeInplace(count * sizeof(SkPMColor)),</div><div class="line">                   ctable-&gt;lockColors(), count * sizeof(SkPMColor));</div><div class="line">            ctable-&gt;unlockColors(false);</div><div class="line">        &#125; else &#123;</div><div class="line">            p-&gt;writeInt32(0);   // indicate no ctable</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line">    memcpy(p-&gt;writeInplace(size), bitmap-&gt;getPixels(), size); //这个地方传输像素数据</div><div class="line">    bitmap-&gt;unlockPixels();</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而Parcel的writeInplace方法很简单，就是根据传进去的位置，然后返回一个地址，这个地址是Parcel数据的地址，相当于当前应该写入的位置。得到地址后，再用memcpy把像素拷贝到Parcel中(mData)。这样相当于直接把数据拷贝到Parcel中。而Parcel传输数据如果大于当前的容量，会通过growData来增大容量，这个最大不要溢出整数的最大值，或者有存储空间可以分配，相当于正常情况下在Parcel没有限制数据大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void* Parcel::writeInplace(size_t len)</div><div class="line">&#123;</div><div class="line">    const size_t padded = PAD_SIZE(len);</div><div class="line"></div><div class="line">    // sanity check for integer overflow</div><div class="line">    if (mDataPos+padded &lt; mDataPos) &#123; //不能超过整数大小</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ((mDataPos+padded) &lt;= mDataCapacity) &#123;</div><div class="line">restart_write:  //不断增大容量</div><div class="line">        //printf(&quot;Writing %ld bytes, padded to %ld\n&quot;, len, padded);</div><div class="line">        uint8_t* const data = mData+mDataPos;</div><div class="line"></div><div class="line">         // Need to pad at end?</div><div class="line">        if (padded != len) &#123;</div><div class="line"></div><div class="line">            //printf(&quot;Applying pad mask: %p to %p\n&quot;, (void*)mask[padded-len],</div><div class="line">            //    *reinterpret_cast&lt;void**&gt;(data+padded-4));</div><div class="line">             *reinterpret_cast&lt;uint32_t*&gt;(data+padded-4) &amp;= mask[padded-len];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        finishWrite(padded);</div><div class="line">        return data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    status_t err = growData(padded);</div><div class="line">    if (err == NO_ERROR) goto restart_write;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样方式传输，会把像素数组全部传输到Binder驱动中，而导致如果图片太大出现一些<figure class="highlight plain"><figcaption><span>BINDER TRANSACTION```。大小的限制在Binder。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 4.0源码</div><div class="line">在4.0的源码中，Android的Parcel传输Bitmap的时候，会采用Blob来传输，Blob是用来传递占用内存很大的对象的，这是在native层的接口，如果4.0在Java层使用Parcel传递未提供的接口的数据的话，可以考虑用writeByteArray，在5.0中Java层增加了Blob接口。</div><div class="line"></div><div class="line"></div><div class="line">先看Bitmap_writeTOParcel源码:</div></pre></td></tr></table></figure></p>
<p>static jboolean Bitmap_writeToParcel(JNIEnv<em> env, jobject,<br>                                     const SkBitmap</em> bitmap,<br>                                     jboolean isMutable, jint density,<br>                                     jobject parcel) {<br>    if (parcel == NULL) {<br>        SkDebugf(“——- writeToParcel null parcel\n”);<br>        return false;<br>    }</p>
<pre><code>android::Parcel* p = android::parcelForJavaObject(env, parcel);

...前面部分是传输图片相关的一些特性，比如宽度，高度，颜色等等，与2.3一致

size_t size = bitmap-&gt;getSize();
//这里开始用blob传输
android::Parcel::WritableBlob blob;
android::status_t status = p-&gt;writeBlob(size, &amp;blob);
if (status) {
    doThrowRE(env, &quot;Could not write bitmap to parcel blob.&quot;);
    return false;
}

bitmap-&gt;lockPixels();
const void* pSrc =  bitmap-&gt;getPixels(); //把像素copy到blob的指针，也就是blob里面
if (pSrc == NULL) {
    memset(blob.data(), 0, size);
} else {
    memcpy(blob.data(), pSrc, size);
}
bitmap-&gt;unlockPixels();

blob.release();
return true;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">而Parcel的writeBlob用来写入Blob，它会根据数据量的大小来判断是否应该使用ashmem来传输。其源码如下:</div></pre></td></tr></table></figure></p>
<p>status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)<br>{<br>    status_t status;</p>
<pre><code>if (!mAllowFds || len &lt;= IN_PLACE_BLOB_LIMIT) { //IN_PLACE_BLOB_LIMIT 为40 * 1024
//如果不允许fd共享内存文件传输，或者长度小于IN_PLACE_BLOB_LIMIT，则按照原来的方式传输
    LOGV(&quot;writeBlob: write in place&quot;);
    status = writeInt32(0); //未使用asm
    if (status) return status;

    void* ptr = writeInplace(len);
    if (!ptr) return NO_MEMORY;

    outBlob-&gt;init(false /*mapped*/, ptr, len); // Blob对应的地址为ptr，其实也是Parcel的地址
    return NO_ERROR;
}
// 下面的就是通过ashmem（匿名共享内存）来传递数据，
LOGV(&quot;writeBlob: write to ashmem&quot;);
int fd = ashmem_create_region(&quot;Parcel Blob&quot;, len);
if (fd &lt; 0) return NO_MEMORY;

int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);
if (result &lt; 0) {
    status = result;
} else {
    void* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED) {
        status = -errno;
    } else {
        result = ashmem_set_prot_region(fd, PROT_READ);
        if (result &lt; 0) {
            status = result;
        } else {
            status = writeInt32(1); //标记使用了asm传输
            if (!status) {
                status = writeFileDescriptor(fd, true /*takeOwnership*/); //传递fd
                if (!status) {
                    outBlob-&gt;init(true /*mapped*/, ptr, len); //如果成功，Blob将会对应asm中的内存位置。
                    return NO_ERROR;
                }
            }
        }
    }
    ::munmap(ptr, len);
}
::close(fd);
return status;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Parcel在4.0后增加Blob数据接口，用来传输占用内存大的数据，Blob传输具体的流程就是：如果数据量不超过IN_PLACE_BLOB_LIMIT或者不允许fd传输，则采用普通的方式，也就是直接将数据拷贝到Parcel里面；如果上面的条件不符合，则会采用asm来传输，也就是创建一个asm区域，然后把fd传入Parcel，把Blob对应的指针位置指向asm区域(通过mmap映射内存，最后直接将数据拷贝到这里面）。</div><div class="line">另外需要说的writeBlob只是给Blob赋值了一个指针位置，这个指针或者是Parcel的mData中的某个位置，或者asm区域里面的指针(mmap得到)，调用writeBlob的不用关心具体是哪个位置。</div><div class="line"></div><div class="line">如果是普通方式传输，先写入一个0，如果是asm方式先写入一个1，读取的时候根据这个标志来判断是不是asm方式，具体可以看我代码的注释，下面是readBlob源码:</div></pre></td></tr></table></figure>
<p>status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const<br>{<br>    int32_t useAshmem;<br>    status_t status = readInt32(&amp;useAshmem); //useAshmem是标志位，如果为0表示不使用ashmem传输<br>    if (status) return status;</p>
<pre><code>if (!useAshmem) {
    LOGV(&quot;readBlob: read in place&quot;);
    const void* ptr = readInplace(len);
    if (!ptr) return BAD_VALUE;

    outBlob-&gt;init(false /*mapped*/, const_cast&lt;void*&gt;(ptr), len);
    return NO_ERROR;
}

LOGV(&quot;readBlob: read from ashmem&quot;);
int fd = readFileDescriptor();
if (fd == int(BAD_TYPE)) return BAD_VALUE;

void* ptr = ::mmap(NULL, len, PROT_READ, MAP_SHARED, fd, 0);
if (!ptr) return NO_MEMORY;

outBlob-&gt;init(true /*mapped*/, ptr, len);
return NO_ERROR;
</code></pre><p>}<br>```</p>
<p>也就是在4.0之后，如果允许fd传递的话，大数据量会通过ashmem来传递，而数据小的直接通过拷贝的方式，这样对于图片的大小限制也就小了很多。</p>
<h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>关于遇到Intent传递图片因为大小限制而报错<code>FAILED BINDER TRANSACTION</code>，应该是4.0之前的机器的。4.0之后正常情况下应该不会出错。</p>
<p>其实我在传递图片的时候，都是先保存在sdcard，然后再将图片的路径传递到另外的进程或不同的Activity，我觉得直接传递图片会导致占用内存太大。但是为什么Android内部还是提供了这样一个接口呢？</p>
<p>认真阅读了4.0之后的源码后，我发现从原理上面来看直接传递图片的效率和速度会更高，因为保存在sdcard会经过两次io（起码一次），而直接通过Parcel传递图片，那么直接在内存中操作，速度会高很多。另外我担心的内存占用太大其实多虑了。在4.0之后，如果图片小的话（40kb以内），不会太大影响，如果超过40kb，则会使用asm来传，不会占用到Java的堆内存，而且占用的内存传输完毕后就会释放了。即使是4.0之前，如果图片预计比较小，直接通过Parcel传递应该会好很多（也就是Activity之间直接把Bitmap放入Intent）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/24/android-bitmap-sourcecode-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/24/android-bitmap-sourcecode-analysis/" itemprop="url">Android6.0 Bitmap存储以及Parcel传输源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-24T00:00:00+08:00">
                2016-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果想要对Android Bitmap进行更多的操作，理解好Bitmap的实现将会有非常大的帮助，另外Android在6.0中增加了asm存储图片。这篇文章就通过源码来分析Android6.0中的Bitmap。本文主要分析Java层与native层的Bitmap，以及Bitmap的储存和Parcel传输。源码基于6.0，所以会有一些新的特性。</p>
<h2 id="Bitmap存储方式以及包含的属性"><a href="#Bitmap存储方式以及包含的属性" class="headerlink" title="Bitmap存储方式以及包含的属性"></a>Bitmap存储方式以及包含的属性</h2><p>计算机里面图片都是作为数组来存储的，而在Android中Bitmap也是一样。在Java层的Bitmap数组保存为mBuffer。而在native层，Bitmap有四种保存方式，在Bitmap.h文件中有个枚举类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum class PixelStorageType &#123;</div><div class="line">    Invalid,</div><div class="line">    External,</div><div class="line">    Java,</div><div class="line">    Ashmem,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Invalid表示图片已经失效了，一般图片free掉之后就会是这种状态。External是外部存储。Java是表示这个Bitmap对应着Java的Bitmap，此时Bitmap会保存着Java层Bitmap的存储数组的弱引用。而Ashmem则是对应着匿名共享内存，表示图片是存储在匿名共享内存当中。后三种类型在Bitmap中对应着一个union类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">union &#123;</div><div class="line">    struct &#123;</div><div class="line">        void* address;</div><div class="line">        void* context;</div><div class="line">        FreeFunc freeFunc;</div><div class="line">    &#125; external;</div><div class="line">    struct &#123;</div><div class="line">        void* address;</div><div class="line">        int fd;</div><div class="line">        size_t size;</div><div class="line">    &#125; ashmem;</div><div class="line">    struct &#123;</div><div class="line">        JavaVM* jvm;</div><div class="line">        jweak jweakRef;</div><div class="line">        jbyteArray jstrongRef;</div><div class="line">    &#125; java;</div><div class="line">&#125; mPixelStorage;</div></pre></td></tr></table></figure>
<p>另外因为图片是直接保存在一片内存区域，那么它也可以保存在匿名共享内存当中，这就是Fresco在5.0之前干的事情，而将图片放到匿名共享内存当中，不会自动GC，应用会更加流畅，因为不在Java堆，也不用关心Java堆大小的限制而导致OOM。</p>
<p>另外还包含几种属性：<br>width, height: 图片宽度和高度<br>mDensity: 设备密度<br>colorType: 图片颜色类型，RGB或者gray等，图片通道数量<br>rowBytes: 用来表示图片像素的字节数<br>alphaType: 图像透明度类型，是否有透明度或者没有透明度<br>isMutable: 是否易变的</p>
<p>这些属性在进行Parcel传输的时候，都会通过Parcel传递，另外也是为了方便图片操作。</p>
<h2 id="Java层与native层Bitmap"><a href="#Java层与native层Bitmap" class="headerlink" title="Java层与native层Bitmap"></a>Java层与native层Bitmap</h2><p>Bitmap的主要实现是在native层，Java层的Bitmap相当于是native层的接口。</p>
<h3 id="Java层Bitmap"><a href="#Java层Bitmap" class="headerlink" title="Java层Bitmap"></a>Java层Bitmap</h3><p>Bitmap实际上分为Java层和native层的，Java层包含了一个mBuffer数组用来存储像素，但总的来说Java层只是一个方便Java层应用访问的接口，最终还是通过native层来保存图片内容。在Java层中，我们常用的接口可能是createBitmap，getPixel，setPixel等，但实际上这些函数最终都是调用native层接口实现的，下面是Java层Bitmap的创建函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private static Bitmap createBitmap(DisplayMetrics display, int width, int height,</div><div class="line">        Config config, boolean hasAlpha) &#123;</div><div class="line">    if (width &lt;= 0 || height &lt;= 0) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;width and height must be &gt; 0&quot;);</div><div class="line">    &#125;</div><div class="line">    Bitmap bm = nativeCreate(null, 0, width, width, height, config.nativeInt, true);　// 这！！！</div><div class="line">    if (display != null) &#123;</div><div class="line">        bm.mDensity = display.densityDpi;</div><div class="line">    &#125;</div><div class="line">    bm.setHasAlpha(hasAlpha);</div><div class="line">    if (config == Config.ARGB_8888 &amp;&amp; !hasAlpha) &#123;</div><div class="line">        nativeErase(bm.mFinalizer.mNativeBitmap, 0xff000000);</div><div class="line">    &#125;</div><div class="line">    // No need to initialize the bitmap to zeroes with other configs;</div><div class="line">    // it is backed by a VM byte array which is by definition preinitialized</div><div class="line">    // to all zeroes.</div><div class="line">    return bm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bitmap还有很多native方法，具体可以看<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/graphics/Bitmap.java#1618" target="_blank" rel="external">Bitmap native 方法</a>。我们重点看createBitmap。</p>
<p>另外在Java层与native层对应的标记是mNativeBitmap变量，它保存的是native层Bitmap的指针地址。这样在native层通过reinterpret_cast即可得到具体的对象。关于这个，可以看Binder机制的实现<a href="http://blog.csdn.net/xxxzhi/article/details/51225455" target="_blank" rel="external">Android源码代理模式—Binder</a>。</p>
<h3 id="native层"><a href="#native层" class="headerlink" title="native层"></a>native层</h3><p>既然Bitmap的具体实现都是在native，那么看一下native层的Bitmap，native层的Bitmap在frameworks/base/core/jni/android/graphics/Bitmap.cpp中，对应的jni注册部分也在该文件下。看一下native层Bitmap的创建nativeCreate对应的Bitmap_creator函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static jobject Bitmap_creator(JNIEnv* env, jobject, jintArray jColors,</div><div class="line">                              jint offset, jint stride, jint width, jint height,</div><div class="line">                              jint configHandle, jboolean isMutable) &#123;</div><div class="line">    SkColorType colorType = GraphicsJNI::legacyBitmapConfigToColorType(configHandle);</div><div class="line">    if (NULL != jColors) &#123;</div><div class="line">        size_t n = env-&gt;GetArrayLength(jColors);</div><div class="line">        if (n &lt; SkAbs32(stride) * (size_t)height) &#123;</div><div class="line">            doThrowAIOOBE(env);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // ARGB_4444 is a deprecated format, convert automatically to 8888</div><div class="line">    if (colorType == kARGB_4444_SkColorType) &#123;</div><div class="line">        colorType = kN32_SkColorType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SkBitmap bitmap;</div><div class="line">    bitmap.setInfo(SkImageInfo::Make(width, height, colorType, kPremul_SkAlphaType));</div><div class="line"></div><div class="line">    Bitmap* nativeBitmap = GraphicsJNI::allocateJavaPixelRef(env, &amp;bitmap, NULL);</div><div class="line">    if (!nativeBitmap) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (jColors != NULL) &#123;</div><div class="line">        GraphicsJNI::SetPixels(env, jColors, offset, stride,</div><div class="line">                0, 0, width, height, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return GraphicsJNI::createBitmap(env, nativeBitmap,</div><div class="line">            getPremulBitmapCreateFlags(isMutable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看Bitmap的创建函数，从一创建开始，Bitmap就是先出现在native层的，Android中2D绘图是由skia框架实现的，在上述代码中就对应着SkBitmap。</p>
<p>而对于Java存储类型的Bitmap的创建是由GraphicsJNI的allocateJavaPixelRef完成的，allocateJavaPixelRef是从Java层分配像素数组，看看allocateJavaPixelRef的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">android::Bitmap* GraphicsJNI::allocateJavaPixelRef(JNIEnv* env, SkBitmap* bitmap,</div><div class="line">                                             SkColorTable* ctable) &#123;</div><div class="line">    const SkImageInfo&amp; info = bitmap-&gt;info();</div><div class="line">    if (info.fColorType == kUnknown_SkColorType) &#123;</div><div class="line">        doThrowIAE(env, &quot;unknown bitmap configuration&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size_t size;</div><div class="line">    if (!computeAllocationSize(*bitmap, &amp;size)) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // we must respect the rowBytes value already set on the bitmap instead of</div><div class="line">    // attempting to compute our own.</div><div class="line">    const size_t rowBytes = bitmap-&gt;rowBytes();</div><div class="line">    // 在这里分配</div><div class="line">    jbyteArray arrayObj = (jbyteArray) env-&gt;CallObjectMethod(gVMRuntime,</div><div class="line">                                                             gVMRuntime_newNonMovableArray,</div><div class="line">                                                             gByte_class, size); //在这创建Java层Array</div><div class="line">    if (env-&gt;ExceptionCheck() != 0) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    SkASSERT(arrayObj);</div><div class="line">    jbyte* addr = (jbyte*) env-&gt;CallLongMethod(gVMRuntime, gVMRuntime_addressOf, arrayObj); //获取地址</div><div class="line">    if (env-&gt;ExceptionCheck() != 0) &#123;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    SkASSERT(addr);</div><div class="line">    android::Bitmap* wrapper = new android::Bitmap(env, arrayObj, (void*) addr,</div><div class="line">            info, rowBytes, ctable); //创建native层对象, 在Bitmap构造函数中mPixelStorage中存储了jweak引用。</div><div class="line">    wrapper-&gt;getSkBitmap(bitmap);　// 在这里会将mPixelStorage的弱引用转换为强引用</div><div class="line">    // since we&apos;re already allocated, we lockPixels right away</div><div class="line">    // HeapAllocator behaves this way too</div><div class="line">    bitmap-&gt;lockPixels();</div><div class="line"></div><div class="line">    return wrapper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，native层是通过JNI方法，在Java层创建一个数组对象的，这个数组是对应在Java层的Bitmap对象的buffer数组，所以图像还是保存在Java堆的。而在native层这里它是通过weak指针来引用的，在需要的时候会转换为strong指针，用完之后又去掉strong指针，这样这个数组对象还是能够被Java堆自动回收。可以看一下native层的Bitmap构造函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Bitmap::Bitmap(JNIEnv* env, jbyteArray storageObj, void* address,</div><div class="line">            const SkImageInfo&amp; info, size_t rowBytes, SkColorTable* ctable)</div><div class="line">        : mPixelStorageType(PixelStorageType::Java) &#123;</div><div class="line">    env-&gt;GetJavaVM(&amp;mPixelStorage.java.jvm);</div><div class="line">    mPixelStorage.java.jweakRef = env-&gt;NewWeakGlobalRef(storageObj);//创建对Java层对象的弱引用</div><div class="line">    mPixelStorage.java.jstrongRef = nullptr;</div><div class="line">    mPixelRef.reset(new WrappedPixelRef(this, address, info, rowBytes, ctable));</div><div class="line">    // Note: this will trigger a call to onStrongRefDestroyed(), but</div><div class="line">    // we want the pixel ref to have a ref count of 0 at this point</div><div class="line">    mPixelRef-&gt;unref();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面jstrongRef一开始是赋值为null的，但是在bitmap的getSkBitmap方法会使用weakRef给他赋值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void Bitmap::getSkBitmap(SkBitmap* outBitmap) &#123;</div><div class="line">    assertValid();</div><div class="line">    android::AutoMutex _lock(mLock);</div><div class="line">    // Safe because mPixelRef is a WrappedPixelRef type, otherwise rowBytes()</div><div class="line">    // would require locking the pixels first.</div><div class="line">    outBitmap-&gt;setInfo(mPixelRef-&gt;info(), mPixelRef-&gt;rowBytes());</div><div class="line">    outBitmap-&gt;setPixelRef(refPixelRefLocked())-&gt;unref(); //refPixelRefLocked</div><div class="line">    outBitmap-&gt;setHasHardwareMipMap(hasHardwareMipMap());</div><div class="line">&#125;</div><div class="line">void Bitmap::pinPixelsLocked() &#123;  //refPixelRefLocked会调用这个方法</div><div class="line">    switch (mPixelStorageType) &#123;</div><div class="line">    case PixelStorageType::Invalid:</div><div class="line">        LOG_ALWAYS_FATAL(&quot;Cannot pin invalid pixels!&quot;);</div><div class="line">        break;</div><div class="line">    case PixelStorageType::External:</div><div class="line">    case PixelStorageType::Ashmem:</div><div class="line">        // Nothing to do</div><div class="line">        break;</div><div class="line">    case PixelStorageType::Java: &#123;</div><div class="line">        JNIEnv* env = jniEnv();</div><div class="line">        if (!mPixelStorage.java.jstrongRef) &#123;</div><div class="line">            mPixelStorage.java.jstrongRef = reinterpret_cast&lt;jbyteArray&gt;(</div><div class="line">                    env-&gt;NewGlobalRef(mPixelStorage.java.jweakRef));//赋值</div><div class="line">            if (!mPixelStorage.java.jstrongRef) &#123;</div><div class="line">                LOG_ALWAYS_FATAL(&quot;Failed to acquire strong reference to pixels&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在native层随时添加删除一个强引用，这样有利于更好地配合Java堆的垃圾回收。图片的数组可能会是非常耗内存的。</p>
<p>在创建了native层的Bitmap后，再用GraphicsJNI的createBitmap创建Java层的Bitmap对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">jobject GraphicsJNI::createBitmap(JNIEnv* env, android::Bitmap* bitmap,</div><div class="line">        int bitmapCreateFlags, jbyteArray ninePatchChunk, jobject ninePatchInsets,</div><div class="line">        int density) &#123;</div><div class="line">    bool isMutable = bitmapCreateFlags &amp; kBitmapCreateFlag_Mutable;</div><div class="line">    bool isPremultiplied = bitmapCreateFlags &amp; kBitmapCreateFlag_Premultiplied;</div><div class="line">    // The caller needs to have already set the alpha type properly, so the</div><div class="line">    // native SkBitmap stays in sync with the Java Bitmap.</div><div class="line">    assert_premultiplied(bitmap-&gt;info(), isPremultiplied);</div><div class="line"></div><div class="line">    jobject obj = env-&gt;NewObject(gBitmap_class, gBitmap_constructorMethodID,</div><div class="line">            reinterpret_cast&lt;jlong&gt;(bitmap), bitmap-&gt;javaByteArray(),</div><div class="line">            bitmap-&gt;width(), bitmap-&gt;height(), density, isMutable, isPremultiplied,</div><div class="line">            ninePatchChunk, ninePatchInsets);//创建Java层Bitmap对象</div><div class="line">    hasException(env); // For the side effect of logging.</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建过程中，将刚刚创建的Java层Array和native层的bitmap指针也都会传给Java层Bitmap的构造函数。</p>
<p>另外对于External存储类型的Bitmap，它的创建如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Bitmap::Bitmap(void* address, void* context, FreeFunc freeFunc,</div><div class="line">            const SkImageInfo&amp; info, size_t rowBytes, SkColorTable* ctable)</div><div class="line">        : mPixelStorageType(PixelStorageType::External) &#123;</div><div class="line">    mPixelStorage.external.address = address;</div><div class="line">    mPixelStorage.external.context = context;</div><div class="line">    mPixelStorage.external.freeFunc = freeFunc;</div><div class="line">    mPixelRef.reset(new WrappedPixelRef(this, address, info, rowBytes, ctable));</div><div class="line">    // Note: this will trigger a call to onStrongRefDestroyed(), but</div><div class="line">    // we want the pixel ref to have a ref count of 0 at this point</div><div class="line">    mPixelRef-&gt;unref();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而Ashmem则是保存一个fd，以及asm地址和大小:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Bitmap::Bitmap(void* address, int fd,</div><div class="line">            const SkImageInfo&amp; info, size_t rowBytes, SkColorTable* ctable)</div><div class="line">        : mPixelStorageType(PixelStorageType::Ashmem) &#123;</div><div class="line">    mPixelStorage.ashmem.address = address;</div><div class="line">    mPixelStorage.ashmem.fd = fd;</div><div class="line">    mPixelStorage.ashmem.size = ashmem_get_size_region(fd);</div><div class="line">    mPixelRef.reset(new WrappedPixelRef(this, address, info, rowBytes, ctable));</div><div class="line">    // Note: this will trigger a call to onStrongRefDestroyed(), but</div><div class="line">    // we want the pixel ref to have a ref count of 0 at this point</div><div class="line">    mPixelRef-&gt;unref();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>native层Bitmap会针对不同的存储类型，做不同的处理。</p>
<h2 id="Parcel传递"><a href="#Parcel传递" class="headerlink" title="Parcel传递"></a>Parcel传递</h2><p>首先在Java层Bitmap实现了Parcelable接口，所以他是能够通过Parcel来传递的,看看Bitmap的parcelable部分的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public final class Bitmap implements Parcelable &#123;</div><div class="line">    ...</div><div class="line">    /**</div><div class="line">     * Write the bitmap and its pixels to the parcel. The bitmap can be</div><div class="line">     * rebuilt from the parcel by calling CREATOR.createFromParcel().</div><div class="line">     * @param p    Parcel object to write the bitmap data into</div><div class="line">     */</div><div class="line">    public void writeToParcel(Parcel p, int flags) &#123;</div><div class="line">        checkRecycled(&quot;Can&apos;t parcel a recycled bitmap&quot;);</div><div class="line">        if (!nativeWriteToParcel(mFinalizer.mNativeBitmap, mIsMutable, mDensity, p)) &#123;</div><div class="line">            throw new RuntimeException(&quot;native writeToParcel failed&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static final Parcelable.Creator&lt;Bitmap&gt; CREATOR</div><div class="line">              = new Parcelable.Creator&lt;Bitmap&gt;() &#123;</div><div class="line">            </div><div class="line">    </div><div class="line">        public Bitmap More ...createFromParcel(Parcel p) &#123;</div><div class="line">            Bitmap bm = nativeCreateFromParcel(p);</div><div class="line">            if (bm == null) &#123;</div><div class="line">                 throw new RuntimeException(&quot;Failed to unparcel Bitmap&quot;);</div><div class="line">            &#125;</div><div class="line">            return bm;</div><div class="line">        &#125;</div><div class="line">        public Bitmap[] More ...newArray(int size) &#123;</div><div class="line">            return new Bitmap[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写入和读取分别调用了nativeWriteToParcel，nativeCreateFromParcel。先看看nativeWriteToParcel对应的native层方法Bitmap_writeToParcel:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">static jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,</div><div class="line">                                     jlong bitmapHandle,</div><div class="line">                                     jboolean isMutable, jint density,</div><div class="line">                                     jobject parcel) &#123;</div><div class="line">    </div><div class="line">    //根据handle创建native层图片，写入图片相关的一些附加信息，width,height,colorType,density等等。</div><div class="line">    if (parcel == NULL) &#123;</div><div class="line">        SkDebugf(&quot;------- writeToParcel null parcel\n&quot;);</div><div class="line">        return JNI_FALSE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    android::Parcel* p = android::parcelForJavaObject(env, parcel);</div><div class="line">    SkBitmap bitmap;</div><div class="line"></div><div class="line">    android::Bitmap* androidBitmap = reinterpret_cast&lt;Bitmap*&gt;(bitmapHandle);</div><div class="line">    androidBitmap-&gt;getSkBitmap(&amp;bitmap);</div><div class="line"></div><div class="line">    p-&gt;writeInt32(isMutable);</div><div class="line">    p-&gt;writeInt32(bitmap.colorType());</div><div class="line">    p-&gt;writeInt32(bitmap.alphaType());</div><div class="line">    p-&gt;writeInt32(bitmap.width());</div><div class="line">    p-&gt;writeInt32(bitmap.height());</div><div class="line">    p-&gt;writeInt32(bitmap.rowBytes());</div><div class="line">    p-&gt;writeInt32(density);</div><div class="line"></div><div class="line">    if (bitmap.colorType() == kIndex_8_SkColorType) &#123;</div><div class="line">        SkColorTable* ctable = bitmap.getColorTable();</div><div class="line">        if (ctable != NULL) &#123;</div><div class="line">            int count = ctable-&gt;count();</div><div class="line">            p-&gt;writeInt32(count);</div><div class="line">            memcpy(p-&gt;writeInplace(count * sizeof(SkPMColor)),</div><div class="line">                   ctable-&gt;readColors(), count * sizeof(SkPMColor));</div><div class="line">        &#125; else &#123;</div><div class="line">            p-&gt;writeInt32(0);   // indicate no ctable</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 关键看这部分传输代码！！！！</div><div class="line">    // Transfer the underlying ashmem region if we have one and it&apos;s immutable.</div><div class="line">    android::status_t status;</div><div class="line">    int fd = androidBitmap-&gt;getAshmemFd();　//获取匿名共享内存，如果是图片是在匿名共享内存</div><div class="line">    if (fd &gt;= 0 &amp;&amp; !isMutable &amp;&amp; p-&gt;allowFds()) &#123;　//如果成功获取，并且图片不是mutable，同时允许fd(mAllowFds默认为True)</div><div class="line">        status = p-&gt;writeDupImmutableBlobFileDescriptor(fd); //最终会直接把文件fd传过去</div><div class="line">        if (status) &#123;</div><div class="line">            doThrowRE(env, &quot;Could not write bitmap blob file descriptor.&quot;);</div><div class="line">            return JNI_FALSE;</div><div class="line">        &#125;</div><div class="line">        return JNI_TRUE;</div><div class="line">    &#125;</div><div class="line">    // 如果不能通过fd传递，则传输Blob数据，也就是相当于直接把像素数据传递过去。</div><div class="line">    // Copy the bitmap to a new blob.</div><div class="line">    bool mutableCopy = isMutable;</div><div class="line"></div><div class="line">    size_t size = bitmap.getSize();</div><div class="line">    android::Parcel::WritableBlob blob;</div><div class="line">    status = p-&gt;writeBlob(size, mutableCopy, &amp;blob);</div><div class="line">    if (status) &#123;</div><div class="line">        doThrowRE(env, &quot;Could not copy bitmap to parcel blob.&quot;);</div><div class="line">        return JNI_FALSE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bitmap.lockPixels();</div><div class="line">    const void* pSrc =  bitmap.getPixels();</div><div class="line">    if (pSrc == NULL) &#123;</div><div class="line">        memset(blob.data(), 0, size);</div><div class="line">    &#125; else &#123;</div><div class="line">        memcpy(blob.data(), pSrc, size);</div><div class="line">    &#125;</div><div class="line">    bitmap.unlockPixels();</div><div class="line"></div><div class="line">    blob.release();</div><div class="line">    return JNI_TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以知道，如果是匿名共享内存存储，那么writeToParcel会通过匿名共享内存的方式将匿名共享文件传递过去，看看writeDupFileDescriptor方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeDupFileDescriptor(int fd)</div><div class="line">&#123;</div><div class="line">    int dupFd = dup(fd);</div><div class="line">    if (dupFd &lt; 0) &#123;</div><div class="line">        return -errno;</div><div class="line">    &#125;</div><div class="line">    status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);</div><div class="line">    if (err) &#123;</div><div class="line">        close(dupFd);</div><div class="line">    &#125;</div><div class="line">    return err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是保存的数组数据，那么会直接将像素数据转换为Blob来传递。这是在6.0的源码中是如此的，在5.0的源码中，还没有增加这些东西，5.0的源码中只有普通的将像素存储区域memcopy来传。Android在3.0中增加了inBitmap，在4.4增加了不同大小的图片使用inBitmap。</p>
<p>而nativeCreateFromParcel对应了native层的Bitmap_createFromParcel，在6.0的源码里面源码如下(去掉了DEBUG_PARCEL):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) &#123;</div><div class="line">    ......</div><div class="line">    // 一开始读取图片相关的一些信息，比如说width, height, density, colorType等等，并存于SkImageInfo中。并且对ColorType的相关处理，这些占用的内存都很小，关键看像素的传递</div><div class="line">   </div><div class="line">    SkColorTable* ctable = NULL;</div><div class="line">    if (colorType == kIndex_8_SkColorType) &#123;</div><div class="line">        int count = p-&gt;readInt32();</div><div class="line">        if (count &lt; 0 || count &gt; 256) &#123;</div><div class="line">            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,</div><div class="line">            // inclusive.</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        if (count &gt; 0) &#123;</div><div class="line">            size_t size = count * sizeof(SkPMColor);</div><div class="line">            const SkPMColor* src = (const SkPMColor*)p-&gt;readInplace(size);</div><div class="line">            if (src == NULL) &#123;</div><div class="line">                return NULL;</div><div class="line">            &#125;</div><div class="line">            ctable = new SkColorTable(src, count);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Read the bitmap blob.</div><div class="line">    size_t size = bitmap-&gt;getSize();</div><div class="line">    android::Parcel::ReadableBlob blob;</div><div class="line">    android::status_t status = p-&gt;readBlob(size, &amp;blob);　//这里对应writeDupFileDescriptor</div><div class="line">    if (status) &#123;</div><div class="line">        SkSafeUnref(ctable);</div><div class="line">        doThrowRE(env, &quot;Could not read bitmap blob.&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">     // 关键看这部分传输代码！！！！</div><div class="line">    // Map the bitmap in place from the ashmem region if possible otherwise copy.</div><div class="line">    Bitmap* nativeBitmap;</div><div class="line">    if (blob.fd() &gt;= 0 &amp;&amp; (blob.isMutable() || !isMutable) &amp;&amp; (size &gt;= ASHMEM_BITMAP_MIN_SIZE)) &#123;</div><div class="line"></div><div class="line">        // Dup the file descriptor so we can keep a reference to it after the Parcel</div><div class="line">        // is disposed.</div><div class="line">        int dupFd = dup(blob.fd());</div><div class="line">        if (dupFd &lt; 0) &#123;</div><div class="line">            blob.release();</div><div class="line">            SkSafeUnref(ctable);</div><div class="line">            doThrowRE(env, &quot;Could not allocate dup blob fd.&quot;);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Map the pixels in place and take ownership of the ashmem region.</div><div class="line">        nativeBitmap = GraphicsJNI::mapAshmemPixelRef(env, bitmap.get(),</div><div class="line">                ctable, dupFd, const_cast&lt;void*&gt;(blob.data()), !isMutable);</div><div class="line">        SkSafeUnref(ctable);</div><div class="line">        if (!nativeBitmap) &#123;</div><div class="line">            close(dupFd);</div><div class="line">            blob.release();</div><div class="line">            doThrowRE(env, &quot;Could not allocate ashmem pixel ref.&quot;);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Clear the blob handle, don&apos;t release it.</div><div class="line">        blob.clear();</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        // Copy the pixels into a new buffer.</div><div class="line">        nativeBitmap = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);</div><div class="line">        SkSafeUnref(ctable);</div><div class="line">        if (!nativeBitmap) &#123;</div><div class="line">            blob.release();</div><div class="line">            doThrowRE(env, &quot;Could not allocate java pixel ref.&quot;);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">        bitmap-&gt;lockPixels();</div><div class="line">        memcpy(bitmap-&gt;getPixels(), blob.data(), size);</div><div class="line">        bitmap-&gt;unlockPixels();</div><div class="line"></div><div class="line">        // Release the blob handle.</div><div class="line">        blob.release();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return GraphicsJNI::createBitmap(env, nativeBitmap,</div><div class="line">            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个是与writeToParcel相互对应的，如果是asm则直接读取文件fd，如果是数据，则传对应数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面就是Bitmap在Java层与native的表现，Bitmap的操作基本都是在native层，Java层与native层通过一个handle相互对应。在6.0Bitmap总共有四种存储形式，也增加了asm的存储。在进行Parcel传输的时候，针对asm，Parcel传输的fd，这样能够减少很多内存的消耗。在Android6.0内部，很多图片也开始存储在asm里面了。不过在Java层还没有提供将图片保存在匿名共享内存里面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/20/xposed-source-read-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/20/xposed-source-read-summary/" itemprop="url">Xposed源码阅读小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-20T00:00:00+08:00">
                2016-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近借助着邓凡平的这篇文章<a href="http://www.infoq.com/cn/articles/android-in-depth-xposed" target="_blank" rel="external">深入理解Android（三）：Xposed详解</a>去阅读了一下Xposed的Hook源码，在这里总结一下Xposed使用的一些东西。</p>
<h2 id="Xposed实现原理简述"><a href="#Xposed实现原理简述" class="headerlink" title="Xposed实现原理简述"></a>Xposed实现原理简述</h2><p>Xposed实际上是将Android的zygote给替换了，Xposed自己搞了一个zygote，在这个zygote中加载安装的modules,将这些modules hook到指定的方法当中。最核心的功能就是findAndHookMethod这个函数，它找到对应的Method，将XC_Method_Hook(想要添加的Hook信息)与其匹配起来，将Method的访问标志改为native，并且将它的nativeFunc赋值为hookedMethodCallback，使得Java层调用的Method时候，虚拟机会调用native层hookedMethodCallback方法，而hookedMethodCallback方法先调用XC_Method_Hook接口的before方法，然后再调用原来的Method方法，之后再调用after方法，最后返回结果。整个Hook的流程就是这样的，里面每个细节都需要很多知识。下面分别介绍Xposed用到的东西。</p>
<h2 id="Xposed用到的知识"><a href="#Xposed用到的知识" class="headerlink" title="Xposed用到的知识"></a>Xposed用到的知识</h2><h3 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h3><p>首先自然就是zygote了，zygote是Android中所有应用程序的父进程，所以应用程序进程都要经过zygote，zygote通过fork创建一个新的应用程序进程。如果替换掉zygote，那么创建新的进程的时候，zygote的很多东西还是可以影响到新的应用程序进程。</p>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>对于这部分，我本来就接触较多，不过zygote中大部分都是使用动态注册JNI函数，env-&gt;RegisterNatives</p>
<h3 id="dvm方法"><a href="#dvm方法" class="headerlink" title="dvm方法"></a>dvm方法</h3><p>Dalvik虚拟机提供了很多的dvm开头的方法，在xposed/zygote里面使用了很多，它是Dalvik虚拟机提供的方法。</p>
<h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>用于加载已经安装了的APK的Class。DexClassLoader是能够加载未安装的apk的dex文件。</p>
<h3 id="修改method-访问标志"><a href="#修改method-访问标志" class="headerlink" title="修改method 访问标志"></a>修改method 访问标志</h3><p>在native层，虚拟机提供了方法修改Method的访问标志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET_METHOD_FLAG(method,ACC_NATIVE)</div></pre></td></tr></table></figure></p>
<p>通过该方法将Method修改为native方法，这样当运行Java层对应的方法的时候，虚拟机会调用nativeFunc。这样就提供了一种hook的契机。</p>
<h3 id="Dalvik-native-interface"><a href="#Dalvik-native-interface" class="headerlink" title="Dalvik native interface"></a>Dalvik native interface</h3><p>Dalvik提供了两种internative interface。</p>
<p>一种是供应用程序使用的，使用javah生成，或者直接使用env-&gt;RegisterNatives注册，这种方式是我们经常在jni开放中使用的，每个参数都会相互对应。</p>
<p>另外一种是类似于这种接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void hookedMethodCallback(const u4* args, JValue* pResult, const Method* method, ::Thread* self)</div></pre></td></tr></table></figure></p>
<p>将这个函数与Java层的native函数对应，参数和返回参数都放在args中，method是对应的Java层方法在native层的对象。这种native interface的方式只能够在Dalvik虚拟机内部使用。一个这样的函数声明，可以对应Java层中任何native方法，这样就可以很方便地将这种函数与Java层的native方法对应了，只要一个方法就够了。</p>
<p>在xposed中，findMethodAndHook的过程中就将对应的Method的nativeFunc赋值为&amp;hookedMethodCallback。这样在执行Java层方法的时候，Dalvik虚拟机就会运行hookedMethodCallback方法了。下面这段代码是修改访问标志和nativeFunc的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SET_METHOD_FLAG(method, ACC_NATIVE);</div><div class="line">method-&gt;nativeFunc = &amp;hookedMethodCallback;</div><div class="line">method-&gt;insns = (const u2*) hookInfo;  //这里是把Hook方法也加入到method当中了。这样在hookedMethodCallback中也可以执行添加的hook方法。</div><div class="line">method-&gt;registersSize = method-&gt;insSize;</div><div class="line">method-&gt;outsSize = 0;</div></pre></td></tr></table></figure></p>
<h2 id="阅读中的疑惑"><a href="#阅读中的疑惑" class="headerlink" title="阅读中的疑惑"></a>阅读中的疑惑</h2><h3 id="如何Hook"><a href="#如何Hook" class="headerlink" title="如何Hook"></a>如何Hook</h3><p>上面已经介绍了</p>
<h3 id="如何Hook到APK里面的函数的"><a href="#如何Hook到APK里面的函数的" class="headerlink" title="如何Hook到APK里面的函数的"></a>如何Hook到APK里面的函数的</h3><p>一开始一直在想Xposed是怎么Hook APK里面的方法，因为他需要影响到不同的进程，我一直觉得是在启动对应的应用程序的时候再去做的工作，但是发现实际上不是的。它是一开始就Hook了对应的方法，在zygote进程中。为什么在之后还是能够使用呢？因为应用程序都是zygote子进程，在fork的时候，父进程load的Class还是会在子进程当中，fork的时候复制了一份。</p>
<p>还有一些正在学习，比如说Dalvik虚拟机的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看源码的时候，一开始了解整个源码的流程，然后在脑子里想它具体是怎么实现的，遇到不知道怎么弄的时候，再去重新看源码，不断思考为什么，这样的过程能够学到很多东西，也能够更好地理解源码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/19/feature-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/19/feature-source-code/" itemprop="url">FutureTask源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-19T00:00:00+08:00">
                2016-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FutureTask是JDK1.6新增的内容，间接实现了Future, Runnable接口。前面已经介绍过了Future的get方法会阻塞在那，等待执行完成，获取结果，那么FutureTask是怎么实现这一功能的呢？</p>
<h2 id="相关类简介"><a href="#相关类简介" class="headerlink" title="相关类简介"></a>相关类简介</h2><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport是用来创建锁及其他同步类的基本线程阻塞元素，它的park和 unpark能够分别阻塞线程和解除线程阻塞。它提供了可以指定阻塞时长的park方法。park和unpark的基本接口为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void park() &#123;</div><div class="line">    unsafe.park(false, 0L);</div><div class="line">&#125;</div><div class="line">public static void unpark(Thread thread) &#123;</div><div class="line">    if (thread != null)</div><div class="line">        unsafe.unpark(thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>unpark需要指定对应的线程，而park是将当前线程阻塞。其实这里也提供阻塞线程新的方式，我们已经或者用忙等待，或者用中断睡眠的方式阻塞唤醒线程，这里可以通过LockSupport实现。FutureTask就是用这种方式实现的。下面看一下unsafe，它是一个Unsafe类</p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Java不能够直接访问操作系统底层，而是通过本地方法来访问。Unsafe提供了硬件级别的原子访问，主要提供一下功能：</p>
<ol>
<li>分配释放内存</li>
<li>定位某个字段的内存位置</li>
<li>挂起一个线程和恢复，更多的是通过LockSupport来访问。park和unpark</li>
<li>CAS操作，比较一个对象的某个位置的内存值是否与期望值一致，一致则更新对应值，此更新是不可中断的。主要方法是compareAndSwap*。</li>
</ol>
<h2 id="FutureTask源码"><a href="#FutureTask源码" class="headerlink" title="FutureTask源码"></a>FutureTask源码</h2><p>FutureTask主要是通过这两个类来实现的，调用get的时候如果异步线程还没有执行完，就是先park当前线程，如果超时则返回，这个时候如果异步线程还是没有执行完成，则返回失败。如果异步线程执行完成了，则会调用LockSupport的unpark方法，将主线程（与异步线程对应）解除阻塞，而主线程解除阻塞后就会获取执行的结果，get函数返回结果。下面看一下get方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public V get(long timeout, TimeUnit unit)</div><div class="line">    throws InterruptedException, ExecutionException, TimeoutException &#123;</div><div class="line">    if (unit == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    int s = state;</div><div class="line">    if (s &lt;= COMPLETING &amp;&amp;</div><div class="line">        (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</div><div class="line">        throw new TimeoutException();</div><div class="line">    return report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它实际实现wait的是awaitDone方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private int awaitDone(boolean timed, long nanos)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</div><div class="line">    WaitNode q = null;</div><div class="line">    boolean queued = false;</div><div class="line">    for (;;) &#123;</div><div class="line">        if (Thread.interrupted()) &#123;</div><div class="line">            removeWaiter(q);</div><div class="line">            throw new InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int s = state;</div><div class="line">        if (s &gt; COMPLETING) &#123;</div><div class="line">            if (q != null)</div><div class="line">                q.thread = null;</div><div class="line">            return s;</div><div class="line">        &#125;</div><div class="line">        else if (s == COMPLETING) // cannot time out yet, 已经完成了，但是状态还在COMPLETING，yield一下下次再判断。</div><div class="line">            Thread.yield();</div><div class="line">        else if (q == null)　//如果队列还是为创建一个等待节点</div><div class="line">            q = new WaitNode();</div><div class="line">        else if (!queued) //如果还没有加入waiters队列，则先将waiters赋值给q.next，然后判断waiters是否已经是q.next，如果是，则将q赋值给waiters(waitersOffset对应waiters在FutureTask中的偏移量)。关键在于此一系列操作能保证一致性。</div><div class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,</div><div class="line">                                                 q.next = waiters, q);</div><div class="line">        else if (timed) &#123; //如果是需要判断超时，则使用parkNanos</div><div class="line">            nanos = deadline - System.nanoTime();</div><div class="line">            if (nanos &lt;= 0L) &#123;</div><div class="line">                removeWaiter(q);</div><div class="line">                return state;</div><div class="line">            &#125;</div><div class="line">            LockSupport.parkNanos(this, nanos);</div><div class="line">        &#125;</div><div class="line">        else </div><div class="line">            LockSupport.park(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>waitDone就是将当前线程加入等待队列(WaitNode有当前Thread的Thread变量)，然后用LockSupport将自己阻塞，等待超时或者被解除阻塞后，判断是否已经完成(state为&gt;= COMPLETING)，如果未完成(state&lt; COMPLETING)抛出超时异常，如果已完成则稍等或者直接返回结果。</p>
<p>下面看看异步线程如何唤醒当前线程，从run方法开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">    if (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</div><div class="line">                                     null, Thread.currentThread())) //给runner赋值</div><div class="line">        return;</div><div class="line">    try &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        if (c != null &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            boolean ran;</div><div class="line">            try &#123;</div><div class="line">                result = c.call();</div><div class="line">                ran = true;</div><div class="line">            &#125; catch (Throwable ex) &#123;</div><div class="line">                result = null;</div><div class="line">                ran = false;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            if (ran)　//已经运行完则设置结果，前面一段是调用Callable运行需要做的操作</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>set方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void set(V v) &#123;</div><div class="line">        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; //原子操作state</div><div class="line">            outcome = v;</div><div class="line">            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</div><div class="line">            finishCompletion();//通知线程</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>finishCompletion:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void finishCompletion() &#123;</div><div class="line">    // assert state &gt; COMPLETING;</div><div class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</div><div class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;//如果已经赋值给q ,则对waiter置null</div><div class="line">            for (;;) &#123;　//一个一个地unpark。</div><div class="line">                Thread t = q.thread;</div><div class="line">                if (t != null) &#123;</div><div class="line">                    q.thread = null;</div><div class="line">                    LockSupport.unpark(t);</div><div class="line">                &#125;</div><div class="line">                WaitNode next = q.next;</div><div class="line">                if (next == null)</div><div class="line">                    break;</div><div class="line">                q.next = null; // unlink to help gc</div><div class="line">                q = next;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    done(); //默认实现什么也不做</div><div class="line"></div><div class="line">    callable = null;        // to reduce footprint</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码就是遍历waiters,然后解除他们的阻塞。这样整个流程就算完了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在整个FeatureTask中没有直接使用锁机制，而是通过LockSupport来阻塞线程，唤醒线程。对于多线程访问FeatureTask的waiters,state，都是采用Unsafe来操作，避免使用锁（毕竟锁其实很耗时），改为直接原子操作对应的变量。FeatureTask是一个非常好的Unsafe和LockSupport例子。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/16/java-callable-future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/16/java-callable-future/" itemprop="url">Callable, Future和FutureTask简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-16T00:00:00+08:00">
                2016-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDK1.5后新增了一些接口用于并发编程的接口，Callable，Future。以及1.6添加了FutureTask。之前看到了他们的使用，JDK1.8还添加了CompletableFuture，一直想了解一下这些东西。这里记录下对Callable, Future和FutureTask的理解。</p>
<h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><p>FutureTask实现了RunnableFuture接口，而RunnableFuture继承了Runnable，Future接口。FutureTask又有一个Callable参数的构造函数，下面分别介绍这些接口。</p>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>这个是在Java一开始就出现了的接口，只有一个接口方法run，表示可以被运行的类。可以放到线程池，Thread中运行。跟Thread是两种不同的实现方式。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future<v></v></h3><p>这是在JDK1.5新增的接口，展示异步执行的结果(结果，将来的，Future)。他有以下几个方法:</p>
<ul>
<li>cancel: 尝试去取消这个任务，如果该任务已经完成，或者已经取消，或者其他什么原因将不能取消。</li>
<li>get: 可以通过get方法获取异步线程的结果，如果没有执行完成则阻塞当前线程，等待异步线程执行完获取结果。</li>
<li>isDone: 判断该任务是否已经完成。如果是被取消，中断等，该方法也会返回true。</li>
<li>isCancelled: 判断该任务是否已经取消。</li>
</ul>
<p>Runnable和Thread都有一个问题，就是不能够直接获取异步线程运行的结果，而Future可以做到。</p>
<h3 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture<v></v></h3><p>实现了Runnable接口和Future接口。</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable<v></v></h3><p>一个可以返回结果的接口。只有一个方法call。</p>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><h3 id="使用Callable放到线程池中运行。"><a href="#使用Callable放到线程池中运行。" class="headerlink" title="使用Callable放到线程池中运行。"></a>使用Callable放到线程池中运行。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class TestFuture &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException&#123;</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        Task task = new Task();</div><div class="line">        Future&lt;Integer&gt; future = executor.submit(task);</div><div class="line">        // do something</div><div class="line">        System.out.println(&quot;可以先做一些事情，再去获取运行结果&quot;);</div><div class="line">        if(!future.isDone())&#123;</div><div class="line">            // you also can do something.</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;运行结果: &quot;+future.get()); // 可能会阻塞等待结果</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static class Task implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            System.out.println(&quot;异步任务开始运行&quot;);</div><div class="line">            TimeUnit.SECONDS.sleep(3);</div><div class="line">            int sum = 0 ;</div><div class="line">            for(int i = 0 ; i != 200; ++i)&#123;</div><div class="line">                sum+=i;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;异步任务完成运行&quot;);</div><div class="line">            return sum;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//运行结果</div><div class="line">/*</div><div class="line">可以先做一些事情，再去获取运行结果</div><div class="line">异步任务开始运行</div><div class="line">异步任务完成运行</div><div class="line">运行结果: 19900</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>可以自己实现Callable接口，Executor执行完成后会返回一个Future对象。在获取运行结果前，可以先做一些其他的事情。</p>
<h3 id="使用FutureTask"><a href="#使用FutureTask" class="headerlink" title="使用FutureTask"></a>使用FutureTask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class TestFutureTask &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException&#123;</div><div class="line">        ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Task());</div><div class="line">        executor.submit(futureTask); //调用的submit(Runnable runnable) 方法</div><div class="line">        // do something</div><div class="line">        System.out.println(&quot;可以先做一些事情，再去获取运行结果&quot;);</div><div class="line">        if(!futureTask.isDone())&#123;</div><div class="line">            // you also can do something.</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;运行结果: &quot;+futureTask.get()); // 可能会阻塞等待结果</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    static class Task implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Integer call() throws Exception &#123;</div><div class="line">            System.out.println(&quot;异步任务开始运行&quot;);</div><div class="line">            TimeUnit.SECONDS.sleep(3);</div><div class="line">            int sum = 0 ;</div><div class="line">            for(int i = 0 ; i != 200; ++i)&#123;</div><div class="line">                sum+=i;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;异步任务完成运行&quot;);</div><div class="line">            return sum;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟前面直接使用Callable结果是一样的，只是使用方式有点不一样。这里不需要从submit中获得Future对象，直接就是传入的那个参数futureTask，在有些使用使用起来会更加方便。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得Future接口提供了一种异步操作新的思路，Runnable和Thread都是直接执行完就没有了，并没有获得执行结果的接口，但是Future可以获得执行结果。Future就是用来展示执行结果。当然Future这一系列接口的使用远远不止这些，Future的get方法还可以设置超时时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/12/android-view-dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/12/android-view-dispatch/" itemprop="url">关于Android事件派发流程的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-12T00:00:00+08:00">
                2016-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以前看了很多人介绍的Android事件派发流程，但最近使用那些来写代码的时候出现了不少错误。所以回顾一下整个流程，简单介绍从手触摸屏幕开始到事件在View树派发。从源码上分析ViewGroup.dispatchTouchEvent。</p>
<h3 id="事件从触摸到View简述"><a href="#事件从触摸到View简述" class="headerlink" title="事件从触摸到View简述"></a>事件从触摸到View简述</h3><p>Android的事件产生是从我们触摸屏幕开始，在经过Input子系统，最后达到我们的应用程序(或者经过WindowManagerService到达应用程序)。</p>
<p>而其中Input子系统在Java层对应着InputManagerService，其主要在native层，由InputReader读取EventHub的元数据，将这些数据加工成InputEvent，最后发到InputDispatcher，而InputDispatcher则负责将时间发到应用程序，Input子系统流程可以参见这篇文章<a href="http://www.cnblogs.com/haiming/p/3318614.html" target="_blank" rel="external">Android Framework——之Input子系统</a>。</p>
<p>对于应用层的事件流程，主要是下面的流程图所示：<br><img src="http://xxxzhi.github.io/images/touch-event-application.png" alt="此处输入图片的描述"><br>其中最后一步就是我们经常说的View事件派发流程。另外上面DecorView是经过了两次，第一次是调用DecorView的dispatchTouchEvent，它的源码是:</p>
<pre><code>@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    final Callback cb = getCallback();
    return cb != null &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev)
            : super.dispatchTouchEvent(ev);
}
</code></pre><p>Callback就是Window.Callback，Activity实现了这个接口。在Activity的attach函数中，会调用window的setCallback，将Activity设置给Window。所以这里getCallback返回的就是Activity，最终会调用Activity的dispatchTouchEvent。下面看一下Activity的dispatchTouchEvent函数:</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>在ACTION_DOWN的时候会调用onUserInteraction方法，然后调用Window（实际上是PhoneWindow)的superDispatchTouchEvent，<strong><em>如果Window的superDispatchTouchEvent消耗了事件，则直接返回，不会调用Activity的onTouchEvent方法。</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    return mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而DecorView的superDispatchTouchEvent为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    return super.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终还是调用DecorView的父类的dispatchTouchEvent，DecorView的父类是FrameLayout，它没实现该方法，最终会调用ViewGroup的dispatchTouchEvent方法。从这里开始就进入了view树的时间派发流程了。</p>
<h3 id="View树的事件派发流程"><a href="#View树的事件派发流程" class="headerlink" title="View树的事件派发流程"></a>View树的事件派发流程</h3><p>这里从源码上分析事件派发的一些特性。事件派发最开始会进入到ViewGroup的dispatchTouchEvent(DecorVIew父类)，下面是ViewGroup的dispatchTouchEvent伪代码的分析，直接在对应的代码部分加了注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    //一开始做一些调试验证，另外如果事件的目标是focused view,并且当前view就是一个focused view,</div><div class="line">    //有可能view的子View就会处理这次事件，所以将targetAccessibilityFocus设置为false。</div><div class="line">    ...</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    boolean handled = false;</div><div class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;　//检查event是否是安全的</div><div class="line">        final int action = ev.getAction();</div><div class="line">        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</div><div class="line"></div><div class="line">        // Handle an initial down.</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            // Throw away all previous state when starting a new touch gesture.</div><div class="line">            // The framework may have dropped the up or cancel event for the previous gesture</div><div class="line">            // due to an app switch, ANR, or some other state change.</div><div class="line">            //清除之前的事件状态。比如说在app切换，ANR或其他状态改变时，系统框架将会去掉up或cancel事件。在这里会将mFirstTouchTarget清空，mFirstTouchTarget是保存了会接受事件的View处理对象。</div><div class="line">            cancelAndClearTouchTargets(ev);</div><div class="line">            resetTouchState();　//这里会将mGroupFlags的FLAG_DISALLOW_INTERCEPT标识清除，</div><div class="line">            //1. 每次事件流开始的时候都会先清除FLAG_DISALLOW_INTERCEPT，所以子view的requestDisallowInterceptTouchEvent只有当次事件流有效。</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 判断是否需要拦截事件，去判断是否拦截事件的条件是此次事件是DOWN事件，或者有子类会处理这次事件(mFirstTouchTarget不为null)，并且FLAG_DISALLOW_INTERCEPT没被设置。</div><div class="line">        final boolean intercepted;</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                || mFirstTouchTarget != null) &#123;</div><div class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">            if (!disallowIntercept) &#123;</div><div class="line">                //2. 只有有TouchTarget并且没有被disallow，或者是ACTION_DOWN时才会调用onInterceptTouchEvent。</div><div class="line">                intercepted = onInterceptTouchEvent(ev);</div><div class="line">                ev.setAction(action); // restore action in case it was changed</div><div class="line">            &#125; else &#123;</div><div class="line">                intercepted = false;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // There are no touch targets and this action is not an initial down</div><div class="line">            // so this view group continues to intercept touches.</div><div class="line">            intercepted = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If intercepted, start normal event dispatch. Also if there is already</div><div class="line">        // a view that is handling the gesture, do normal event dispatch.</div><div class="line">        if (intercepted || mFirstTouchTarget != null) &#123;</div><div class="line">            ev.setTargetAccessibilityFocus(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Check for cancelation.判断是否取消</div><div class="line">        final boolean canceled = resetCancelNextUpFlag(this)</div><div class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</div><div class="line"></div><div class="line">        // Update list of touch targets for pointer down, if needed.</div><div class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</div><div class="line">        TouchTarget newTouchTarget = null;</div><div class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</div><div class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line"></div><div class="line">            // If the event is targeting accessiiblity focus we give it to the</div><div class="line">            // view that has accessibility focus and if it does not handle it</div><div class="line">            // we clear the flag and dispatch the event to all children as usual.</div><div class="line">            // We are looking up the accessibility focused host to avoid keeping</div><div class="line">            // state since these events are very rare.</div><div class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</div><div class="line">                    ? findChildWithAccessibilityFocus() : null;</div><div class="line"></div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</div><div class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">                final int actionIndex = ev.getActionIndex(); // always 0 for down</div><div class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</div><div class="line">                        : TouchTarget.ALL_POINTER_IDS;</div><div class="line"></div><div class="line">                // Clean up earlier touch targets for this pointer id in case they</div><div class="line">                // have become out of sync.</div><div class="line">                removePointersFromTouchTargets(idBitsToAssign);</div><div class="line"></div><div class="line">                final int childrenCount = mChildrenCount;</div><div class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</div><div class="line">                    final float x = ev.getX(actionIndex);</div><div class="line">                    final float y = ev.getY(actionIndex);</div><div class="line">                    // Find a child that can receive the event.</div><div class="line">                    // Scan children from front to back.</div><div class="line">                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">                    final boolean customOrder = preorderedList == null</div><div class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">                    final View[] children = mChildren;</div><div class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                        final int childIndex = customOrder</div><div class="line">                                ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">                        final View child = (preorderedList == null)</div><div class="line">                                ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">                        // If there is a view that has accessibility focus we want it</div><div class="line">                        // to get the event first and if not handled we will perform a</div><div class="line">                        // normal dispatch. We may do a double iteration but this is</div><div class="line">                        // safer given the timeframe.</div><div class="line">                        if (childWithAccessibilityFocus != null) &#123;</div><div class="line">                            if (childWithAccessibilityFocus != child) &#123;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            childWithAccessibilityFocus = null;</div><div class="line">                            i = childrenCount - 1;</div><div class="line">                        &#125;</div><div class="line">                        //判断当前的child是否可以接收事件，并且事件是否在当前的view范围</div><div class="line">                        if (!canViewReceivePointerEvents(child)</div><div class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</div><div class="line">                            ev.setTargetAccessibilityFocus(false);</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        newTouchTarget = getTouchTarget(child);</div><div class="line">                        if (newTouchTarget != null) &#123;</div><div class="line">                            // Child is already receiving touch within its bounds.</div><div class="line">                            // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        resetCancelNextUpFlag(child);</div><div class="line">                                    //3.dispatchTransformedTouchEvent会将Event转化为child坐标空间(getX的变化)，然后去除无关的points id，如果有必要更改事件，最后调用child.dispatchTouchEvent。 dispatchTransformedTouchEvent把事件派发给child，如果child成功处理了，则会将child添加到mFirstTouchTarget</div><div class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</div><div class="line">                            // Child wants to receive touch within its bounds.</div><div class="line">                            mLastTouchDownTime = ev.getDownTime();</div><div class="line">                            if (preorderedList != null) &#123;</div><div class="line">                                // childIndex points into presorted list, find original index</div><div class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</div><div class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                                        mLastTouchDownIndex = j;</div><div class="line">                                        break;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                mLastTouchDownIndex = childIndex;</div><div class="line">                            &#125;</div><div class="line">                            mLastTouchDownX = ev.getX();</div><div class="line">                            mLastTouchDownY = ev.getY();</div><div class="line">                            //addTouchTarget会创建新的TouchTarget，并将其加入到mFirstTouchTarget</div><div class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                            alreadyDispatchedToNewTouchTarget = true;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // The accessibility focus didn&apos;t handle the event, so clear</div><div class="line">                        // the flag and do a normal dispatch to all children.</div><div class="line">                        ev.setTargetAccessibilityFocus(false);</div><div class="line">                    &#125;</div><div class="line">                    if (preorderedList != null) preorderedList.clear();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</div><div class="line">                    // Did not find a child to receive the event.</div><div class="line">                    // Assign the pointer to the least recently added target.</div><div class="line">                    newTouchTarget = mFirstTouchTarget;</div><div class="line">                    while (newTouchTarget.next != null) &#123;</div><div class="line">                        newTouchTarget = newTouchTarget.next;</div><div class="line">                    &#125;</div><div class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //4. 派发事件</div><div class="line">        // Dispatch to touch targets.</div><div class="line">        if (mFirstTouchTarget == null) &#123; //mFirstTouchTarget为空表示没有子View会处理这次事件，则交给当前的ViewGroup处理。</div><div class="line">            // No touch targets so treat this as an ordinary view.</div><div class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">                    TouchTarget.ALL_POINTER_IDS);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Dispatch to touch targets, excluding the new touch target if we already</div><div class="line">            // dispatched to it.  Cancel touch targets if necessary.</div><div class="line">            TouchTarget predecessor = null;</div><div class="line">            TouchTarget target = mFirstTouchTarget;　</div><div class="line">            while (target != null) &#123;//遍历mFirstTouchTarget链表，一个一个地处理TouchTarget。</div><div class="line">                final TouchTarget next = target.next;</div><div class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//新添加的不会立刻处理，ACTION_DOWN已经在前面派发了</div><div class="line">                    handled = true;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</div><div class="line">                            || intercepted;</div><div class="line">                    //dispatchTransformedTouchEvent会将Event转化为child坐标空间(getX的变化)，然后去除无关的points id，如果有必要更改事件，最后调用child.dispatchTouchEvent</div><div class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</div><div class="line">                            target.child, target.pointerIdBits)) &#123;</div><div class="line">                        handled = true;</div><div class="line">                    &#125;</div><div class="line">                    if (cancelChild) &#123;</div><div class="line">                        if (predecessor == null) &#123;</div><div class="line">                            mFirstTouchTarget = next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            predecessor.next = next;</div><div class="line">                        &#125;</div><div class="line">                        target.recycle();</div><div class="line">                        target = next;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                predecessor = target;</div><div class="line">                target = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Update list of touch targets for pointer up or cancel, if needed.</div><div class="line">        if (canceled</div><div class="line">                || actionMasked == MotionEvent.ACTION_UP</div><div class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class="line">            resetTouchState();</div><div class="line">        &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</div><div class="line">            final int actionIndex = ev.getActionIndex();</div><div class="line">            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</div><div class="line">            removePointersFromTouchTargets(idBitsToRemove);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    //用于测试的代码</div><div class="line"></div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>事件派发流程主要集中在这几个方法的调用:
- dispatchTouchEvent 这是事件派发每个View的时候，第一个被调用的方法，如果是ViewGroup，dispatchTouchEvent会先去调用onInterceptTouchEvent是否应该拦截事件，不拦截的话会先从子View中判断是否有处理该次事件的（在ACTION_DOWN中采用mFirstTouchTarget链接保存会处理事件的TouchTarget），如果没有的话则调用当前View的onTouchEvent。
- onInterceptTouchEvent 判断是否应该拦截事件，ViewGroup默认实现是返回false，子View可以调用getParent.requestDisallowInterceptTouchEvent()来阻止父View拦截。否则只要有子View可能消费事件，该方法都会被调用。
- onTouchEvent这个方法是在没有子View将会消耗事件时才会被调用，onClickListener，onTouchListener,onLongClickListener都是在这个方法中处理的。如果返回true表示消费这次事件。



对于事件派发流程，我觉得有几个地方需要注意的：
1. 应该把ViewGroup以及它所包含的子View都看作是这个ViewGroup的一部分，对于一个ViewGroup是否会处理一次事件，应该是包含了它的子View是否也处理。
2. 如果整个ViewGroup以及它的子类没有一个View处理ACTION_DOWN事件，那么下一次就不会调用这个ViewGroup的dispatchTouchEvent。***但是如果ACTION_DOWN返回了true，那么下一次事件还是会继续派发到ViewGroup，即使中间某个ACTION_MOVE返回了false***。
3. onInterceptTouchEvent是在子View可能会处理该次事件，并且没有被设置FLAG_DISALLOW_INTERCEPT才会被调用。正常情况下，它在ACTION_DOWN的时候一定会被调用的，因为在ACTION_DOWN的时候会先调用resetTouchState()。
</code></pre><p>这个是最近略微改了一下很久之前写的一个模仿QQ邮箱滑动退出写的一个东西:<a href="https://github.com/xxxzhi/SlideListener，改的过程发现之前看的东西理解地不够好…" target="_blank" rel="external">https://github.com/xxxzhi/SlideListener，改的过程发现之前看的东西理解地不够好…</a></p>
<p>源码是解释很多现象的最根本的原因，阅读源码能够更好地理解事件派发流程，理解地更加深刻。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/05/05/android-thinking-about-mvp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/05/android-thinking-about-mvp/" itemprop="url">关于Android MVP模式的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-05T00:00:00+08:00">
                2016-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近经常看到各种介绍MVP模式的博客的，之前写过不少的Android应用，在做那些应用的时候，都是要求快速完成，所以从开始设计到写代码就一直考虑着重用。以前写的项目基本都是不断重构项目，将项目代码变得更加精简，提高代码之间的复用性。但是代码并没有特别地注重按照MVC模式或者是MVP模式来，更多的是直接考虑模块化，重用，精简。所以看了MVP模式后，决定去总结一下自己代码中的问题并优化，算是对自己之前写的代码的回顾。</p>
<h2 id="MVP框架"><a href="#MVP框架" class="headerlink" title="MVP框架"></a>MVP框架</h2><p>MVP框架是目前在Android流行起来的框架，它非常适合用于Android开发上面。我最早接触MVP模式是在一本敏捷开发的书上。MVP分别指代M(model),V(View),P(Presenter)：</p>
<ul>
<li>M（Model）：表示数据模型，以及相关的数据结构。</li>
<li>V（View）：表示视图，主要是指UI界面相关的那些东西。在Android里面比如说layout的xml文件，在MVP中，很多时候Activity/Fragment也是被看做View。</li>
<li>P（Presenter）：可以直接理解为视图与模型的中间纽带。</li>
</ul>
<p><img src="http://xxxzhi.github.io/images/mvp.png" alt="此处输入图片的描述"></p>
<p>在MVP模式中，Model和View不直接进行关联，而是通过Presenter来进行关联的。往往实现的方式是增加一个IModel接口和IView接口，用Model和View分别实现那两个接口，Presenter里面保存IModel和IView接口类型的成员变量。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面举一个关于Android用户信息的MVP模式例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IUserView&#123;</div><div class="line">void setName(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户的JavaBean—User:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class User&#123;</div><div class="line">    private String name;</div><div class="line">    private String id;</div><div class="line">    public String getName()&#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public String getId()&#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public void setId(String id)&#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户模型接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IUserModel&#123;</div><div class="line">void saveUser(User user);</div><div class="line">User load();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class UserModel implements IUserModel&#123;</div><div class="line">    void saveUser(User user)&#123;</div><div class="line">        // 保存用户信息，保存在本地数据库中，或者xml里面</div><div class="line">    &#125;</div><div class="line">    User loadUser()&#123;</div><div class="line">        // 从网络中，或者从本地缓存中读取用户信息</div><div class="line">        return null; //未实现</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Presenter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class UserPresenter&#123;</div><div class="line">    private IUserView view;</div><div class="line">    private IUserModel userModel;</div><div class="line">    public UserPresenter(IUserView view)&#123;</div><div class="line">        this.view = view;</div><div class="line">        userModel = new UserModel();</div><div class="line">    &#125;</div><div class="line">    public void loadUser()&#123;</div><div class="line">        // 此处可能是异步load</div><div class="line">        User user = userModel.loadUser();</div><div class="line">        view.setName(user.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把Activity作为View来看待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class UserActivity extends Activity implements IUserView&#123;</div><div class="line">    TextView tvName; //名称对应的TextView</div><div class="line">    UserPresenter userPresenter ;</div><div class="line">    public void onCreate(Bundle bundle)&#123;</div><div class="line">        ...</div><div class="line">        userPresenter = new UserPresenter(this);</div><div class="line">        // userPresenter.loadUser(); 可以有先初始化</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void setName(String name)&#123;</div><div class="line">        tvName.setText(name); //如果presenter的loadUser是异步线程，这里可以通过tvName.post来运行在UI线程。</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void reloadUserData()&#123; //该函数可以某个按钮的onClick事件里面调用</div><div class="line">        userPresenter.loadUser(); // 可以是从网络中加载数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中Activity不再与Model直接关联，而是通过Presenter来间接关联Model。并且当Model的数据变化了的时候，Presenter能够通知View。上面的例子是View需要变化了，请求Presenter获取数据。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>MVP与MVC最大的不同就是View和Model不再直接关联。很多Android的MVC模式都是直接将Activity看作Control，这会导致整个Activity非常臃肿，因为它既然进行UI交互，还需要加上Control这部分的功能。另外即使另外新建一个Control，而把Activity只当做View的功能，如果Activity还是直接跟Model直接关联的话，因为跟Model直接关联，还是会在Activity增加很多操作。而使用P作为Model和View的纽带，P可以先对模型数据进行一些处理，然后再显示到View。另外一方面对于View的一些请求，Presenter也可以进行一些处理再去请求Model。</p>
<p>上面是关于代码方面的优势，其实通过分隔开Model和View，也是将各个模块进行了解耦。另外一方面通过增加IUserView和IUserModel，这样每个部分进行单元测试也更加方便了，比如可以直接实现IUserView来模拟测试Presenter。</p>
<p>个人觉得MVP模式适合Android应用，一个很大的原因就是Activity这种组件的存在，UI交互完全放在了Activity里面，这导致很多时候Activity会在一不注意间就变得臃肿。View过于庞大。当然还有很多跟Android相关的优势，比如说能够更好地避免Activity的内存泄漏（Presenter直接引用View，而不是Activity的时候）。其实通过增加Presenter，一定程度上也增加了Presenter的复用，很多人说View和Presenter是一一对应的，但是我觉得如果不一一对应，比如说一个Activity里面包含多个Presenter，将Presenter细化，那样Presenter复用的可能性也就越高了，同时也避免了Presenter过于臃肿。</p>
<h2 id="一个模式优化过程"><a href="#一个模式优化过程" class="headerlink" title="一个模式优化过程"></a>一个模式优化过程</h2><p>平时自己写代码的时候，其实还真的是比较少那么明显地使用这种MVP模式，或者说是MVC模式。更多的是模块化，类层次化（面向对象），面向切面，并且坚持代码精简，复用的原则。下面介绍一个将平时的项目简化后的模式，并且通过考虑优化结构将模式转变成MVP的过程。先看看下面这种类型结构:<br><img src="http://xxxzhi.github.io/images/stru.png" alt="此处输入图片的描述"></p>
<p>先模块化将程序分为Fragment/Activity部分,Adapter部分,模型网络操作部分，通过将相关类进行层次化来减少类的臃肿，另外通过AOP编程的方式将一些内容从子父类中提取出来，作为一个单独的切面。这种面向切面能够提高代码的复用性。</p>
<p>上面的类型图里面也有一个不合理的例子，正如上面的注释中所说的将网络操作作为模型的一部分，而不是再添加一个接口，会导致网络操作一旦修改，会影响到Model的子类。</p>
<p>下面看看如何对上面的结构进行转换。上面这种结构更多的是MVC的方式，而且是将V和C基本合在一起了，内聚在一起能够更方面UI交互，但是也会导致臃肿。上面的图中发现只有BaseFragment单向地去关联Model，这样势必会导致Fragment增加更多的代码来控制，因为在Android中进行网络连接是一定要在非UI线程操作的，如果Model没有关连Fragment，必然需要将一个异步操作放到Fragment，等待Model操作完成了后，Fragment来更新Fragment的内容。如果增加一个接口，然后Fragment实现，并且用Model引用它，那么将能够减少Fragment的操作，而且能够更好地去对Model进行单元测试。如果增加一个Presenter，由Presenter与Fragment相互关联，然后Presenter也与Model相互关联，那么Fragment将会大大简化，更加专注一些其他的UI交互。增加Presenter整个架构就变成了MVP模式了。重构后的类型图如下:</p>
<p><img src="http://xxxzhi.github.io/images/stru2.png" alt="此处输入图片的描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模式总是坚持着复用，模块间低耦合，模块内高内聚等等原则来进行的，设计模式中就有六大原则: 单一职责原则，开闭原则，依赖倒转原则，迪米特法则，里氏替换原则，组合聚合原则。好的模式能够让人在阅读的时候能够很好地理解代码，在对程序进行修改的时候能够快速简洁，并且不对原有代码结构破坏。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/30/android-sourcecode-binder-process-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/30/android-sourcecode-binder-process-analysis/" itemprop="url">Android Binder跨进程与非跨进程的传输异同源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-30T00:00:00+08:00">
                2016-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天看到Service的onBind函数返回值的三种情况（扩展Binder对象，Messenger，aidl），一直在想他们内部的实现有什么不一样的，网上很多文章都介绍了Service的绑定过程，但是并没有介绍对于跨进程与非跨进程，对于不同的返回值，其具体有什么区别，以及具体是怎么实现的。这篇文章就根据源码分析Android究竟是在哪部分来控制跨进程与非跨进程Binder的传输的，Binder究竟是怎么传输的。</p>
<p>首先看一下Service的绑定中，Binder跨进程与非跨进程的区别代码中的体现。</p>
<h2 id="Service跨进程绑定与非跨进程绑定的表象"><a href="#Service跨进程绑定与非跨进程绑定的表象" class="headerlink" title="Service跨进程绑定与非跨进程绑定的表象"></a>Service跨进程绑定与非跨进程绑定的表象</h2><p>想知道具体是怎么样的，其实直接在ServiceConnection的onServiceConnection回调函数中，以及在Service的onBind中分别打印一下Binder就好了，如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Service onBind</span></div><div class="line"><span class="function"><span class="keyword">public</span> Binder <span class="title">onBind</span><span class="params">()</span></span>&#123;</div><div class="line">    Binder binder ; <span class="comment">//这里并没有初始化，可以使扩展Binder，也可以是aidl的Stub</span></div><div class="line">    Log.i(<span class="string">"TestLog"</span>,<span class="string">"onBind: "</span>+binder.hashCode()+<span class="string">","</span>+binder.toString());</div><div class="line">    <span class="keyword">return</span> binder;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ServiceConnection</span></div><div class="line">ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnection</span><span class="params">(ComponentName component, Binder binder)</span></span>&#123;</div><div class="line">        Log.i(<span class="string">"TestLog"</span>,<span class="string">"onServiceConnection: "</span>+binder.hashCode()+<span class="string">","</span>+binder.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过设置Service的android:process，可以将Service远程进程与相同进程进行实验。<br>通过log可以发现，如果是跨进程的话，在ServiceConnection的onServiceConnection返回的结果是一个BinderProxy对象，与onBind中打印的结果是不一致的。如果是非跨进程，在onServiceConnection与onBind的打印的内容是一模一样的。<strong><em>这里跟onBind是返回扩展Binder还是返回扩展aidl自动产生Stub类是没有关系的，只跟是否跨进程有关</em></strong>。</p>
<p>从这里可以看出，如果是跨进程则返回BinderProxy，非跨进程则返回原来在onBind中返回的对象。我困惑的问题是，Android是怎么实现这个根据不同的进程来返回不同的结果呢？下面先看一下Service的绑定过程是否有针对不同进程的区别处理。</p>
<h2 id="Service绑定过程"><a href="#Service绑定过程" class="headerlink" title="Service绑定过程"></a>Service绑定过程</h2><h3 id="绑定过程"><a href="#绑定过程" class="headerlink" title="绑定过程"></a>绑定过程</h3><p>首先简单介绍一下Service的绑定过程：</p>
<ol>
<li>Activity通过bindService请求绑定相应的Service(由Intent指定），并设置了ServiceConnection回调接口。</li>
<li>实际上会调用ContextImpl.bindService，然后调用ActivityManagerNative.getDefault().bindService，也就是通过IPC调用ActivityManagerService的bindService函数。</li>
<li>在ActivityManagerService的bindService函数中，先通过retrieve创建ServiceRecord，这个就是对应着我们想要绑定的Service</li>
<li>然后根据结果创建ConnectionRecord，将ServiceConnection保存在这里面。ConnectionRecord保存在一个ArrayList中，可能有多个客户端想要绑定。</li>
<li>接着在bringUpServiceLocked函数中判断是否需要重新创建一个进程来运行Service，根据android:processd的设置</li>
<li>启动服务，通过ApplicationThreadProxy(app.thread)远程调用ApplicationThread的scheduleCreateService来发送Message给主线程消息循环(ActivityThread,ActivityThread.H)，启动服务。</li>
<li><p>绑定服务，通过ApplicationThreadProxy(app.thread)远程调用ApplicationThread的scheduleBindService来发送Message给主线程消息循环(ActivityThread,ActivityThread.H)，绑定服务(handleBindService)。这里看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!data.rebind) &#123;</div><div class="line">        IBinder binder = s.onBind(data.intent);</div><div class="line">        ActivityManagerNative.getDefault().publishService(</div><div class="line">            data.token, data.intent, binder);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        s.onRebind(data.intent);</div><div class="line">        ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class="line">            data.token, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    ensureJitEnabled();</div><div class="line">&#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在绑定服务中，调用Service的onBind方法得到Binder，并且通过ActivityManagerNative.getDefault().publishService发布服务。</p>
</li>
<li>在publishServcie中使用ServiceRecord获取ConnectionRecord，最终调用保存在ConnectionRecord里面的ServiceConnection的onServiceConnection函数。其中ServiceRecord，ServiceConnection都是Binder类，可以通过IPC访问。</li>
</ol>
<p>这里只是简单介绍一下绑定Service的流程，也并没有把具体对象名称写出来。如果想要更详细的了解整个过程可以去看一下老罗的博客，其实最好是照着别人的博客看一下源码。</p>
<h3 id="绑定过程是否处理了不同onBind返回值"><a href="#绑定过程是否处理了不同onBind返回值" class="headerlink" title="绑定过程是否处理了不同onBind返回值"></a>绑定过程是否处理了不同onBind返回值</h3><p>我一直觉得是在绑定服务的过程中会针对不同的onBind返回值有不同的处理，但实际上并没有。看第7步中的源码就知道了，上面的过程中，并没有针对不同的onBind返回值进行特殊处理。</p>
<p>既然绑定过程中没有对不同进程进行处理，那么只能看看Parcel了。而实际上确实是在Parcel中有体现出来了跨进程与非跨进程的区别。下面看看Parcel读取和写入Binder。</p>
<h2 id="Parcel中写入读取Binder"><a href="#Parcel中写入读取Binder" class="headerlink" title="Parcel中写入读取Binder"></a>Parcel中写入读取Binder</h2><h3 id="Parcel写入Binder"><a href="#Parcel写入Binder" class="headerlink" title="Parcel写入Binder"></a>Parcel写入Binder</h3><p>Parcel写入Binder是通过writeStrongBinder的，Java层的writeStrongBinder是一个native函数，对应的JNI实现为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</div><div class="line">&#123;</div><div class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</div><div class="line">    if (parcel != NULL) &#123;</div><div class="line">        const status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</div><div class="line">        if (err != NO_ERROR) &#123;</div><div class="line">            signalExceptionForError(env, clazz, err);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中ibinderForJavaObject是将java层的对象转换成native层的Binder对象，实际上对应的是JavaBBinder。</p>
<p>然后native层的parcel会调用它的writeStrognBinder:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</div><div class="line">&#123;</div><div class="line">    return flatten_binder(ProcessState::self(), val, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用flatten_binder:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</div><div class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</div><div class="line">&#123;</div><div class="line">    flat_binder_object obj;</div><div class="line"></div><div class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</div><div class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</div><div class="line">        IBinder *local = binder-&gt;localBinder();   <span class="comment">//JavaBBinder返回的是this,也就是自己</span></div><div class="line">        <span class="keyword">if</span> (!local) &#123;</div><div class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</div><div class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</div><div class="line">                ALOGE(<span class="string">"null proxy"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</div><div class="line">            obj.type = BINDER_TYPE_HANDLE;</div><div class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></div><div class="line">            obj.handle = handle;</div><div class="line">            obj.cookie = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 写入JavaBBinder将会对应这一段。</span></div><div class="line">            obj.type = BINDER_TYPE_BINDER;</div><div class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</div><div class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);   <span class="comment">//把对应的JavaBBinder的指针转换成整形uintptr_t</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        obj.type = BINDER_TYPE_BINDER;</div><div class="line">        obj.binder = <span class="number">0</span>;</div><div class="line">        obj.cookie = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out); <span class="comment">//finish_flatten_binder是将obj写入到out里面。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就根据是本地binder还是远程binder，对Binder的写入采取了两种不同的方式。Binder如果是JavaBBinder，则它的localBinder会返回localBinder，如果是BpBinder则localBinder会为null。我们写入的时候，ibinderForJavaObject就返回的是JavaBBinder。flat_binder_object是Binder写入的时候的对象，它对应着Binder。handle表示Binder对象在Binder驱动中的标志，比如ServiceManager的handle为0。type表示当前传输的Binder是本地的（同进程），还是一个proxy（跨进程）。binder，cookie保存着Binder对象的指针。finish_flatten_binder会将obj写入到out里面，最终写入到Binder驱动中，写入部分也就完了。从上面的流程可以看出，在写入的时候，Parcel会针对不同的Binder（BBinder/JavaBBinder,BpBinder）有不同的处理，而他们确实就是对应着跟Service端Binder是同一个进程的还是不同进程的情况。</p>
<h4 id="Parcel读取Binder"><a href="#Parcel读取Binder" class="headerlink" title="Parcel读取Binder"></a>Parcel读取Binder</h4><p>接下来就是读取了，同样的，Java层的Parcel也是通过native函数来读取的。在这里我们从最底层开始分析，首先从unflatten_binder开始：</p>
<p>unflatten_binder:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</div><div class="line">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (flat) &#123;</div><div class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</div><div class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</div><div class="line">                <span class="keyword">return</span> finish_unflatten_binder(</div><div class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BAD_TYPE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先从Binder驱动中读取一个flat_binder_object—flat。flat的处理是关键，它会根据flat-&gt;type的值分别处理，如果是BINDER_TYPE_BINDER，则使用cookie中的值强制转换成指针。如果是BINDER_TYPE_HANDLE，则使用Proxy，getStringProxyForHandle会返回BpBinder。而调用unflatten_binder的是native层的Parcel的readStringBinder。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    sp&lt;IBinder&gt; val;</div><div class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &amp;val);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用readStrongBinder的是jni函数的实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</div><div class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> javaObjectForIBinder(env, parcel-&gt;readStrongBinder());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>javaObjectForIBinder与ibinderForJavaObject相对应，把IBinder对象转换成对应的Java层的Object。这个函数是关键。看看它的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;  <span class="comment">//如果是本地的，那么会直接进入这部分代码，因为这个val是写入的时候同一个对象，gBinderOffsets也是一致。如果val是一种proxy对象，则不然，会继续往下执行找到一个Proxy对象。</span></div><div class="line">         <span class="comment">// One of our own!</span></div><div class="line">         jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</div><div class="line">         LOGDEATH(<span class="string">"objectForBinder %p: it's our own %p!\n"</span>, val.get(), object);</div><div class="line">         <span class="keyword">return</span> object;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="comment">// For the rest of the function we will hold this lock, to serialize</span></div><div class="line">     <span class="comment">// looking/creation of Java proxies for native Binder proxies.</span></div><div class="line">     AutoMutex _l(mProxyLock);</div><div class="line"> </div><div class="line">     <span class="comment">// Someone else's...  do we know about it?</span></div><div class="line">     jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</div><div class="line">     <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</div><div class="line">        jobject res = jniGetReferent(env, object);</div><div class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</div><div class="line">            ALOGV(<span class="string">"objectForBinder %p: found existing %p!\n"</span>, val.get(), res);</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        LOGDEATH(<span class="string">"Proxy object %p of IBinder %p no longer in working set!!!"</span>, object, val.get());</div><div class="line">        android_atomic_dec(&amp;gNumProxyRefs);</div><div class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</div><div class="line">        env-&gt;DeleteGlobalRef(object);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);<span class="comment">//gBinderProxyOffsets保存的是Java层BinderProxy的信息，这里也是创建BinderProxy。</span></div><div class="line">    <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</div><div class="line">        LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</div><div class="line">        <span class="comment">// The proxy holds a reference to the native object.</span></div><div class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</div><div class="line">        val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line"></div><div class="line">        <span class="comment">// The native object needs to hold a weak reference back to the</span></div><div class="line">        <span class="comment">// proxy, so we can retrieve the same proxy if it is still active.</span></div><div class="line">        jobject refObject = env-&gt;NewGlobalRef(</div><div class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</div><div class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</div><div class="line">                jnienv_to_javavm(env), proxy_cleanup);</div><div class="line"></div><div class="line">        <span class="comment">// Also remember the death recipients registered on this proxy</span></div><div class="line">        sp&lt;DeathRecipientList&gt; drl = <span class="keyword">new</span> DeathRecipientList;</div><div class="line">        drl-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(drl.get()));</div><div class="line"></div><div class="line">        <span class="comment">// Note that a new object reference has been created.</span></div><div class="line">        android_atomic_inc(&amp;gNumProxyRefs);</div><div class="line">        incRefsCreated(env);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//IBinder</div><div class="line">checkSubclass(const void* subclassID) const</div><div class="line">&#123;</div><div class="line">    return subclassID == &amp;gBinderOffsets;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的处理中，如果是跟Service是同一个进程，也就是val是JavaBBinder。那么在checkSubclass中，它所包含的gBinderOffsets指针与参数传入的gBinderOffsets的指针必然是同一个值，则满足if条件。直接将指针强制转换成JavaBBinder，返回对应的jobject。如果是不同的进程，那么val也就会是BpBinder，最终会返回一个BinderProxy,不同的进程这一部分网上很多介绍Binder的文章都介绍了。</p>
<h3 id="Parcel读取写入总结"><a href="#Parcel读取写入总结" class="headerlink" title="Parcel读取写入总结"></a>Parcel读取写入总结</h3><p>上面介绍了Parcel整个写入读取的流程，最后代替Binder传输的是flat_binder_object。在native的Parcel中，根据跨进程还是非跨进程，flat_binder_object的值是不一样的，跨进程的时候flat_binder_object的type为BINDER_TYPE_HANDLE，非跨进程的时候flat_binder_object的type为BINDER_TYPE_BINDER。在这里已经可以发现跨进程与非跨进程的时候传输的数据的区别了。客户端的Parcel在读取Binder的时候，根据是flat_binder_object的type的值进行区分对待，返回不同的内容。</p>
<h2 id="Binder驱动的处理"><a href="#Binder驱动的处理" class="headerlink" title="Binder驱动的处理"></a>Binder驱动的处理</h2><p>但是我们还没有发现Android是如何区分跨进程与非跨进程的呢？显然它的实现在Binder驱动里面。关于如何判断读取的时候是跟Service同一个进程还是不同的进程，脑子里随便一想基本就能够想到怎么去实现了。因为每个进程进行系统调用陷入内核的时候，内核的当然是可以知道当前进入内核空间的进程的信息了啦，这样就可以判断当前请求读取信息的是跟Service同一个进程还是不同的进程了。</p>
<p>实际上Binder驱动保存着Service端的Binder地址和handle的信息，将两者相互映射，根据不同的服务端进程和客户端进程来区别处理。这篇文章详细介绍了Binder驱动<a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上真正控制跨进程与非跨进程返回Binder类型的，不是绑定服务的过程，而是Binder驱动。Parcel是根据从驱动中读取的数据作出不同的处理，而Binder驱动真正控制。如果是与Service端同一个进程则返回Binder(在底层是Binder指针)，如果是不同的进程则返回handle。真正在传输的过程中，是作为flat_binder_object对象来传递的。</p>
<p>其实也可以在Service的绑定过程中来根据是否是相同进程来进行处理的，但那样就局限于Service的绑定部分了,而Android中用的Binder传输的实在是太多了，所以直接在Binder驱动中进行控制更加方便。</p>
<hr>
<blockquote>
<p>积跬步，至千里；积小流，成江海</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/26/android-sourcecode-bridge-fragmentcompat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/26/android-sourcecode-bridge-fragmentcompat/" itemprop="url">Android源码桥梁模式---FragmentCompat</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-26T00:00:00+08:00">
                2016-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>发现想要在Android源码中找到一个明显使用桥梁模式的模块还真的挺不容易的，但由于Android代码命名上面的规律，还是让我搜索到了。FragmentCompat是一个用于访问Fragment特征的帮助类，它在support v13开始以一种向后兼容的风格提出。它是如何向后兼容的呢？就是使用桥梁模式来向后兼容。它是一种简化了的桥梁模式，下面将简单介绍FragmentCompat与桥梁模式。</p>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将对象的抽象与实现分隔开来，以使对象的抽象与实现相互独立地变化。</p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="http://xxxzhi.github.io/images/bridge.png" alt="此处输入图片的描述"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//抽象</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsComponent</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> AbsComponentImpl impl;</div><div class="line">    <span class="function"><span class="keyword">public</span> AbsComponentImpl <span class="title">getComponentImpl</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> impl;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbsComponent</span><span class="params">(AbsComponentImpl impl)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.impl = impl;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//实现</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsComponentImpl</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operateImpl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentImpl1</span> <span class="keyword">extends</span> <span class="title">AbsComponentImpl</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateImpl</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"operate implements"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span> <span class="keyword">extends</span> <span class="title">AbsComponent</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component1</span><span class="params">(AbsComponentImpl impl)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(impl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//通过具体的实现部分（impl）来进行操作。</span></div><div class="line">        getComponentImpl().operateImpl();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbsComponentImpl <span class="title">createImpl</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</div><div class="line">    <span class="comment">// 根据id来创建不同的对象</span></div><div class="line">    <span class="keyword">switch</span>(id)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentImpl1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Component1 com = <span class="keyword">new</span> Component1(createImpl(<span class="number">1</span>)); <span class="comment">//此处就是将实现与抽象部分结合起来，大多采用工厂方法的方式创建实现部分</span></div><div class="line">    com.operate();    <span class="comment">//里面是桥接到实现部分去操作的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，有一个抽象组件以及组件实现，组件实现也是有一个抽象父类，想要实现组件实现，就去新创建一个子类。大部分时候，都是采用工厂方法模式去创建一个具体的组件实现对象。根据传入的参数来创建不同的实现。假如实现修改了，抽象部分并不需要改变，只需要创建一个对应的实现对象就可以了。同样抽象部分的变化，也完全不会影响到实现。这就是桥接模式的好处，几乎所有的窗口实现都是采用桥接模式的，窗口与窗口的具体实现（Linux Gnome窗口，Ubuntu窗口）通过桥接模式分隔开来，应用程序开发的时候只需要考虑窗口就可以了。</p>
<h2 id="FragmentCompat"><a href="#FragmentCompat" class="headerlink" title="FragmentCompat"></a>FragmentCompat</h2><p>FragmentCompat的源码在android.support.v13.app中。它只有四个静态方法，首先介绍一下FragmentCompat相关接口功能:</p>
<ul>
<li>setMenuVisibility(Fragment f,boolean visible)<br>设置Fragment创建的菜单是否显示。会在合适的Android版本中调用f.setMenuVisibility(visible)。</li>
<li>setUserVisibleHint(Fragment f, boolean deferStart)<br>设置Fragment是否显示给用户，这个可以用作Fragment延迟加载，也可以用作在ScrollView中未显示给用户的fragment隐藏起来。</li>
<li>requestPermissions(Fragment fragment, String[] permissions, int requestCode)<br>请求对应的权限，关于在应用中请求权限是在Mashmallow出现的，从Mashmallow开始，Android重新设计了应用权限，在apk安装的时候不再显示所需要的权限，而是在应用中需要权限的时候再向用户请求。关于应用权限，这篇文章我觉得讲的很不错<a href="http://zhixinliu.com/2015/11/23/2015-11_23_android_permission/" target="_blank" rel="external">Android permissions最佳实践</a></li>
<li>shouldShowRequestPermissionRationale(Fragment fragment, String permission)<br>判断是否应该显示请求权限的原因，让用户更好地了解该权限的使用。这个要在API23才能使用，之前的版本都是返回false。</li>
</ul>
<h3 id="FragmentCompat-UML图"><a href="#FragmentCompat-UML图" class="headerlink" title="FragmentCompat UML图"></a>FragmentCompat UML图</h3><p><img src="http://xxxzhi.github.io/images/fragment-compat.png" alt="此处输入图片的描述"></p>
<h3 id="FragmentCompat的实现"><a href="#FragmentCompat的实现" class="headerlink" title="FragmentCompat的实现"></a>FragmentCompat的实现</h3><p>FragmentCompat中的四个方法都是静态方法，它包含一个FragmentCompatImpl静态成员对象IMPL。其初始化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> FragmentCompatImpl IMPL;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</div><div class="line">        IMPL = <span class="keyword">new</span> MncFragmentCompatImpl();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= <span class="number">15</span>) &#123;</div><div class="line">        IMPL = <span class="keyword">new</span> ICSMR1FragmentCompatImpl();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</div><div class="line">        IMPL = <span class="keyword">new</span> ICSFragmentCompatImpl();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        IMPL = <span class="keyword">new</span> BaseFragmentCompatImpl();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上就是根据不同的sdk版本采用不同的实现。从上面的UML图也可以看出来，目前的实现方式都是新的SDK版本的实现继承旧的SDK版本的实现。</p>
<p>其实ICSFragmentCompatImpl,ICSMR1FragmentCompatImpl,MncFragmentCompatImpl内部的实现又是通过引用FragmentCompatICS,FragmentCompatICSMR1，FragmentCompat23来实现对应的功能的。如UML图所示，setMenuVisibility由FragmentCompatICS实现，setUserVisibleHint由FragmentCompatICSMR1实现，requestPermissions和shouldShowRequestPermissionRationale由FragmentCompat23实现。</p>
<h2 id="桥梁模式在FragmentCompat的使用分析"><a href="#桥梁模式在FragmentCompat的使用分析" class="headerlink" title="桥梁模式在FragmentCompat的使用分析"></a>桥梁模式在FragmentCompat的使用分析</h2><p>FragmentCompat可以看作是桥梁模式的抽象部分，FragmentCompatImpl是它的实现部分。在FragmentCompat中，它的抽象只有一个，其实也没什么变化，它变化的部分主要还是在实现。Android在不同的SDK版本中都有不同的FragmentCompatImpl实现，在这里有点特殊的是它最新的实现都是通过继承之前的实现来完成的。FragmentCompat可以根据不同的SDK版本采用不同的实现。桥梁模式非常适合这种情况。</p>
<p>在另外一方面，在新的sdk出现的时候，有些功能有变化了（比如到了API23, Fragment有shouldShowRequestPermissionRationale方法了，shouldShowRequestPermissionRationale可以实现了），那只需要采用新的Impl就好了，并不会影响前面的实现部分。这样就达到了向后兼容的效果。</p>
<hr>
<blockquote>
<p>读书无嗜好，就能尽其多。不先泛览群书，则会无所适从或失之偏好，广然后深，博然后专。—鲁迅</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">houzhi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">houzhi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
