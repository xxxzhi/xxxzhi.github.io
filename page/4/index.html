<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="侯志">
<meta property="og:url" content="http://houzhi.me/page/4/index.html">
<meta property="og:site_name" content="侯志">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="侯志">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://houzhi.me/page/4/"/>





  <title>侯志</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">侯志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/10/21/java-f-bounded/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/21/java-f-bounded/" itemprop="url">Java F-bounded</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-21T00:00:00+08:00">
                2015-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上次在<a href="http://stackoverflow.com/questions/33186850/what-the-usefulness-about-java-generics-involving-inheritance-and-generics-exten" target="_blank" rel="external">StackOverflow</a>上面问了一个问题，下面这种模式有什么用处.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">abstract class Base&lt;T extends Base&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Variant&lt;T extends Variant&lt;T&gt;&gt; extends Base&lt;T&gt; &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我是在另外一个问题上面看到的这样的一段代码，一开始一直都不理解，后面看了那些回答的结果，这个F-bounded类型最贴近我想问的。</p>
<p>想明白F-bounded是什么以及它的用处，我举个例子可能就会很清楚的了。下面是wiki中的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class I&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A &lt;T extends I&gt;&#123;</div><div class="line">    public T id(T x)&#123;</div><div class="line">        return x</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A类型里面的id函数的参数被限制为I的子类的。再看下面这一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">abstract class I&lt;T extends I&lt;T&gt;&gt;&#123;</div><div class="line">    public T clone(T x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A extends I&lt;A&gt;&#123;</div><div class="line">    @Override</div><div class="line">    public A clone(A x)&#123;</div><div class="line">        return x</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面通过I就将clone函数的参数限制为A本身了。这是一个非常好的类型复制方法。它很好地限制了类型的参数。显然I也可以是Java的接口，这是Java模版一个非常巧妙的使用。</p>
<p>回到第一段代码，如果我们有VariantA继承Variant，即</p>
<pre><code>class VariantA extends Variant&lt;VariantA&gt;{
}
</code></pre><p>那第一段代码就可以正常使用了。它也可以发挥F-bounded代码的效果。对某些函数进行参数限制。有了VariantA后，也可以这样去实例化Variant。</p>
<pre><code>Variant&lt;VariantA&gt; variant = new Varaint&lt;VariantA&gt;();
</code></pre><p>或者</p>
<pre><code>Variant&lt;VariantA&gt; variant = new VariantA();
</code></pre><p>这段时间看开源项目的源码收获颇多，见识了很多东西，接下来还需要自己研读，慢慢地好好总结。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/10/16/java-dynamic-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/16/java-dynamic-proxy/" itemprop="url">Java动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-16T00:00:00+08:00">
                2015-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://xxxzhi.github.io/images/beautiful3.jpg" alt="enter image description here"></p>
<p>最近发现很多项目都用到了动态代理，就又认真学习了下Java动态代理。代理模式应用在很多地方，但是如果在编码的时候就添加代理类，那整个代码就会变的非常冗余，繁琐。这样动态代理就应运而生了，动态代理的代理是在程序运行的时候动态生成的。动态代理只需要提供一组接口，以及被代理的对象，程序就会自动生成代理类，而且你还可以在运行方法的前后做一些自己需要的操作，甚至于不执行方法。</p>
<p>下面介绍一个动态代理的例子。</p>
<p>首先是一个被代理的类,以及类实现的接口</p>
<pre><code>public interface ProxyInterface{
    void doProxy();
}



public class ProxyObject implements ProxyInterface{

    public void doProxy(){
        System.out.println(&quot;hello proxy object&quot;);
    }
}
</code></pre><p>然后有一个对代理运行的时候调用处理的Handle类</p>
<pre><code>public class TestProxyHandler implements InvotationHandler{
    Object proxyObject = null;
    public TestProxyHandler(Object proxyObject){
        this.proxyObject = proxyObject;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        Object result = method.invoke(proxyObject,args);
    }
}
</code></pre><p>使用这些代理的代码</p>
<pre><code>ProxyObject object = new ProxyObject();
TestProxyHandler proxyHandler = new TestProxyHandler(object);
ProxyInterface proxyInterface = (ProxyInterface)Proxy.newProxyInstance(ProxyObject.class.getClassLoader(),
                object.getClass().getInterfaces(),
                proxyHandler);
proxyInterface.doProxy();
</code></pre><p>通过Proxy的newProxyInstance方法产生了一个新的代理对象，这个代理对象实现了指定的接口（方法newProxyInstance第二个参数传入的内容）。程序在运行的时候会执行proxyHandler的invoke方法，我们可以在invoke方法里面做自己需要做的一些操作。</p>
<p>上面就是动态代理的一个非常简单的例子。一个最明显的特征就是代理对象不是单独作为一个类，而是有java代理代码自动生成，其中生成的代理对象内部又引用了InvotationHandler，由InvotationHandler连接与被代理对象。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>Proxy的代码量是固定的了，不会变成一堆庞大的代码</li>
<li>可以实现AOP编程</li>
</ol>
<p>看着动态代理似乎简单，但是应用起来非常广泛，而且有很多意想不到的巧妙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/10/16/java-annotation-simple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/16/java-annotation-simple/" itemprop="url">Java注解简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-16T00:00:00+08:00">
                2015-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://xxxzhi.github.io/images/beautiful6.jpg" alt="enter image description here"></p>
<p>国庆假期前后，基本是看一下开源的项目，发现不少优秀的开源项目都用了注解和动态代理相关的知识，所以顺带有好好地研读了一下注解和动态代理，加深了对注解和动态代理的认识。博客都差不多接近要断了，前一段七七八八地看了各种东西，一直都没有写东西，懒惰了很多。整的现在很多东西都没有做好，突然觉得不仅仅是专业学习，其他的各种东西也应该有点追求。力求生活精致。</p>
<p>Java从JDK5开始引入了注解（Annotation），也称元数据，它可以用于创建文档，代码依赖性跟踪，甚至编译时的基本检查。注解基本格式是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString()&#123;</div><div class="line">        return &quot;annotation string&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">Java注解可以应用到包，类，方法，字段，局部变量上面。另外Java可以通过反射去读取注解的内容。</div><div class="line"></div><div class="line">## Java内置注解</div><div class="line">Java内置了三个注解，定义在java.lang包里面：</div><div class="line">- Override：重载检查</div><div class="line">- Deprecated: 使用过时的代码的提示</div><div class="line">- SuppressWarnings:提醒，像uncheck，serial等</div><div class="line"></div><div class="line">这些个也都是我们经常使用的注解，特别是```Override```，在继承的时候加上注解，能够对继承进行检查。像本文第一段代码就是使用了Override。下面这段就是Override的源码：</div></pre></td></tr></table></figure></p>
<pre><code>package java.lang;
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 自定义注解</div><div class="line">Java出了内置了注解，也同样是允许自定义注解的。自定义注解也跟Override的实现完全一样。比如说我们想要实现一个Hello注解，只需要使用如下代码：</div></pre></td></tr></table></figure>
<pre><code>package java.lang;
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
public @interface Hello {
    String haha() default &quot;ha&quot;;
    String haha1() default &quot;ha1&quot;;
}
</code></pre><p>```</p>
<p>这样就可以像使用Override一样使用Hello注解了。其中<code>@interface</code>是声明一个注解，自动继承了java.lang.annotation.Annotation接口，编译器程序会完成其他部分，在定义注解时，不能继承其他注解或接口。<code>@Retention</code>是用来设置作用范围，默认时RetentionPolicy.CLASS，它也是一种保留范围，CLASS保留在class文件中，但VM运行时不保存，RUNTIME保留在class，运行时可以反射读取注解的值。</p>
<p><code>@Target</code>是用来指定适用的元素种类。如果不添加的话，任何元素都能够使用。注解里面的方法是注解的变量，可以设置默认值，类型基本变量都可以。</p>
<h2 id="读取注解的值"><a href="#读取注解的值" class="headerlink" title="读取注解的值"></a>读取注解的值</h2><p>注解的值可以在运行的时候读取出来，只要<code>@Retention</code>设置为RUNTIME就能够被读取出来了。不过读取出来的具体方法就需要去了解下了。</p>
<p>比如我们使用之前定义的Hello注解</p>
<pre><code>@Hello
class TestHello{
    @Hello(haha=&quot;haha&quot;)
    public void sayHello(){}

    @Hello(haha=&quot;hahastr&quot;)
    public void hello;
}
</code></pre><h3 id="类注解"><a href="#类注解" class="headerlink" title="类注解"></a>类注解</h3><pre><code>Class&lt;TestHello&gt; cl = TestHello.class
Hello h = cl.getAnnotation(Hello.class);
System.out.println(h.haha()+&quot;,&quot;+h.haha1());
</code></pre><h3 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h3><pre><code>Class&lt;TestHello&gt; cl = TestHello.class
Method method = cl.getMethod(&quot;sayHello&quot;,new Class[0]);
Hello h = (Hello)method.getAnnotation(Hello.class);
</code></pre><p>字段，构造函数的使用方式都是一样的。程序可以在运行的时候读取注解</p>
<h2 id="处理注解的工具APT"><a href="#处理注解的工具APT" class="headerlink" title="处理注解的工具APT"></a>处理注解的工具APT</h2><p>APT（Annotation Processing Tool）就是jdk在1.5提供的帮助注解处理过程的工具。它的作用是在编译源文件之前，通过一个自定义的注释处理器去解释并处理源文件的注释，并且由注释处理器生成一些新的源文件，字节码文件，或其他文本文件。APT也会对新的源文件进行处理，知道没有新的源文件产生。</p>
<h2 id="使用了注解的一些工具"><a href="#使用了注解的一些工具" class="headerlink" title="使用了注解的一些工具"></a>使用了注解的一些工具</h2><p>现在很多开源第三方Android项目都是使用了注解，</p>
<p>像依赖注入库<a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a>就是使用了很多注解去实现注入，并且利用注解处理工具在编译时生成辅助类，在运行时完成注入。</p>
<p>另外又比如<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">ButterKnife</a>，也是一种依靠注入的开源库，不过ButterKnife是Android中通过id自动绑定java中的View变量与layout中描述的View的一个开源库。</p>
<p>以及我前面看过的<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>，那是一个将Http访问简化成与ORM一样的开源库。很多第三方库都使用注解来方便开发者使用，但是其中的原理还是应该了解一下。</p>
<p>Spring中用到的注解就更多了，以及很多ORM都是用注解方便开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/10/07/retorfit-analyse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/07/retorfit-analyse/" itemprop="url">Retrofit源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-07T00:00:00+08:00">
                2015-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-功能介绍"><a href="#1-功能介绍" class="headerlink" title="1. 功能介绍"></a>1. 功能介绍</h3><h4 id="1-1-Retrofit"><a href="#1-1-Retrofit" class="headerlink" title="1.1 Retrofit"></a>1.1 Retrofit</h4><p>Retrofit是Github上面squre组织开发的一个类型安全的Http客户端，它可以在Java和Android上面使用。Retrofit将描述请求的接口转换为对象，然后再由该对象去请求后台。Retrofit将请求对象化了。目前已经发布了2.0beta版本。</p>
<h4 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h4><p>Retrofit主要有以下功能特点</p>
<ol>
<li>将Http请求对象化，函数化。让接口的函数代表具体请求。</li>
<li>利用注解的方式标记参数，将HTTP的请求方法，请求头，请求参数，请求体等等都用注解的方式标记，使用起来非常方便。</li>
<li>支持Multipart，以及文件上传（file upload）。</li>
<li>直接将Http的Response转换成对象。用户可以根据Response的具体内容，更换转换器，或者自己新建转化器。</li>
<li>Retrofit默认使用OkHttp开源库请求后台，用户也可以使用自定义的具体请求方式。方便扩展。</li>
<li>自带提供了异步处理Http请求的方式。</li>
</ol>
<h4 id="1-3简单Demo"><a href="#1-3简单Demo" class="headerlink" title="1.3简单Demo"></a>1.3简单Demo</h4><p>这是一个简单的例子，访问<a href="https://httpbin.org/" target="_blank" rel="external">httpbin</a>网站。也可以看完整的<a href="https://github.com/android-cn/android-open-project-demo/tree/master/Retrofit-demo" target="_blank" rel="external">Retrofit Demo</a><br>首先声明一个java接口</p>
<pre><code>public interface HttpbinService {
    @GET(&quot;/get?arg1=hello&quot;)
    Call&lt;HttpbinRequest&gt; testGet();
}
</code></pre><p>使用方式</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
            .baseUrl(&quot;https://httpbin.org&quot;)
            .addConverterFactory(GsonConverterFactory.create())
            .build();

HttpbinService httpbinService = retrofit.create(HttpbinService.class);
</code></pre><p>使用httpbinService获取一个Call，用来请求HTTP服务器。</p>
<pre><code>Call&lt;HttpbinRequest&gt; call = httpbinService.testGet();
</code></pre><p>因为接口返回的应该是一个Call，用来请求后台HTPP服务器，所以我们在声明接口的似乎，返回参数应该是Call&lt;?&gt;。由于httpbin返回的是一个json格式的数据，我们想要返回直接的自定义的模型数据，但是retrofit默认只会返回ResponseBody，所以我们需要自己添加一个GsonConverter第三方库。在build.graddle中的dependencies添加：</p>
<pre><code>compile &apos;com.squareup.retrofit:converter-gson:2.0.0-beta2&apos;
</code></pre><h3 id="2-总体设计"><a href="#2-总体设计" class="headerlink" title="2. 总体设计"></a>2. 总体设计</h3><p>Retrofit可以分为注解解析（Request生成），请求执行，请求回调（异步处理），响应体转化几个部分。其中请求执行与请求回调可以算作一个部分，并且请求回调也可以没有，Call有直接执行的接口execute。</p>
<p><img src="http://xxxzhi.github.io/images/retorfit-model.png" alt="Retrofit总体结构"></p>
<ol>
<li>首先由解析部分（这部分也是Request生成部分），利用注解（Annotation）解析接口文件，将接口方法解析好，每个方法生成一个Request。</li>
<li>然后利用Call部分执行Request。Retrofit使用的是okHttp来请求，程序中将Retrofit Request转化为OKHttp开源库的Request，转由OkHttpClient执行。</li>
<li>在Request执行完后，得到Response，使用Converter转化Response为用户需要的对象。比如将json格式的数据，利用gson转化为具体的Object（也就是接口函数中的返回Call的模版参数的具体类型对象）</li>
<li>利用回调将第三步得到的对象，将对象传回给UI线程，更新UI。</li>
</ol>
<p>这里面第三部与第四步是可以合在一起的，但是目前Retrofit提供的默认代码中，会通过Call，加入Callback，用户可以在Callback中处理结果。</p>
<p>注解（Annotation）是Retrofit预先定义的注解，包括Http的各个部分，比如POST、GET、Query、QueryMap、Field等等。</p>
<h3 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3. 流程图"></a>3. 流程图</h3><p><img src="http://xxxzhi.github.io/images/flow-draw.png" alt="Retrofit使用流程图"></p>
<p>其中生成Call的部分可以看下面关于这个适配器的类图。</p>
<h3 id="4-详细设计"><a href="#4-详细设计" class="headerlink" title="4. 详细设计"></a>4. 详细设计</h3><h4 id="4-1-类图"><a href="#4-1-类图" class="headerlink" title="4.1 类图"></a>4.1 类图</h4><p>首先是整个项目的类图<br><img src="http://xxxzhi.github.io/images/retrofit-uml.png" alt="Retrofit UML图"></p>
<p>对于Retrofit项目中CallAdapter用着适配器模式也挺巧的，通过适配器将Callback回调接口运行在UI线程。下面时有关CallAdapter，Call，Callback的类图，其中也是连续用了两次代理模式。</p>
<p><img src="http://xxxzhi.github.io/images/call-adapter-uml.png" alt="CallAdapter uml图"></p>
<p>ExecutorCallback代理的是用户自定义的Callback。通过这种方式让OkHttpCall去执行Call，让ExecutorCallback将用户自定义的Callback运行在指定线程上。</p>
<h4 id="4-2-类功能详细介绍"><a href="#4-2-类功能详细介绍" class="headerlink" title="4.2 类功能详细介绍"></a>4.2 类功能详细介绍</h4><p>在Retrofit开源库中，Retrofit类是用户最基础的访问入口。然后Converter部分是由用户自己扩展的，而Paraser部分的相关类RequestBuilder，RequestFactory等则主要是负责解析接口并且生成Request，而Call，CallAdapter等主要是负责底层的Http请求，以及请求后线程转换。</p>
<h5 id="4-2-1-Retrofit"><a href="#4-2-1-Retrofit" class="headerlink" title="4.2.1 Retrofit"></a>4.2.1 Retrofit</h5><p>Retrofit类是包含了一个构造器Retrofit.Builder，由Builder指定Retrofit的相关参数，创建一个新的Retrofit。Retrofit中包含了很多重要的成员变量，而这些成员变量都是可以自设置的。</p>
<p>Retrofit包含以下成员变量：</p>
<ul>
<li>baseUrl: Http请求的基础url，类型是BaseUrl，包含了url函数返回HttpUrl（OkHttp的类），由Retrofit.Builder.baseUrl设置。</li>
<li>client：OkHttp库的OkHttpClient类型。由Builder的client函数设置，默认为<code>OkHttpClient()</code>。</li>
<li>methodHandlerCache：Map类型，MethodHandler的缓存，从接口中解析出来，放在这个map里面。</li>
<li>converterFactories：List类型，包含了很多converter的创建工厂，用户可以通过Builder的addConverterFactory来添加。默认添加了BuiltInConverters。</li>
<li>callbackExecutor：回调函数的执行器，也就是回调函数执行的线程，Android中默认为MainThreadExecutor。</li>
<li>adapterFactories：List类型，包含了CallAdapter.Factory，用户可以通过Builder的addCallAdapterFactory来添加。Android中默认添加了ExecutorCallAdapterFactory。使用callbackExecutor作为Executor。</li>
<li>validateEagerly：这个是设置的在创建动态代理对象之前，是否提前解析接口Method，创建MethodHandler并添加到Cache中。</li>
</ul>
<p>Retrofit重要方法:</p>
<ul>
<li>create(final Class<t> service):T<br>这个是一个public模版方法，用户可以通过这个方法，传入接口Class（T），获得接口Class Http请求的动态代理对象。这是该开源库的主入口，这个函数先验证接口以及其方法，然后创建一个匿名InvocationHandler，在匿名InvocationHandler的invoke中首先去掉Object以及Platform默认的方法，然后调用loadMethodHandler解析对应的方法（接口方法），创建MethodHandler加入到methodHandlerCache中，得到MethodHandler，最后调用MethodHandler的invoke方法得到返回结果（接口方法的返回类型）。动态代理请见<a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">Java动态代理</a></t></li>
<li>loadMethodHandler(Method method):MethodHandler&lt;?&gt;<br>解析对应的方法（接口方法），创建MethodHandler加入到methodHandlerCache中，返回得到MethodHandler。</li>
<li>nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,<pre><code>Annotation[] annotations):CallAdapter&lt;?&gt;
</code></pre>该方法主要是从callAdapterFactories中获取新的CallAdapter，它会跳过skipPast，以及skipPast之前的Factory，然后找到与returnType和annotations都匹配的CallAdapterFactory。如果不匹配CallAdapterFactory的get会返回null，所以搜索Factories的时候，直到搜索到返回非null就找到对应的了。</li>
</ul>
<p>如果没有找到对应的CallAdapterFactories，得到CallAdapter，则该方法会抛出一个IllegalArgumentException异常，异常里面的message会是”Could not locate call adapter for “，如果遇到这个异常，则去判断对应的方法的返回类型是不是与CallAdapterFactory不匹配。</p>
<ul>
<li>requestConverter(Type type, Annotation[] annotations):Converter<t, requestbody=""><br>也是模版方法，该方法返回Converter。利用converterFactories创建一个与RequestBody对应的Converter对象。<br>如果没有找到对应的ConverterFactory，得到Converter，则该方法会抛出一个IllegalArgumentException异常，异常里面的message会是”Could not locate RequestBody converter for  “。同样，如果遇到这个异常，则去判断对应的方法的返回类型是不是与ConverterFactory不匹配。</t,></li>
<li>responseConverter(Type type, Annotation[] annotations): Converter<responsebody, t=""><br>与requestConverter类似，不过该方法对应的是Response。</responsebody,></li>
</ul>
<h5 id="4-2-2-MethodHandler"><a href="#4-2-2-MethodHandler" class="headerlink" title="4.2.2 MethodHandler"></a>4.2.2 MethodHandler</h5><p>MethodHandler是retrofit中连接了解析部分，执行部分，转换部分的一个关键的中间类。不过MethodHandler的代码量很少。它可以说是连接各个部分的桥梁，也是接口方法的描述类。它有包含了retrofit，requestFactory，callAdapter，responseConverter成员变量。主要方法如下</p>
<ul>
<li>create(Retrofit retrofit, Method method):MethodHandler&lt;?&gt;<br>这是个静态方法。MethodHandler的创建方法，在这个方法里面通过创建CallAdapter，responseConverter，requestFactory，最后创建MethodHandler。</li>
<li>createCallAdapter(Method method, Retrofit retrofit): CallAdapter&lt;?&gt;<br>这是个静态方法。通过retrofit的newCallAdapter创建CallAdapter</li>
<li>createResponseConverter(Method method,Retrofit retrofit, Type responseType):Converter<responsebody, ?=""><br>这是个静态方法。通过retrofit的responseConverter方法得到responseConverter</responsebody,></li>
<li>invoke(Object… args):Object<br>通过callAdapter的adapter将OkHttpCall转换成需要返回的Call<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object invoke(Object... args) &#123;</div><div class="line">  return callAdapter.adapt(new OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-2-3-Converter-与Converter-Factory"><a href="#4-2-3-Converter-与Converter-Factory" class="headerlink" title="4.2.3 Converter 与Converter.Factory"></a>4.2.3 Converter 与Converter.Factory</h5><p>这两个类别都是在Converter文件下。Converter是接口，Factory抽象类，很简短。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface Converter&lt;F, T&gt; &#123;</div><div class="line">  T convert(F value) throws IOException;</div><div class="line"></div><div class="line">  abstract class Factory &#123;</div><div class="line">    // 返回将ResponseBody转化为Type具体的对象的Converter</div><div class="line">    public Converter&lt;ResponseBody, ?&gt; fromResponseBody(Type type, Annotation[] annotations) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //返回将函数Body参数转化为RequestBody的Converter</div><div class="line">    public Converter&lt;?, RequestBody&gt; toRequestBody(Type type, Annotation[] annotations) &#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Factory主要是负责生成两种Converter。Retrofit实现了一个简单的BuiltInConverters。</p>
<h5 id="4-2-4-Call"><a href="#4-2-4-Call" class="headerlink" title="4.2.4 Call"></a>4.2.4 Call</h5><p>这是Retrofit的框架基础接口。它是Retrofit的发送请求给服务器并且返回响应体的调用。每个Call都有自己的HTTP请求和相匹配的响应。<br>它有如下四个接口：</p>
<ul>
<li>execute 同步执行请求<br><code>Response&lt;T&gt; execute() throws IOException;</code></li>
<li>enquene 异步执行请求，并且使用Callback作为请求结束后的回调。<br><code>void enqueue(Callback&lt;T&gt; callback);</code></li>
<li>cancel 取消请求<br><code>void cancel();</code></li>
<li>clone 复制请求，如果需要很多相同的Call，可以通过clone复制。<br><code>Call&lt;T&gt; clone();</code></li>
</ul>
<h5 id="4-2-5-CallAdapter"><a href="#4-2-5-CallAdapter" class="headerlink" title="4.2.5 CallAdapter"></a>4.2.5 CallAdapter</h5><p>这是Retrofit的框架基础接口。CallAdapter是将一个Call适配给另外一个Call的适配器接口。它有以下两个接口：</p>
<ul>
<li>responseType 返回请求后，转化的参数Type类型。<br><code>Type responseType();</code></li>
<li>adapt 适配，将一个Call转换成另外一个Call。<br><code>&lt;R&gt; T adapt(Call&lt;R&gt; call);</code></li>
</ul>
<h5 id="4-2-6-Callback"><a href="#4-2-6-Callback" class="headerlink" title="4.2.6 Callback"></a>4.2.6 Callback</h5><p>请求结构的回调接口。在Call的enquene接口中使用 有如下两个方法</p>
<ul>
<li>onResponse 返回响应体<br><code>void onResponse(Response&lt;T&gt; response, Retrofit retrofit);</code></li>
<li>onFailure 请求失败的时候，比如网络或者一些难以预料的异常。<br><code>void onFailure(Throwable t);</code></li>
</ul>
<h5 id="4-2-7-OkHttpCall"><a href="#4-2-7-OkHttpCall" class="headerlink" title="4.2.7 OkHttpCall"></a>4.2.7 OkHttpCall</h5><p>实现了Call接口，但同样是模版类。首先介绍一下OkHttpCall的主要函数：</p>
<ul>
<li>createRawCall</li>
</ul>
<p><code>private com.squareup.okhttp.Call createRawCall()</code><br>根据由requestFactory根据args创建一个Request，然后利用这个Request创建一个okhttp.Call。</p>
<ul>
<li>parseResponse<br><code>private Response&lt;T&gt; parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException</code></li>
</ul>
<p>解析okhttp.Response，</p>
<ol>
<li>首先将body读取出来作为rawBody，然后用OkHttpCall.NoContentResponseBody作为新的Body，创建新的rawResponse。</li>
<li>判断Response.code()，如果不在200范围内，读取rawBody出来，返回一个错误的retrofit的Response。如果code为204或205（没有返回内容），则返回一个body为空的retrofit的Response。</li>
<li>如果code正常，则用OkHttpCall.ExceptionCatchingRequestBody包装一下rawBody，  然后使用responseConverter将包装后的catchingBody转化为具体的返回类型数据。</li>
</ol>
<p>OkHttpCall是将Request放入到okhttp的Call里面执行，执行完成后，又将okhttp的Call返回的Response转化为retrofit的Response，在此同时将Body里面的内容，通过converter转化为对应的对象。这个OkHttpCall</p>
<h5 id="4-2-8-Response"><a href="#4-2-8-Response" class="headerlink" title="4.2.8 Response"></a>4.2.8 Response</h5><p>这个类是包含了具体返回对象的响应体。里面包含了模版参数T类型的body对象，以及okhttp的Response。</p>
<h5 id="4-2-9-注解类"><a href="#4-2-9-注解类" class="headerlink" title="4.2.9 注解类"></a>4.2.9 注解类</h5><p>在Retrofit里面创建了Body注解，Filed注解（Field，FieldMap），请求方法注解（DELETE，GET，PATCH，POST，PUT），请求头注解（HEAD，Header，Headers），multipart注解（Part，Multipart，PartMap），接口加码（FormUrlEncoded），Url，Streaming，查询（Query，QueryMap），参数路径（Path），HTTP</p>
<h5 id="4-2-10-RequestBuilderAction"><a href="#4-2-10-RequestBuilderAction" class="headerlink" title="4.2.10 RequestBuilderAction"></a>4.2.10 RequestBuilderAction</h5><p>这是一个抽象类，只有一个未实现的perform方法。</p>
<p><code>abstract void perform(RequestBuilder builder, Object value);</code></p>
<p>但是在RequestBuilderAction类里面有很多RequestBuilderAction的子类，分别对应注解类。Url，Header，Path，Query，QueryMap，Field，FieldMap，Part，PartMap，Body都是在RequestBuilderAction的内部类，并且继承了RequestBuilderAction。RequestBuilder就是将对应注解的值给RequestBuilder。</p>
<h5 id="4-2-11-RequestBuilder"><a href="#4-2-11-RequestBuilder" class="headerlink" title="4.2.11 RequestBuilder"></a>4.2.11 RequestBuilder</h5><p>这是一个okhttp.Request的创建类。负责设置HTTP请求的相关信息，创建Request。它主要有以下方法：</p>
<ul>
<li>RequestBuilder</li>
<li>setRelativeUrl</li>
<li>addHeader</li>
<li>addPathParam</li>
<li>canonicalize static 方法</li>
<li>canonicalize</li>
<li>addQueryParam</li>
<li>addFormField</li>
<li>addPart</li>
<li>setBody</li>
<li>build</li>
</ul>
<p>它的构造方法如下：<br><code>RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers, MediaType contentType, boolean hasBody, boolean isFormEncoded, boolean isMultipart)</code></p>
<p>RequestBuilder就是创建请求。</p>
<h5 id="4-2-12-RequestFactory"><a href="#4-2-12-RequestFactory" class="headerlink" title="4.2.12 RequestFactory"></a>4.2.12 RequestFactory</h5><p>RequestFactory是创建Request，他有个create方法，</p>
<p><code>Request create(Object... args) {</code></p>
<p>参数是接口函数对应的参数值，cerate是创建RequestBuilder，遍历RequestFactory的成员变量requestBuilderActions，设置好RequestBuilder，最后创建Request返回。</p>
<h5 id="4-2-13-RequestFactoryParser"><a href="#4-2-13-RequestFactoryParser" class="headerlink" title="4.2.13 RequestFactoryParser"></a>4.2.13 RequestFactoryParser</h5><p>这个类主要是接口函数Method的每个注解。入口函数是parse。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) &#123;</div><div class="line">  RequestFactoryParser parser = new RequestFactoryParser(method);</div><div class="line">  parser.parseMethodAnnotations(responseType);</div><div class="line">  parser.parseParameters(retrofit);</div><div class="line">  return parser.toRequestFactory(retrofit.baseUrl());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先解析方法注解（应用到方法上的注解），比如说FormUrlEncoded，Headers。得到对应的值。</p>
<p>然后再解析方法参数注解（应用到方法参数上的注解），在解析方法参数注解的时候，会生成一个requestBuilderActions数组，对应到每个参数。每个Action都对应了每个函数参数的处理。等到具体函数调用的时候，跟函数具体的参数值对应。也就是RequestFactory与Builder的工作了，这部分是等到运行的时候才能够确定的。</p>
<h5 id="4-2-14-BuiltInConverters，OkHttpResponseBodyConverter，VoidConverter，OkHttpRequestBodyConverter"><a href="#4-2-14-BuiltInConverters，OkHttpResponseBodyConverter，VoidConverter，OkHttpRequestBodyConverter" class="headerlink" title="4.2.14 BuiltInConverters，OkHttpResponseBodyConverter，VoidConverter，OkHttpRequestBodyConverter"></a>4.2.14 BuiltInConverters，OkHttpResponseBodyConverter，VoidConverter，OkHttpRequestBodyConverter</h5><p>BuiltInConverters 继承自Converter.Factory，返回的responseConverter是OkHttpResponseBodyConverter或VoidConverter，也就是接口方法返回的职能是OkHttp的ResponseBody，或者Void。<br>返回的requestConverter是OkHttpRequestBodyConverter，接口方法的参数中如果使用Body，那Body也只能是OkHttp的RequestBody。</p>
<p>VoidConverter： 将OkHttp的ResponseBody转化为Void。<br>OkHttpResponseBodyConverter：将OkHttp的ResponseBody转化为OkHttp的ResponseBody。如果是Streaming标记的接口的话，利用Utils.readBodyToBytesIfNecessary缓冲整个body。<br>OkHttpRequestBodyConverter：将OkHttp的RequestBody转化为OkHttp的RequestBody。</p>
<h5 id="4-2-15-PlatForm-Android-MainThreadExecutor"><a href="#4-2-15-PlatForm-Android-MainThreadExecutor" class="headerlink" title="4.2.15 PlatForm.Android.MainThreadExecutor"></a>4.2.15 PlatForm.Android.MainThreadExecutor</h5><p>一个Executor，通过android Handler将Runnable执行在UI线程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class MainThreadExecutor implements Executor &#123;</div><div class="line">  private final Handler handler = new Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">  @Override public void execute(Runnable r) &#123;</div><div class="line">    handler.post(r);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="4-2-16-Utils"><a href="#4-2-16-Utils" class="headerlink" title="4.2.16 Utils"></a>4.2.16 Utils</h5><p>这是Retrofit中的一个工具类，里面包含了很多范型的检查、操作。另外以及一些基本的工具性的功能。下面是它里面的函数：</p>
<ul>
<li><p>checkNotNull<br><code>&lt;T&gt; T checkNotNull(T object, String message)</code><br>检查非空，如果是null，则抛出NullPointerException，内容提示为message。</p>
</li>
<li><p>closeQuietly<br><code>static void closeQuietly(Closeable closeable)</code><br>静默地关闭Closeable对象。不会抛出异常</p>
</li>
<li><p>isAnnotationPresent<br><code>static boolean isAnnotationPresent(Annotation[] annotations,Class&lt;? extends Annotation&gt; cls)</code><br>判断cls是否是annotations里面的一个实例。如果在则返回true。</p>
</li>
<li><p>readBodyToBytesIfNecessary<br><code>static ResponseBody readBodyToBytesIfNecessary(final ResponseBody body) throws IOException</code><br>如果body非null的话，把整个body读取出来（读取到buffer），返回再返回一个ResponseBody。</p>
</li>
<li><p>validateServiceInterface<br><code>static &lt;T&gt; void validateServiceInterface(Class&lt;T&gt; service)</code><br>验证接口是否有效，这个接口就是用户自定义的接口。如果不是接口，或者里面没有任何函数，则抛出IllegalArgumentException异常。</p>
</li>
<li><p>getSingleParameterUpperBound<br><code>public static Type getSingleParameterUpperBound(ParameterizedType type)</code><br>该函数获取type的单个模版参数的上届。如果type有多个类型，函数会抛出异常，如果模版参数不是WildcardType，则直接返回模版参数类型</p>
</li>
<li><p>hasUnresolvableType<br><code>public static boolean hasUnresolvableType(Type type)</code><br>判断是否有不能分解的类型，比如有TypeVariable，WildcardType等</p>
</li>
<li><p>getRawType<br><code>public static Class&lt;?&gt; getRawType(Type type)</code><br>这个方法是从Gson里面截取的，获取type的实际类型。</p>
</li>
<li><p>methodError<br><code>static RuntimeException methodError(Method method, String message, Object... args)</code><br><code>static RuntimeException methodError(Throwable cause, Method method, String message,Object... args)</code><br>两个重载函数，抛出方法错误异常</p>
</li>
<li><p>getCallResponseType<br><code>static Type getCallResponseType(Type returnType)</code><br>获取返回Call的返回类型，必须是模版参数类型，并且Call的模版参数不能是retrofit.Response.class。返回getSingleParameterUpperBound(returnType)</p>
</li>
</ul>
<h4 id="4-3-扩展"><a href="#4-3-扩展" class="headerlink" title="4.3 扩展"></a>4.3 扩展</h4><p>Retrofit是很适合扩展的，里面设计的Call，以及Converter就是为了方便扩展使用。</p>
<h5 id="4-3-1-Converter"><a href="#4-3-1-Converter" class="headerlink" title="4.3.1 Converter"></a>4.3.1 Converter</h5><p>Retrofit提供的默认的Converter只会返回ResponseBody，如果我们想要返回具体的Object，我们可以使用另外的第三方包，并且在创建Retrofit的时候添加对应的ConverterFactory。这里有6个序列化第三方库:</p>
<ul>
<li>Gson: com.squareup.retrofit:converter-gson</li>
<li>Jackson: com.squareup.retrofit:converter-jackson</li>
<li>Moshi: com.squareup.retrofit:converter-moshi</li>
<li>Protobuf: com.squareup.retrofit:converter-protobuf</li>
<li>Wire: com.squareup.retrofit:converter-wire</li>
<li>Simple XML: com.squareup.retrofit:converter-simplexml</li>
</ul>
<h5 id="4-3-2-Rxjava"><a href="#4-3-2-Rxjava" class="headerlink" title="4.3.2 Rxjava"></a>4.3.2 Rxjava</h5><p>retrofit也可以与<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">Rxjava</a>联合起来使用，之前的版本使用范例可以参考<a href="http://randomdotnext.com/retrofit-rxjava/" target="_blank" rel="external">http://randomdotnext.com/retrofit-rxjava/</a></p>
<ul>
<li>adapter-Rxjava: com.squareup.retrofit:adapter-rxjava</li>
</ul>
<p>正在开发中，主要是通过扩展CallAdapter，将之前Call，转换为rxjava需要的Observable&lt;?&gt;。</p>
<h3 id="5-杂谈"><a href="#5-杂谈" class="headerlink" title="5 杂谈"></a>5 杂谈</h3><p>  Retrofit整体框架的代码并不多，主要是围绕着converter，CallAdapter设计的整个框架。花了两天时间耐耐心心地把代码也是挺有收获。Retrofit用到的基本技术是动态代理，Java注解，Java范型。另外如果对设计模式很熟悉的话，读起来感觉就会很简单。整个架构设计的非常好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/09/10/jvm-memory-manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/jvm-memory-manager/" itemprop="url">JVM内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-10T00:00:00+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://xxxzhi.github.io/images/beautiful4.jpg" alt="图片"></p>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>Java的内存区域主要包括虚拟机栈，本地方法栈，程序计数器，堆，方法区。</p>
<p><strong><em>虚拟机栈</em></strong>是对应于每个线程运行时候的东西，JVM会给每个线程分配一个栈，线程运行就是执行栈里面的东西。这个栈又包含了帧，帧对应着线程函数。栈里面只能够出帧和入帧，对应着每个函数的运行和运行完成。</p>
<p><strong><em>本地方法栈</em></strong>是每个线程native代码对应的部分。与虚拟机栈很相似，但是本地方法栈执行的是Java Native方法。</p>
<p><strong><em>程序计数器</em></strong>可以看作是当前线程执行字节码的行号指示器。字节码解释器可以通过改变程序计数器的值来选取下一条需要执行的指令。分支，循环，跳转都需要这个计数器来实现。</p>
<p><strong><em>JAVA堆</em></strong>是所有线程共享的，每次new的时候，JVM就会在Java堆里面划一块区域。平时的内存溢出也基本都是这块区域超出了。</p>
<p><strong><em>JAVA方法区</em></strong>是存储着已经加载的类，常量，静态变量等数据。方法区，也常被称作永久代，方法区很少进行垃圾回收，回收也非常严苛。如果这个区域出现异常，则一般会提示PermGen space。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Java中有四种引用，强引用，软引用，弱引用，虚引用。JVM对每种类型的回收是不一致的。</p>
<p><strong>强引用</strong>是Java中最常见的，一般我们使用的<code>Object object = new Object</code>就是强引用。一个对象只要存在强引用，对象就不会被回收，如果内存不够，就抛出OutOfMemory异常。</p>
<p><strong>软引用</strong>是如果一个对象只有软引用，那么在内存足够的时候对象不会回收该对象，如果内存不够的时候对象就会被回收。软引用适合作高速缓存。</p>
<p>软引用可以和引用队列一起使用，当引用对象被回收的时候，会被虚拟机加入到引用队列里面去。</p>
<pre><code>SoftReference&lt;Object&gt; softObject = new SoftReference(new Object(),new ReferenceQueue&lt;Object&gt;())
</code></pre><p><strong>弱引用</strong>是一个对象如果只有弱引用，那么对象在下次垃圾回收的时候，不管内存足不足够都会被回收。它比软引用的周期更短，不过垃圾回收是一个优先级非常低的线程，对象实际上被回收也不会那么快。它也可以跟一个引用队列一起使用。</p>
<p><strong>虚引用</strong>是一个更加弱小的引用，只有虚引用的对象不知道对象什么时候会被回收。它主要用来跟踪对象被垃圾回收的活动。它一定要跟一个引用队列一起使用。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Java会有一个单独垃圾回收进程，对虚拟机在程序新建的但已经没有用的对象进行回收。对于如何判断对象是否还在使用，这里面有两种常见的方式是引用计数法跟可达性分析法。<strong>引用计数法</strong>通过给每个对象的引用进行计数，这种方式很简单，并且效率高。但是在解决循环引用的时候效果并不好。而主流的编程语言都是采用<strong>可达性分析法</strong>来进行对象是否还有用的判断的，可达性分析法通过一系列的“GC ROOT”对象，通过其引用的对象以及这些对象的引用不断地循环扩展，构成一颗引用树，那些没有在这颗树上的对象就是没有用的，可以被回收的对象了。</p>
<p>垃圾收集算法有很多，像标记清除算法，复制算法，标记整理算法，分代收集算法等等。</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>JVM在内存分配的时候遵循着一些规则：</p>
<ol>
<li><p>对象优先分配在Eden区</p>
</li>
<li><p>大对象直接分配在老年代，老年代的回收是非常少的，老年代的回收是一次Full GC。</p>
</li>
<li><p>长期存活的对象进入老年代</p>
</li>
<li><p>动态对对象年龄的判断，如果Eden区有相同年龄的对象内存之和超过新生代空间一半，则将年龄超过这些年龄相同对象的对象都移到老年区</p>
</li>
<li><p>空间分配担保，在进行minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于则直接GC，如果不大于，则要根据之前新生代到老年代的对象的平均大小来判断，如果老年代连续可用空间比平均大小大，则继续minor GC，如果不大，则进行一次Full GC。<br>内存代，新生代，老年代，永久代</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/09/10/http-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/http-protocol/" itemprop="url">Http协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-10T00:00:00+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://xxxzhi.github.io/images/beautiful1.jpg" alt="enter image description here"></p>
<p>老早就学了Http协议，但是最开始学HTTP协议的时候，没有从内心意识到他的地位之高，它的使用范围之广。那时候学习的时候，基本时联系到平时使用的Apache Http包或者Java HttpUrlConnection来考虑了。更多地是在应用，或者说是比较，但是最近接触到的各种知识，像REST规范。以及使用的API各种接口。越来越觉得HTTP协议是简单但重要的东西。以前对HTTP协议，是从应用来考虑的，而现在我觉得应该从协议上面来重新学习一下。</p>
<h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><p>平时使用最多的，接触最多的，都是POST方式，GET方式请求，其实这只是HTTP协议中请求的Method而已。HTTP协议的第一行（<strong>请求行</strong>）就是包括下面这些内容：</p>
<pre><code>METHOD URI  VERSION CRLF
</code></pre><p>example：</p>
<pre><code>GET /index.html http/1.0 CRLF
</code></pre><p>对应中文的解释分别是：Http请求方法，uri路径，http协议版本（有1.0和1.1），回车换行。而HTTP协议中，METHOD有GET，POST，HEAD，PUT，DELETE，TRACE。</p>
<p>在请求行之后，整个请求头还有一系列的请求报头，像Host(HTTP1.1中，Host是必须的)，Accept，If-Modified-Since等等。在请求消息报头后面，还有一个请求体，POST请求内容就放请求体中，而GET请求则放在url后面（?param1=1&amp;param2=2）。</p>
<p>这是一个非常简单的请求的例子：</p>
<pre><code>GET /index.html http/1.1 CRLF
Host:localhost:8080
Accept:*/*
</code></pre><h2 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h2><p>响应消息是指HTTP协议返回的消息，包括状态行，响应头，响应体。状态行格式如下所示：</p>
<pre><code>HTTP-VERSION STATUS-Code RESULT-Phrase
</code></pre><p>比如：</p>
<pre><code>http/1.1 200 ok
</code></pre><p>在状态行之后就是响应头，响应头类似于请求头，包含了响应的一些信息，以key：value的形式，其中包括诸如Allow，Date，Content-Length等。这个里面每个响应头都有重要用处，在平时的使用中，如果能够理解这些，对于一些请求错误，会有非常大的帮助，就比如说Encoding，Language。乱码就是来源于请求头，和响应头的这些信息不对。</p>
<p>在响应头之后，就是响应体，HTTP返回的附加内容就是放在响应体当中。比如请求文件，那么文件内容就在这个里面。</p>
<h2 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h2><p>在平常对HTTP的使用当中，用的最多的就是这两个了，这两个大部分的区别平常基本是明了的：</p>
<ol>
<li><p>GET的参数放在url后面，而POST的参数放在body里面。这样GET的参数长度有限制（1024），而POST长度没有限制。另外这样，POST请求也更加安全。参数放在url中，会有纪录。而被人查看到。</p>
</li>
<li><p>GET没有body，而POST有body</p>
</li>
<li><p>服务器解析GET参数是从Request.QueryString中解析，而POST是从Request.Form中解析。这一点需要特别注意，特别是在使用一些没有对请求参数进行封装的HTTP包的时候。</p>
</li>
</ol>
<h2 id="HTTP与具体代码"><a href="#HTTP与具体代码" class="headerlink" title="HTTP与具体代码"></a>HTTP与具体代码</h2><p>很多人可能一开始接触的不是协议，而是代码。而现在很多应用包都非常好地封装了HTTP协议。如果不去了解HTTP协议，对于这些封装的API函数，显然是无法彻底熟悉的。</p>
<p>其实从HTTP协议上面来看，那些对HTTP请求控制的API，可以分成三个部分，请求方法，请求头内容设置，请求体写入。同样响应也是一样的。从这个思路上去看HTTP请求与响应，对于HTTP的处理就会非常清晰明了。</p>
<p>我们使用最多的可能时响应行中的状态码，我们经常会遇到4开头，5开头的错误。遇到这种，从状态码就可以发现是什么错误原因了。比如说503，那可能是服务器出现错误了，去查看服务器的日志。如果404，就可以考虑是不是自己的url写错了某个字母。</p>
<p>除了状态码外，响应头跟请求头的对应也是非常重要。还有有时候，得到的响应内容是乱码的，这个时候就要看客户端解码是否使用了正确的编码，服务器端写入是否采用了正确的编码，根HTTP响应头协议中的编码格式是否一致。很快就可以查找出来，而不是拿着乱码的错误，到处google，百度，搜索引擎很多时候都不如自己明白详里后，查找原因并且解决问题来的快。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/09/10/jvm-class-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/jvm-class-format/" itemprop="url">java虚拟机Class格式与指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-10T00:00:00+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://xxxzhi.github.io/images/beautiful5.jpg" alt="#java虚拟机Class格式与指令"></p>
<p>前几天看《深入理解java虚拟机》中关于.class文件的详细解析，实际上Class文件里面就是包含着运行时候的指令，以及数据等内容。如果想要能够读懂Class文件，那一定需要对Class的文件结构以及Java虚拟机指令集有一定的了解</p>
<h2 id="JVM指令集"><a href="#JVM指令集" class="headerlink" title="JVM指令集"></a>JVM指令集</h2><p>java虚拟机也有自己的指令集（<strong><em>字节码指令集</em></strong>），指令占一个字节长度，也就是说JVM中的指令最多也就256个。一常用的指令如:iload,iadd,isub,imul…,这里举的例子只是对应于int类型的运算操作码，如果float类型，对应的指令为：fload,fadd,fsub,fmul…。由指令加上对应的数据就是一次运算了。</p>
<p>与指令紧密相关的就是操作数了，JVM里面有操作数栈，本地变量表。</p>
<h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>对一个非常简单的java文件：</p>
<pre><code>public class Test{
    private int a;

    public int value(){
       return a;
    }
}
</code></pre><p>使用<figure class="highlight plain"><figcaption><span>Test.java```得到Test.class.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用```javap -verbose Test.class```可以获得Class文件可视化结果.其中包括常量池，函数字节码代码</div></pre></td></tr></table></figure></p>
<pre><code>Classfile /Users/houzhi/Test.class
Last modified Sep 8, 2015; size 265 bytes
  MD5 checksum 7a6cc538f28ef4dc4978891008b41ed8
  Compiled from &quot;Test.java&quot;
public class Test
  SourceFile: &quot;Test.java&quot;
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#15         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #3.#16         //  Test.a:I
   #3 = Class              #17            //  Test
   #4 = Class              #18            //  java/lang/Object
   #5 = Utf8               a
   #6 = Utf8               I
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               value
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               Test.java
  #15 = NameAndType        #7:#8          //  &quot;&lt;init&gt;&quot;:()V
  #16 = NameAndType        #5:#6          //  a:I
  #17 = Utf8               Test
  #18 = Utf8               java/lang/Object
{
  public Test();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return        
      LineNumberTable:
        line 2: 0

  public int value();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0       
         1: getfield      #2                  // Field a:I
         4: ireturn       
      LineNumberTable:
        line 7: 0
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从上面的结果可以大概看出一些内容，其中major version是java的版本，java7对应是51.然后是类的访问标志，public。然后是常量表，记录字符的表，包括函数名称，变了名称，类路径名称等等。</div><div class="line">再之后是函数，每个函数其实是方法表，方法表里面再包括了访问标志，代码表，LineNumberTable是指函数是在第几行。</div><div class="line"></div><div class="line">代码段里面的内容主要是刚刚操作码的指令，从这些字节代码是完全可以查看函数的功能的。</div><div class="line"></div><div class="line">## 利用查看Class解决bug</div><div class="line">这里顺便提一下我昨天干的一件事，因为部署的服务器应用的源代码在另外一个开发者那里，暂时他去有事了。但是我重新部署他的代码发现有问题，保存图片的位置一直不对，经过测试，感觉他可能是在程序里面写了一个固定的地址，导致换了服务器后，路径总是不太对。正巧这段时间有空的时候就在虚拟机的相关东西，而且基本能确定很大可能是路径问题，所以直接尝试去查看class的内容，就使用了```javap -verbose```来查看对应的class文件的内容，查看引用的地方最终找到了保存的代码，发现确实是他把保存路径写死了。</div><div class="line"></div><div class="line">找到了问题，一下子没源码，就尝试修改class文件去解决这个问题，毕竟class文件是编译后，按照规范的，只要class是符合规范，程序验证通过的话，就会被JVM接受。使用修改的方式如下</div><div class="line"></div><div class="line">1. 使用vim -b Upload.class，这个时候是打开二进制文件，一堆乱码</div><div class="line">2. 输入vim的命令 :%!xxd 把文件转换成二进制的读入，转化后内容会变成这样</div></pre></td></tr></table></figure>
<pre><code>0000010: 1400 1508 0016 0a00 1700 1807 0016 0700  ................

0000020: 1901 0004 5445 5354 0100 124c 6a61 7661  ....TEST...Ljava

0000030: 2f6c 616e 672f 5374 7269 6e67 3b01 000d  /lang/String;...
</code></pre><p>```</p>
<ol>
<li>然后看着右边那里的解释修改。我是直接改了路径，所以相对比较简单，如果太复杂就最好先编译。输入 :%!xxd -r 可以切换回原来的模式。修改后保存。修改可以直接改那些数字。</li>
<li>一次非常好的class文件学习实践体验。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/06/21/android-childautomovi-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/21/android-childautomovi-layout/" itemprop="url">子View按规则自动移动Layout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-21T00:00:00+08:00">
                2015-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://raw.githubusercontent.com/xxxzhi/ChildAutoMovi-Layout/master/movi.gif" alt="Alt Text"></p>
<p>项目地址：<a href="https://github.com/xxxzhi/ChildAutoMovi-Layout" target="_blank" rel="external">https://github.com/xxxzhi/ChildAutoMovi-Layout</a></p>
<p>之前看到一个屏幕上有点不断闪动的，并且移动的界面。当时久萌生一种想法，能不能做一个这样的选择界面呢？</p>
<p>实现起来其实比较简单，写了一下之后，感觉完全可以做一个可以很好地重用，并且方便扩展移动规则的View。趁着平时时间，就干脆实现了它，并且粗略写了几种移动规则。</p>
<h2 id="ChildAutoMoviLayout实现"><a href="#ChildAutoMoviLayout实现" class="headerlink" title="ChildAutoMoviLayout实现"></a>ChildAutoMoviLayout实现</h2><h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><p>考虑到平时使用起来比较方便使用的是RelativeLayout，所以用ChildAutoMoviLayout作为RelativeLayout的子类。这样用户在使用这个Layout的时候，<br>可以更加方便地扩展。比如使用Margins。</p>
<h3 id="添加子View方式"><a href="#添加子View方式" class="headerlink" title="添加子View方式"></a>添加子View方式</h3><p>另外，因为每个子View可以要求为一致，因为自动移动，基本上是一些差不多形式的View移动。所以我使用Android AbsListView的Adapter作为ChildAutoMoviLayout<br>的Adapter。ChildAutoMoviLayout通过读取Adapter来给它自己添加子View 。ChildAutoMoviLayout不通过addView来添加View。这样用户只要实现一个<br>Adapter就可以了。甚至可以直接把ListView的Adapter拿来使用。</p>
<h3 id="移动规则"><a href="#移动规则" class="headerlink" title="移动规则"></a>移动规则</h3><p>移动规则，我设计一个接口，用户只要实现那个接口，并且给ChildAutoMoviLayout就可以了。setMoviInterface。移动规则采用两个方法</p>
<pre><code>/**    
     * 移动    
     * @param view    
     * @param height 移动高度    
     * @param width 移动宽度    
     */    
void move(View view,int width,int height);    


/**    
     * 初始化位置    
     * @param view    
     * @param height 移动高度    
     * @param width 移动宽度    
     */    
void init(View view,int width,int height);    
</code></pre><h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>我使用的是TimeTask作为一个定时器，然后利用定时器，每隔20毫秒移动一下图中的标签（子类视图）</p>
<pre><code>timer.scheduleAtFixedRate(timerTask, 1000, 20);
</code></pre><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="xml使用："><a href="#xml使用：" class="headerlink" title="xml使用："></a>xml使用：</h3><pre><code>&lt;com.houzhi.childautomovi.view.ChildAutoMoviLayout    
android:id=&quot;@+id/tagView&quot;    
android:layout_below=&quot;@+id/tag_container&quot;    
android:layout_width=&quot;match_parent&quot;    
android:layout_height=&quot;match_parent&quot;&gt;    
&lt;/com.houzhi.childautomovi.view.ChildAutoMoviLayout&gt;    
</code></pre><h3 id="java代码使用示例："><a href="#java代码使用示例：" class="headerlink" title="java代码使用示例："></a>java代码使用示例：</h3><ol>
<li><p>从xml中解析出</p>
<pre><code>//从xml中解析出
ChildAutoMoviLayout tagRandomView = (ChildAutoMoviLayout) findViewById(R.id.tagView);    
final LinearLayout linear = (LinearLayout) findViewById(R.id.tag_container);    
</code></pre></li>
<li><p>设置Adapter和移动策略</p>
</li>
</ol>
<pre><code>final TagAdapter adapter = new TagAdapter();    
tagRandomView.setAdapter(adapter, new BubbleLineUpMoving());    
</code></pre><ol>
<li>监听标签（子View）的移动</li>
</ol>
<pre><code>tagRandomView.setOnTagClickListener(new ChildAutoMoviLayout.TagClickListener() {    
                @Override    
                public void onTagClickListener(View view, int position, long id) {    
                        //TODO click things    

                }    
        });    
</code></pre><ol>
<li>开始动画</li>
</ol>
<pre><code>tagRandomView.startMoving();    
</code></pre><p>项目地址：<a href="https://github.com/xxxzhi/ChildAutoMovi-Layout" target="_blank" rel="external">https://github.com/xxxzhi/ChildAutoMovi-Layout</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/06/02/java-Runtime-exec-delay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/02/java-Runtime-exec-delay/" itemprop="url">Runtime.exec使用错误导致延迟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-02T00:00:00+08:00">
                2015-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div align="center"><img src="http://i1383.photobucket.com/albums/ah295/houzhi/12934238772tru_zpsrzqqhdxf.jpg" width="640"></div>


<p>这篇文章是纪录了一个bug解决的过程，但是我还是没有能够真正地找出bug的缘由。希望大牛能够详细解释。</p>
<h2 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h2><p>当接触的系统越来越大的时候，对于系统的性能越来越高的时候，找到表面问题的真正原因就慢慢地成为了一个比较麻烦的问题。说实话，一开始我一直不知道是因为Runtime.getRuntime().exec()导致服务处理时间缓慢。发现这个原因倒是花了不少时间。</p>
<p>为了方便，我直接就用java调用python脚本。用python脚本处理做核心的机器学习算法的东西。而java调用python脚本，我直接就采用了Runtime.getRuntime().exec()，这个方式类似于直接使用了shell来执行。一开始使用的挺好，也没有注意一些细节的问题，慢慢地用着用着，发现有一台机器处理相同地人脸头像比另外一台慢。从经验上考虑过很多的可能情况，但是都不是问题的真正原因。但每一个误判，我感觉都非常值得反思。</p>
<h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>由于我使用了内网穿透工具，本身对工具性能也不熟悉，刚开始的时候立刻就想到了是不是因为使用了内网穿透工具，导致网速太慢了。由于这个问题我几乎就无法解决，所以我一想到这个原因，就没有再去想办法解决了。后面直接发现直接从访问的结果仍然是一样的慢。其实这个地方我应该去<strong>验证</strong>一下，直接从内网访问，看一下速度。这样就能够避免误判带来的问题了。</p>
<h3 id="机器配置问题"><a href="#机器配置问题" class="headerlink" title="机器配置问题"></a>机器配置问题</h3><p>由于两台机器配置的时候还是存在一点点不同，我后面又想是不是一台机器配置出现问题？检查了半天还是不能确认是不是机器配置不同，安装的内容不同导致出现了问题。由于没什么时间，干脆我又扔一边去了。</p>
<h3 id="某些随机因素"><a href="#某些随机因素" class="headerlink" title="某些随机因素"></a>某些随机因素</h3><p>因为一台机器执行快速，另外一台执行缓慢，而出现这种诡异的问题，很容易就让人想到是不是代码库因为某些原因，导致了这种情况。而往往这种问题就基本是没有办法搞定了。其实我还是一个新手的时候，我总是怀疑某些问题是因为一些系统错误，随机因素导致的。但是结果往往是自己的错误。因为有了之前的经验，我潜意识就感觉可能是自己哪段代码出现了错误。</p>
<p>之后通过对代码片段打印时间，每一段执行完都打印时间点。最后查看日志发现，就是在调用process.waitfor的时候，python程序已经返回了，但是java程序仍然没有任何响应，还是在wait。这样才发现了这个问题。然后通过在网上搜索Runtime.getRuntime()执行程序应该注意的事项，找到问题的关键。我使用waitfor，之后再去读取python程序的输出，但是因为输出一直没有被读取，缓冲区满了，程序就被阻塞。</p>
<h2 id="etRuntime-exec"><a href="#etRuntime-exec" class="headerlink" title="etRuntime().exec"></a>etRuntime().exec</h2><p>getRuntime().exec会返回一个Process，在jdk文档中有说明，Process的缓冲区是有限的，如果输出的内容太多，程序就会被阻塞掉。<br>我一开始的程序是像下面这样的：</p>
<pre><code>​    ​try {          
​    ​         final Process p = Runtime.getRuntime().exec(&quot;python test.py&quot;);
​    ​    ​    ​ p.waitFor();       
​    ​         BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
​    ​         try {
​    ​                      while (br.readLine() != null)
​    ​                          ;
​    ​                      br.close();
​    ​          } catch (IOException e) {
​    ​               e.printStackTrace();
​    ​          }
​    ​} catch (Exception e) {
​    ​          e.printStackTrace();      
​    ​}
</code></pre><p>这样的结果就是一台机器在waitFor那里被卡住很长一段时间。然后参考了网上给的原因，将程序改成下面这样：</p>
<pre><code>try {          
         final Process p = Runtime.getRuntime().exec(&quot;python test.py&quot;);

         BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
         try {
                      while (br.readLine() != null)
                          ;
                      br.close();
          } catch (IOException e) {
               e.printStackTrace();
          }
          p.waitFor();  
} catch (Exception e) {
          e.printStackTrace();      
}
</code></pre><p>这样程序就不会长时间卡在那里。甚至于去掉p。waitFor程序也是OK的。因为程序结束后，Stream就被close掉了。网上很多人是遇到了因为exec执行的程序出现了错误，结果Error信息占满了缓冲区，导致程序被挂起。</p>
<h2 id="原因探究"><a href="#原因探究" class="headerlink" title="原因探究"></a>原因探究</h2><p>从网上看的那些信息只能让我猜测可能是因为打印信息太多，没有及时读出，导致程序卡住。但是我心里还是有疑问，为什么一台机器ok，另外一台机器会卡住，过很长时间才返回呢？这里面具体的细节方面的原因我觉得我还是没有找对。其实我python程序打印的东西也不多的。</p>
<p>另外也有一个可能是python程序执行完后，很长时间都没有完全返回。这也是一个猜测的原因。<strong>虽然我按照网上的方式暂时解决了问题，但这些原因其实我觉得都不够充分，希望有人能够给出正确的解释</strong>。基础真的要牢靠。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/04/28/android-pageradapter-notifydatasetchanged/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="侯志">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/28/android-pageradapter-notifydatasetchanged/" itemprop="url">Android notifyDatasetChanged</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-04-28T00:00:00+08:00">
                2015-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div align="center"><img src="http://i1383.photobucket.com/albums/ah295/houzhi/20130519041943_18280_zpspnyvmavc.jpg" width="640"></div>


<h2 id="forget-to-call-notifyDatasetChanged-错误"><a href="#forget-to-call-notifyDatasetChanged-错误" class="headerlink" title="forget to call notifyDatasetChanged 错误"></a>forget to call notifyDatasetChanged 错误</h2><p>这几天一直在完善之前自己的写的Android应用。想用ViewPager让之前界面能够滑动阅读。但是滑动过程中，经常会莫名其妙地遇到一个问题。莫名其妙地提示ViewPager expected 10 counts，but found 20.  forget to call notifyDatasetChanged. 意思很明显，就是ViewPager的数据集改变了，但是我却忘了去通过notifyDatasetChanged去通知PagerAdapter数据已经更新了。但是我其实在那个页面压根没有去更新数据。不过根据提示显然是因为哪个地方改变了数据的数量。还好我动态更新数据的地方不多。检查一下代码，根据自己的思路，立刻发现了问题。我会在已经载入当前列表的时候，去服务器取下一个列表。这样在我取完下一个列表的时候，数据就变了。然后就出现那个问题了。</p>
<p>虽然没怎么浪费时间就解决了问题，但是在面对多个线程数据共享的时候确实得增加一些额外的考虑。PagerAdapter的数据如果改变，是需要调用notifyDatasetChanged方法的。多线程的共享需要考虑同步的问题，这个同步不仅仅是一个synchronize就能够避免的，每个线程都需要去预防共享的数据被另外一个线程更改了。</p>
<h2 id="ViewPager与Fragment"><a href="#ViewPager与Fragment" class="headerlink" title="ViewPager与Fragment"></a>ViewPager与Fragment</h2><p>我在使用ViewPager的时候，使用了FragmentStatePagerAdapter作为它的Adapter，因为会有很多Fragment，如何从ViewPager控制它的Fragment就成了一个问题。</p>
<p>当然，直接保存ViewPager的所有Fragment似乎就能够控制了，但是这实在是不科学，保存起来太耗空间。而实际上ViewPager每次只有几个View保存着。当前显示的View以及前后几个View，在这之外的View都会被destory掉。这样能够很好地控制占用的内存。</p>
<p>但是幸运地是FragmentActivity的FragmentManager提供了一个getFragments的方法，该方法能够获取当前所有的Fragment。这样问题就解决了。获取Activity中所有的Fragment，然后判断是不是FragmentStatePagerAdapter的Fragment。这样ViewPager就能够直接控制它的Fragment Item了。</p>
<p>对于FragmentPagerAdapter与FragmentStatePagerAdapter的区别，FragmentPagerAdapter会对每一个Fragment进行缓存，而FragmentStatePagerAdapter不会。两个的使用方法是一样的。</p>
<h2 id="notifyDatasetChanged做了什么工作？"><a href="#notifyDatasetChanged做了什么工作？" class="headerlink" title="notifyDatasetChanged做了什么工作？"></a>notifyDatasetChanged做了什么工作？</h2><p>每个Adapter都会有<code>private DataSetObservable mObservable = new DataSetObservable();</code> 一个DataSetObservable观察者。这个观察者可以注册<code>registerDataSetObserver</code>。而notifyDatasetChanged函数做的就是通知注册这，我的数据已经改变了。</p>
<p>这样就给了ViewPager监听Adapter数据集变化的机会。在ViewPager的setAdapter中，有下面这段代码:</p>
<pre><code>431        if (mAdapter != null) {
432            if (mObserver == null) {
433                mObserver = new PagerObserver();
434            }
435            mAdapter.registerDataSetObserver(mObserver);
436            mPopulatePending = false;
437            final boolean wasFirstLayout = mFirstLayout;
438            mFirstLayout = true;
439            mExpectedAdapterCount = mAdapter.getCount();
440            if (mRestoredCurItem &gt;= 0) {
441                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);
442                setCurrentItemInternal(mRestoredCurItem, false, true);
443                mRestoredCurItem = -1;
444                mRestoredAdapterState = null;
445                mRestoredClassLoader = null;
446            } else if (!wasFirstLayout) {
447                populate();
448            } else {
449                requestLayout();
450            }
451        }
</code></pre><p>在上面的代码中，注册了数据集变化的观察者。而notifyDatasetChanged就是通知观察者。</p>
<hr>
<p>探究</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">houzhi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">houzhi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
