<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Creative, Challenging and Cogitative">
<meta property="og:url" content="http://houzhi.me/page/3/index.html">
<meta property="og:site_name" content="Creative, Challenging and Cogitative">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Creative, Challenging and Cogitative">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://houzhi.me/page/3/"/>





  <title>Creative, Challenging and Cogitative</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Creative, Challenging and Cogitative</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            HOME
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            ARCHIVE
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/26/android-nice-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/26/android-nice-blog/" itemprop="url">平时看的优质技术博客与网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-26T00:00:00+08:00">
                2016-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>突然想起面试的时候，经常问我平时都看什么网站，我基本都是说最近两天看的。仔细想想，平时貌似还看了不少网站。</p>
<h2 id="论坛性质"><a href="#论坛性质" class="headerlink" title="论坛性质"></a>论坛性质</h2><p>这种的话，看的频率会高很多，只要没什么事，几乎每天都去看看，主要还是因为更新多。</p>
<p><a href="http://stackoverflow.com/" target="_blank" rel="external">StackOverflow: http://stackoverflow.com/</a> </p>
<p><a href="https://plus.google.com/" target="_blank" rel="external">Google+: https://plus.google.com/</a></p>
<h2 id="博客网站"><a href="#博客网站" class="headerlink" title="博客网站"></a>博客网站</h2><p>博客我比较少每天看，都是某个时间一起看。下面是我看过的一些学到很多东西的博客</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/" target="_blank" rel="external">IBM: http://www.ibm.com/developerworks/cn/java/ </a> 里面的Java专题很赞</p>
<p><a href="http://www.infoq.com/" target="_blank" rel="external">infoq: http://www.infoq.com/</a> 里面有很多关于目前比较火的技术的，以及技术方向的文章</p>
<p><a href="http://club.alibabatech.org/" target="_blank" rel="external">阿里技术沙龙：http://club.alibabatech.org/</a></p>
<p><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术博客:http://tech.meituan.com/</a> 更新比较慢，所以有幸从头到尾看了全部</p>
<p><a href="http://www.alloyteam.com/" target="_blank" rel="external">腾讯技术博客: http://www.alloyteam.com/</a>前端较多</p>
<p><a href="http://blog.jobbole.com/" target="_blank" rel="external">伯乐在线: http://blog.jobbole.com/</a></p>
<p>以及<br><a href="http://blog.csdn.net/" target="_blank" rel="external">csdn: http://blog.csdn.net/</a> </p>
<h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><p>这个我看的比较少，都是收藏起来，有空一起看，包括关注的公众号也是一样。或者有时候看到了，直接全部看完。</p>
<p><a href="http://taosay.net/" target="_blank" rel="external">道哥的黑板报: http://taosay.net/</a> 大多关于安全的，超给力<br><a href="http://www.trinea.cn/" target="_blank" rel="external">Trinea: http://www.trinea.cn/</a><br><a href="http://hukai.me/" target="_blank" rel="external">胡凯: http://hukai.me/</a><br><a href="http://blog.csdn.net/Luoshengyang" target="_blank" rel="external">罗升阳: http://blog.csdn.net/Luoshengyang</a> 目前看Android源码的时候，参考的最多的<br><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚: http://blog.csdn.net/singwhatiwanna</a><br>…</p>
<p>还有，我就不一一列举了，我都是如果google的时候看到了，有空就会把他们的我感兴趣的一下子看完…</p>
<h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p>这个倒是经常看看</p>
<p><a href="http://www.geekpark.net/" target="_blank" rel="external">极客公园: http://www.geekpark.net/</a><br><a href="http://36kr.com/" target="_blank" rel="external">36氪: http://36kr.com/</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然还有Github，这个应该没必要说了，必备。</p>
<p>经常看的其实也就是stackoverflow跟googleplus, 以及csdn，极客公园和36氪，因为它们内容更新多，基本每天去看。其他的都是一次看n篇那种，就跟看Github的开源项目一样，经常是如沐春风。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/23/android-sourcecode-proxy-binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/23/android-sourcecode-proxy-binder/" itemprop="url">Android源码代理模式---Binder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-23T00:00:00+08:00">
                2016-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Binder是Android的进程间通信核心，如果看过Android源码，你会发现源码中Android的各种核心服务都是通过Binder机制进行相互通信的。在Binder的client部分就是通过代理模式来访问Server端的。这里想通过代理模式来详细介绍Java层Binder。文中会简单介绍代理模式，详细介绍Binder机制。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>对其他对象提供一种代理以控制对这个对象的访问。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="http://xxxzhi.github.io/images/proxy.png" alt="此处输入图片的描述"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"real operate"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Subject realSubject;</div><div class="line">    Proxy(Subject subject)&#123;</div><div class="line">        realSubject = subject;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>&#123;</div><div class="line">        realSubject.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    RealSubject real = <span class="keyword">new</span> RealSubject();</div><div class="line">    Proxy proxy = <span class="keyword">new</span> Proxy(real);</div><div class="line">    proxy.operate(); <span class="comment">//实际上交给了realsubject去操作了。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于代理模式"><a href="#关于代理模式" class="headerlink" title="关于代理模式"></a>关于代理模式</h3><p>上面的代码跟UML图只是一个例子，并不能完全描述代理模式的。代理模式强调的是一种代理，上面的例子中其实直接用RealSubject就可以了，完全没必要用Proxy。另外代理与被代理对象并不要求有共同的父类/接口。代理模式有几种常见的情况：</p>
<ul>
<li>远程代理(Remote Proxy): 如果某个对象无法实例化，不在同一个地址空间，需要通过编码来进行通信。比如需要访问网络服务器上面的一个对象操作。比如我们接下来需要介绍的Binder。</li>
<li>虚代理(Virtual Proxy): 在需要的时候创建大对象，比如超大图片，我们可以使用一个虚代理代理图像，在真正需要的时候再去将图像完全加载出来，在这之前只需要在代理里面保存图像的大小，让它有个占位就好了。</li>
<li>保护代理(Protect Proxy): 需要对对象的某些操作进行隐藏，那么就可以使用代理对它的接口进行隐藏。</li>
<li>智能指引(Smart Reference):　当需要对对象的引用进行计数的时候，可以使用智能指引的代理模式。</li>
</ul>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder是一个接口形式的IPC。在这里以我们在应用程序开发过程中使用的.aidl文件声明生成的接口为例。使用aidl需要说明的是Android官方文档上面强调过:</p>
<blockquote>
<p>使用aidl的必要条件是你的Service想要被其他客户端从不同的应用程序为了IPC而调用，并且想要在你的Service中处理多线程。如果你不需要并行来自不同的应用程序的IPC,那么你只需要使用实现Binder就好了，如果你不需要处理多线程的并行，那么你使用Messenger就好了。</p>
</blockquote>
<p>这里只是为了说明Binder，名称为ITestService.aidl:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package com.houzhi.testproject;</div><div class="line"></div><div class="line">interface ITestService&#123;</div><div class="line">    String getContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在编译运行前，Android ide(eclipse/android studio) 会自动生成相关的类，ITestService.Stub, ITestService.Proxy, 而我们通过调用bindService就可以得到Binder的代理。</p>
<pre><code>Intent service; //只是为了表明类型
ServiceConnection connection = new ServiceConnection(){
    public void onServiceConnected(ComponetName name, IBinder service){
        ITestService testService = ITestService.stub.asInterface(service);
        //testService就是我们得到的代理
    }
    public void onServiceDisConnected(ComponentName name){

    }
}
context.bindService(service,connection);
</code></pre><p>整个自动生成的类以及Binder, IInterface的UML图如下：<br><img src="http://xxxzhi.github.io/images/binder.png" alt="binder"></p>
<p><code>ITestService.stub.asInterface(service)</code>的内部就是创建了一个Proxy对象，其实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static com.houzhi.testproject.IMyAidlInterface asInterface(android.os.IBinder obj)     &#123;</div><div class="line">    if ((obj == null)) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">    if (((iin != null) &amp;&amp; (iin instanceof com.houzhi.testproject.IMyAidlInterface))) &#123;</div><div class="line">        return ((com.houzhi.testproject.IMyAidlInterface) iin);</div><div class="line">    &#125;</div><div class="line">    return new com.houzhi.testproject.IMyAidlInterface.Stub.Proxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码需要说明的是obj的queryLocalInterface会返回null, 因为obj其实是一个BinderProxy类型，而BinderProxy类中，并没有给DESCRIPTOR添加对应的IInterface。在源码中具体的实现在native层，native通过jni的方式利用mObject（相当于对应的对象id,BinderProxy的成员变量）创建了一个BinderProxy。将这个BinderProxy返回给客户端。</p>
<p>从UML图就已经看出Binder是一个非常典型的代理模式，是一种远程代理，实际上Proxy代理的是另外一个进程中的Stub对象。内部是将接口函数标记为对应的ID，然后根据这个ID来标识目前调用的是哪一个函数。由DESCRIPTOR来作为Token分隔不同的接口调用，另外通过Parcel来写入函数参数和接受函数返回值（Stub端对应接受参数和写入结果）。aidl可接受的类型也是普通类型(int,double…),以及Map,List,String,<br>CharSequence,Parcel,和Binder类型。对应的处理也是不一样的，不过终归可以使用基本的方式搞定。</p>
<p>下面是Stub与Proxy关于接口函数实现的具体代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public static abstract class Stub extends android.os.Binder implements com.houzhi.testproject.ITestService &#123;</div><div class="line">        private static final java.lang.String DESCRIPTOR = &quot;com.houzhi.testproject.ITestService&quot;;</div><div class="line">        //省略了部分代码</div><div class="line">        @Override</div><div class="line">        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;</div><div class="line">            switch (code) &#123;</div><div class="line">                case INTERFACE_TRANSACTION: &#123;</div><div class="line">                    reply.writeString(DESCRIPTOR);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                case TRANSACTION_getContent: &#123;</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    java.lang.String _result = this.getContent();</div><div class="line">                    reply.writeNoException();</div><div class="line">                    reply.writeString(_result);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return super.onTransact(code, data, reply, flags);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private static class Proxy implements com.houzhi.testproject.ITestService &#123;</div><div class="line">            private android.os.IBinder mRemote;</div><div class="line"></div><div class="line">            Proxy(android.os.IBinder remote) &#123;</div><div class="line">                mRemote = remote;</div><div class="line">            &#125;</div><div class="line">            //省略了部分代码</div><div class="line">            @Override</div><div class="line">            public java.lang.String getContent() throws android.os.RemoteException &#123;</div><div class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">                java.lang.String _result;</div><div class="line">                try &#123;</div><div class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    mRemote.transact(Stub.TRANSACTION_getContent, _data, _reply, 0);</div><div class="line">                    _reply.readException();</div><div class="line">                    _result = _reply.readString();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    _reply.recycle();</div><div class="line">                    _data.recycle();</div><div class="line">                &#125;</div><div class="line">                return _result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        static final int TRANSACTION_getContent = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Binder底层实现简述"><a href="#Binder底层实现简述" class="headerlink" title="Binder底层实现简述"></a>Binder底层实现简述</h3><p>看完上一节其实就能想到怎么去实现Binder了，将接口调用请求转换成数据流的形式，通过int类型的id标识具体是哪一个函数，用token来划分每一次函数调用请求，按照函数参数顺序和类型一个一个地写入和读取参数。而在底层通过一个进程通信（Pipe，共享内存）把这些消息发到服务端/客户端，这样就可以大致实现了。实际上最底层使用的是Binder驱动，服务端通过IPCThreadState开启一个线程(IPCThreadState::self()-&gt;startThreadPool())，并且将线程放入到线程池中（IPCThreadState::self()-&gt;joinThreadPool()），等待接收来自客户端的请求(talkWithDriver())。而客户端通过BinderProxy(内部保存了本地BpBinder的指针）的transact,最后访问Binder(talkWithDriver())。内部使用访问驱动函数都是ioctl。</p>
<h3 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h3><p>上面大致介绍了服务端，客户端与Binder驱动通信流程。但是大家有没有想过，在客户端需要请求服务端的时候，我怎么知道我究竟想要请求哪一个服务端呢？ServiceManager。ServiceManager是保存了所有的Service的fd(驱动文件号)。通过请求ServiceManager的<code>getService(String name)</code>就可以获取对应的服务。而ServiceManager也是一个服务，它的fd是0,是服务中心管理器。客户端指定name，通过Binder请求ServiceManager，然后得到客户端想要的服务BinderProxy，然后就可以请求服务端了。当然创建服务的时候，首先需要通过ServiceManager.addService将服务添加到ServiceManager中。</p>
<h3 id="Binder连接的几大模块"><a href="#Binder连接的几大模块" class="headerlink" title="Binder连接的几大模块"></a>Binder连接的几大模块</h3><p>Android中应用层常用的几个重要的模块都是由Binder联系起来的，ActivityManagerService，WindowManagerService，InputManagerService。下面是他们之间的关系图：<br><img src="http://xxxzhi.github.io/images/service-connect.png" alt="binder connect"></p>
<p>另外还有很多服务，比如说Wifi，NetworkPolicy，Power等等。他们都是在SystemServiceRegistry中注册的，这个注册本来在ContextImpl中，现在移到了一个单独的类SystemServiceRegistry。</p>
<h2 id="代理模式在Binder中的应用分析"><a href="#代理模式在Binder中的应用分析" class="headerlink" title="代理模式在Binder中的应用分析"></a>代理模式在Binder中的应用分析</h2><p>代理模式在这里使用的基本上是天衣无缝了，我觉得这是代理模式的经典使用。我们在客户端无法直接访问服务端（因为跨进程，地址空间都不一致），通过代理模式，能够让我们在客户端感觉像是直接访问服务端一样。</p>
<hr>
<blockquote>
<p>如果错过了太阳时你流了眼泪，那你也要错过群星了</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/19/android-sourcecode-abstractfactory-ipolicy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/19/android-sourcecode-abstractfactory-ipolicy/" itemprop="url">Android源码中的抽象工厂---IPolicy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-19T00:00:00+08:00">
                2016-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实抽象工厂应用还是很广的，在Android源码中，这个IPolicy就是一个简单的抽象工厂模式，它负责产生跟对应的窗口相关的一系列对象:PhoneWindow,PhoneWindowPolicy,PhoneLayoutInflater,PhoneFallbackEventHandler。下面就分析一下（源码基于5.0.0）。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://xxxzhi.github.io/images/abs-factory.png" alt="此处输入图片的描述"></p>
<p>通过继承抽象工厂，可以产生不同的产品系列。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsFactory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbsProductA <span class="title">createProduct1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbsProdcutB <span class="title">createProduct2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsProductA</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsProductB</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbsProductA</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbsProductB</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interactWithProductA</span><span class="params">(AbsProductA product)</span></span>&#123; <span class="comment">//与ProductA关联</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbsFactory</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcreteFactory instance = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">    <span class="function"><span class="keyword">public</span> ConcreteFactory <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> AbsProductA <span class="title">createProductA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> AbsProdcutB <span class="title">createProductB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    ConcreteFactory instance = ConcreteFactory.</div><div class="line">    AbsProductA product1 = instance.createProductA();</div><div class="line">    AbsProductB product2 = instance.createProductB();</div><div class="line">    product2.interactWithProductA(product1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象工厂就是创建一系列相互关联的对象，这样每一个抽象工厂的具体实现创建的对象都是相互关联的，而且可以是不同的产品系列，相当于从上层就设计好了一套产品规范。这里只是简单介绍了一下抽象工厂。如果想很好的理解可以参考<strong><em>设计模式：可复用面向对象软件的基础</em></strong>关于抽象工厂的介绍。下面介绍IPolicy。</p>
<h2 id="IPolicy"><a href="#IPolicy" class="headerlink" title="IPolicy"></a>IPolicy</h2><p>IPolicy在com.android.internal.policy包下面。它是关于Android窗口，窗口管理，布局加载，以及事件回退Handler这一系列窗口相关产品的抽象工厂。先看IPolicy的UML类图。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="http://xxxzhi.github.io/images/ipolicy.png" alt="此处输入图片的描述"></p>
<p>IPolicy是产生窗口屏幕相关对象的抽象接口，在Android手机源码中，com.android.internal.policy.impl.Policy是它的唯一一个实现，按照源码中的注释所说的，是Policy是IPolicy的一个简单实现，用来生成对象集合。Policy创建一系列的Phone的窗口相关对象:PhoneWindow，PhoneLayoutInflater，PhoneWindowManager，PhoneFallbackEventHandler。从UML图就可以看出，IPolicy算是一个典型的抽象工厂，只不过在源码中只有一个具体的工厂实现。</p>
<p>另外Policy的实现还有一点特殊的地方，它使用static域将他需要创建的对象都预先load出来，也就是说当虚拟机加载Policy类的时候，就会加载它创建的对象的class。</p>
<h3 id="相关对象介绍"><a href="#相关对象介绍" class="headerlink" title="相关对象介绍"></a>相关对象介绍</h3><p>下面分别介绍IPolicy创建的每个对象</p>
<h4 id="PolicyManager"><a href="#PolicyManager" class="headerlink" title="PolicyManager"></a>PolicyManager</h4><p>PolicyManager相当于是这个抽象工厂的客户端，它只有静态方法，他它的静态方法跟IPolicy的接口是相对应的。它内部包含了一个Policy对象，相当于是Policy的一个代理，对应的创建操作都会交给Policy去创建，比如说makeNewWindow方法的实现:</p>
<pre><code>// The static methods to spawn new policy-specific objects
public static Window makeNewWindow(Context context) {
    return sPolicy.makeNewWindow(context);
}
</code></pre><h4 id="Window与PhoneWindow"><a href="#Window与PhoneWindow" class="headerlink" title="Window与PhoneWindow"></a>Window与PhoneWindow</h4><p>Window是Android中的窗口，每个Activity都会对应着一个Window，在Activity的attach方法中，就有Window的创建代码:</p>
<pre><code>final void attach(Context context, ActivityThread aThread,
    Instrumentation instr, IBinder token, int ident,
    Application application, Intent intent, ActivityInfo info,
    CharSequence title, Activity parent, String id,
    NonConfigurationInstances lastNonConfigurationInstances,
    Configuration config, IVoiceInteractor voiceInteractor) {
    attachBaseContext(context);

    mFragments.attachActivity(this, mContainer, null);

    mWindow = PolicyManager.makeNewWindow(this);
    mWindow.setCallback(this);
    mWindow.setOnWindowDismissedCallback(this);
    mWindow.getLayoutInflater().setPrivateFactory(this);
    ...
</code></pre><p>attach方法是将Context,application等赋值给Activity，在Activiy启动的过程会调用。我们弹出的对话框(Dialog)，里面也是有一个Window的。另外与Activity对应的还有启动窗口(Starting Window)。一个Window还可以有子Window。另外Android中还有一些其他的窗口还有输入法窗口，状态栏窗口，壁纸窗口。</p>
<p>窗口有一个专门的窗口管理服务WindowManagerService，在WindowManagerService中与每个Activity对应的为AppWindowToken,而AppWindowToken描述的是一组窗口(一组WindowState)，对应于Activity中Context的各种窗口。</p>
<p>而手机中, Window的具体实现是PhoneWindow。PhoneWindow是对应着Android手机的Window实现。PhoneWindow里面包含了DecorView, DecorView包含了标题栏以及具体View(由setContentView设置)。它们之间的关系如下：</p>
<p><img src="http://xxxzhi.github.io/images/phonewindow.png" alt="phonewindow"></p>
<p>而真正直接关联Window与View的是WindowManager，由Window.setWindowManager设置。每个Window都会对应一个WindowManager。通过WindowManager的addView，updateViewLayout，removeView来添加，更新，移除Window中的View。</p>
<p>通过context.getSystemService(Context.WINDOW_SERVICE)可以获得WindowManager，这个就是Activity的mWindow的WindowManager，而WindowManager的具体实现是WindowManagerImpl，而WindowManagerImpl又会将Window的相关操作(addView, removeView)交给WindowManagerGlobal来实现。WindowManagerGlobal是一个单例模式，里面包含了一个ViewRootImpl列表（ArrayList），一个View列表， 一个WindowManager.LayoutParams列表，三个链表相互对应，表示一个View对应的LayoutParams和ViewRoot。WindowManagerGlobal获取了WindowManagerService的Binder接口IWindowManager。ViewRootImpl通过WindowManagerGlobal的IWindowManager获取WindowSession(Binder的Proxy)，将ViewRootImpl的W（Binder对象）传给WindowManagerService，来与WindowManagerService相互通信。他们之间的UML图如下：</p>
<p><img src="http://xxxzhi.github.io/images/windowmanager.png" alt="windowmanager"></p>
<h4 id="WindowManagerPolicy-PhoneWindowManager"><a href="#WindowManagerPolicy-PhoneWindowManager" class="headerlink" title="WindowManagerPolicy,PhoneWindowManager"></a>WindowManagerPolicy,PhoneWindowManager</h4><p>这个WindowManagerPolicy不同于Window中介绍的WindownManager，Window中介绍的WindowManager是属于Window与View交互的管理，而WindowManagerPolicy则是更多地倾向于对Window屏幕的管理，比如说启动窗口就是由它创建的。也包括一个具体的屏幕管理，比如说获取屏幕显示的大小，屏幕旋转，屏幕设置等等。PhoneWindowManager是WindowManagerPolicy在手机规格下的实现。WindowManagerPolicy还有一个内部静态类WindowManagerPolicy.WindowState，它是由WindowManagerService管理的，从一个窗口开始添加就存在，到窗口移除就删除，是一个窗口的状态接口，可以获得当前窗口所属的进程，包名，当前的Frame</p>
<h4 id="LayoutInflater-PhoneLayoutInflater"><a href="#LayoutInflater-PhoneLayoutInflater" class="headerlink" title="LayoutInflater,PhoneLayoutInflater"></a>LayoutInflater,PhoneLayoutInflater</h4><p>LayoutInflater应该都比较熟悉，它是Android中用于XML布局加载的类，它是一个抽象类，PhoneLayoutInflater是它在Android手机上面的实现。PhoneLayoutInflater中主要是实现了onCreateView方法和cloneInContext方法。</p>
<h4 id="FallbackEventHandler-PhoneFallbackEventHandler"><a href="#FallbackEventHandler-PhoneFallbackEventHandler" class="headerlink" title="FallbackEventHandler,PhoneFallbackEventHandler"></a>FallbackEventHandler,PhoneFallbackEventHandler</h4><p>这个使用来处理按键的接口，按键事件的处理会有三个部分view树、软键盘系统、FallbackEventHandler。FallbackEventHandler是优先级最低的处理部分。只有前面两个都不处理，FallbackEventHandler才会处理，它是针对所有Window的，像声音按键就是在这里最后处理的。</p>
<h2 id="IPolicy抽象工厂的设计分析"><a href="#IPolicy抽象工厂的设计分析" class="headerlink" title="IPolicy抽象工厂的设计分析"></a>IPolicy抽象工厂的设计分析</h2><p>如果只看IPolicy,PolicyManager,Policy的UML,你会发现其实这三个部分也像是一个策略模式的UML图。这部分里面本身也可以说是一种策略，一种创建的策略。但把IPolicy作为抽象工厂理解会更为合适，它负责生成一系列相关产品，却不用管产品的具体实现。</p>
<p>首先说说这四个产品之间的关系，Window是表示窗口，抽象的窗口管理，而WindowManagerPolicy是关于窗口屏幕的管理策略，LayoutInflater是XML解析器，将XML解析为Window中具体元素View，最后FallbackEventHandler是回退事件Handler，事件会作用在窗口上面。这四个产品在不同的产品簇的具体表现会是不一样的，但是他们又有相互之间的关联。用一个统一的创建接口，在使用这些接口的时候会更加方便。</p>
<p>就拿Phone的这四种产品实现来说，Phone的Window，以及WindowManagerPolicy自然是不同的，另外LayoutInflater也会有所不同，比如XML的View可能限制不一样，在PhoneLayoutInflater中会从包名前缀为”android.widget.”,”android.webkit.”,”android.app.”这三个来创建View。另外如果产品簇是TV的话，FallbackEventHandler处理可能是直接回退到上一个台，而Phone的话会是返回上一个操作。</p>
<h3 id="用四个工厂方法实现"><a href="#用四个工厂方法实现" class="headerlink" title="用四个工厂方法实现"></a>用四个工厂方法实现</h3><p>其实四种不同的产品（Window，WindowManagerPolicy，LayoutInflater，是XML解析器，将XML解析为Window中具体元素View，最后FallbackEventHandler），如果用四个工厂方法也肯定是可以的，但是会缺乏将本来应该有相互关联的产品拆分开了，抽象工厂一定程度上提高了它们之间的内聚。</p>
<h3 id="扩展优势分析"><a href="#扩展优势分析" class="headerlink" title="扩展优势分析"></a>扩展优势分析</h3><p>假如除了Phone外，又突然有了一种新的产品簇（比如说TV，智能手表，我暂时并没有调查这两种的实现方式），那么只需要创建一个对应Policy，以及对应的产品系列，然后将PolicyManager的IPolicy指向新产品簇的Policy就好了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/04/14/android-source-code-decorator-contextwrapper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/14/android-source-code-decorator-contextwrapper/" itemprop="url">Android源码装饰模式---ContextWrapper</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-14T00:00:00+08:00">
                2016-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果说Android源码中哪个地方装饰模式应用的最明显的话，那肯定是非ContextWrapper莫属了，ContextWrapper是一个透明的经典的装饰模式。本文将通过装饰器模式分析Context源码结构。本文基于的Android源码是(android 5.0.0)。首先先介绍一下装饰模式。</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>装饰模式动态地给对象添加额外的职责，就添加功能来说，它比子类的方式更加灵活。</p>
<h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="http://xxxzhi.github.io/images/decorator.png" alt="decorator"></p>
<h4 id="简单代码"><a href="#简单代码" class="headerlink" title="简单代码"></a>简单代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//do operate1</span></div><div class="line">        System.out.println(<span class="string">"operate1"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Component mComponent;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComponentDecorator</span><span class="params">(Component component)</span></span>&#123;</div><div class="line">        mComponent = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 添加相关的职责</span></div><div class="line">        System.out.println(<span class="string">"print before"</span>);</div><div class="line">        mComponent.operate1();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentChild</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//do operate1</span></div><div class="line">        System.out.println(<span class="string">"child operate1"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</div><div class="line">    ComponentChild component = <span class="keyword">new</span> ComponentChild();</div><div class="line">    ComponentDecorator decorator = <span class="keyword">new</span> ComponnentDecorator(component);</div><div class="line">    decorator.operate1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上面的代码就简单实现了装饰模式，通过把被装饰的对象作为装饰器的成员变量，当调用装饰器的操作的时候，装饰器还是会调用被装饰对象的操作，但是装饰器可以给对应的操作添加相关功能。装饰器透明的实现就是跟被装饰对象的接口一致，不添加新的接口，但是现在更多的实现方式是半透明的。装饰模式与子类实现方式比，它能够装饰被装饰对象的各种子类，甚至可以装饰装饰器对象（装饰器之间互相装饰），这样比子类化添加功能更加灵活。如果用子类的方式，将会导致非常多的子类。</p>
<h3 id="ContextWrapper"><a href="#ContextWrapper" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h3><p>下面介绍一下Android源码中装饰器的使用:ContextWrapper（装饰器有个别名Wrapper）。先看UML图。</p>
<p><img src="http://xxxzhi.github.io/images/context-decorator.png" alt="此处输入图片的描述"></p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context是一个全局应用环境接口，具体的实现由Android系统完成。它能访问应用资源，并且能够启动Activity，Service，接收broadcast。</p>
<p>它是一个抽象类，里面包含了各种方法的声明，应该将它作为一个接口类来看待。</p>
<h4 id="ContextWrapper-1"><a href="#ContextWrapper-1" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h4><p>这是一个Context的包装器，里面包含了一个mBase，ContextWrapper就是包装了mBase。而</p>
<h4 id="ContextThemeWrapper-Activity-Application-Service-ReceiverRestrictedContext"><a href="#ContextThemeWrapper-Activity-Application-Service-ReceiverRestrictedContext" class="headerlink" title="ContextThemeWrapper, Activity, Application, Service, ReceiverRestrictedContext"></a>ContextThemeWrapper, Activity, Application, Service, ReceiverRestrictedContext</h4><p>ContextThemeWrapper这个是包含主题的装饰器，而Activity是它的子类。Application, Service, ReceiverRestrictedContext都是ContextWrapper的子类。每一个应用都会有一个Application。Android源码中已经有的Application有EmailApplication,LauncherApplication, Browser等等。</p>
<h4 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h4><p>这个是真正实现Context的类，Context是为应用环境类，它包含了跟环境相关的各种操作：getResource(资源管理，包含了getAssets,layout, string,drawable等等)， getPackageManager(包管理器）， getContentResolver(用于获取内容模型，比如访问ContentProvider)， startActivity(启动Activity)， <em>*</em>Service(包含一系列Service相关操作，start,bind,unbind,stop)， registerBroadcast/unregisterBroadcast/sendBroadcast（Broadcast相关）</p>
<p>这里简单介绍一下这几个关键方法的实现方式</p>
<h5 id="getResource"><a href="#getResource" class="headerlink" title="getResource"></a>getResource</h5><p>这是获取资源的接口，得到Resource对象。ContextImpl里面有个mResource成员变量，android里面由mResource去读取资源。mResource由ResourceManager生成。现在很多Android资源动态加载是直接通过下面这种方式实现的。</p>
<pre><code>AssetManager assets = AssetManager.class.newInstance();
try{
    Method method = AssetManager.class.getMethod(&quot;addAssetPath&quot;,String.class);
    method.invoke(assets,dexPath); //dexPath 表示动态dex包路径
}catch(Exception e){
    e.printStackTrace
}
r = new Resources(assets,getResources.getDisplayMetrics(),getResources.getConfiguration());
</code></pre><p>不过assets的addAssetPath是一个隐藏函数，需要通过反射去调用。</p>
<p>其实Android的资源框架大致就是如下过程：</p>
<ul>
<li>根据layout，values，drawable等生成对应的ID，保存在R.id文件下面，而Android自带的资源在com.android.R.id里面。assets不会赋予id。</li>
<li>Android用不同的资源目录后缀来适配不同的语言环境，屏幕大小，比如说drawable-en-w360。Android有一个对应的<a href="http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources" target="_blank" rel="external">表</a>，按照顺序匹配，对于drawable，本着不超过对应手机的参数的最大值来匹配。Android在打包的时候会将根据这些参数建立一个索引。</li>
<li>打包到resources.arsc文件中</li>
</ul>
<p>运行的时候应用读取过程</p>
<ul>
<li>先去掉跟手机环境完全不匹配的资源目录，比如现在是中文环境，则去掉en目录</li>
<li>assets由AssetsManager来访问。其他对应的资源根据MMC表的顺序，按照索引表一个一个的维度来匹配，筛选，直到找到对应的资源。如果没有找到则抛出异常。</li>
</ul>
<p>上述过程如果想要详细了解可参见<a href="http://blog.csdn.net/luoshengyang/article/details/8738877" target="_blank" rel="external">罗升阳的博客</a></p>
<h5 id="getPackageManager"><a href="#getPackageManager" class="headerlink" title="getPackageManager"></a>getPackageManager</h5><p>返回包管理器，包管理器可以管理安装在系统中的应用程序包相关的各种信息。可以添加权限，可以查看对应包名的包信息，指定组件的组件信息，安装应用包等等。Android里面不同的应用程序报名绝对不同相同，包就对应了应用程序。所以从这里去理解PackageManager，他就是管理涉及到包管理（应用级相关的信息处理）的管理器。</p>
<h5 id="getContentResolver"><a href="#getContentResolver" class="headerlink" title="getContentResolver"></a>getContentResolver</h5><p>返回一个ContentResolver，ContentResolver是用于获取Content模型的，像ContentProvider就是通过ContentResolver来访问。</p>
<h5 id="Activity操作"><a href="#Activity操作" class="headerlink" title="Activity操作"></a>Activity操作</h5><p>Context包含了Activity的启动操作，Activity的启动过程简单来说就是经过下面几个步骤：</p>
<ol>
<li>mMainThread.instrumentation.execStartActivity<br>mMainThread是ActivityThread类型，它是管理着应用程序主线程的执行，像调度Activity,Broadcast等，instrumentation是一个Instrumentation类型，他是Android测试框架，在这里是为了监控Activity的活动,里面会有一个ActivityMonitor去监控被调用的Activity，用ActivityMonitor也可以等待一个指定的Activity启动。也可以阻止一个Activity的启动。<br>　　通过这种方式启动Activity主要就是为了监控Activity的启动活动，在测试中将会大有用处。启动完后，也可以检查启动后的返回组件信息。</li>
<li><p>在execStartActivity的函数中，进行完监控后，就是通过ActivityManagerNative来启动指定的Activity。</p>
<p> int result = ActivityManagerNative.getDefault()</p>
<pre><code>.startActivity(whoThread, who.getBasePackageName(), intent,
        intent.resolveTypeIfNeeded(who.getContentResolver()),
        token, target != null ? target.mEmbeddedID : null,
        requestCode, 0, null, options);
</code></pre><p> 看到Native其实就可以想到它是通过一种IPC机制来访问的了，具体是ActivityManagerProxy通过Binder进行IPC。</p>
</li>
<li><p>由Binder机制来访问ActivityManagerService，ActivityManagerService是进行Activity,Service, Broadcast管理的核心服务。</p>
</li>
<li>由ActivityManagerService.startActivity 会经过mStackSupervisor 以及 ActivityStack 进行相关处理</li>
<li>然后经过ApplicationThread, 最后到主线程的Handler(H)启动Activity</li>
</ol>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>Service除了包含startService,stopService,bindService,unbindService。Service最终也是在ActivityManagerService中管理，但是Service不同的，在ActivityManagerService里面管理的是是ActiveServices。但是最终控制Service的流程还是会到达Handler中</p>
<h5 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h5><p>Context中有sendBroadcast, registerReceiver, unregisterReceiver。对应的都会通过ActivityManagerNative调用ActivityManagerService的相关函数。broadcastIntent是处理sendBroadcast的,　ActivityManagerService中也有registerReceiver, unregisterReceiver。ActivityManagerService里面保存有一个Broadcast的ReceiverList，注册的时候将Receiver保存起来，发送广播的时候，根据保存的IntentFilter来找到对应Receiver，另外BroadCastReceiver还有sticky,是注册的时候如果符合已有的sticky广播，则立刻发送给Receiver。</p>
<p>　<br>对于Activity，Service启动流程，可以去参考罗升阳的博客，他的博客是基于早期的Android版本的，其实很多地方还是有很多变化了。所以如果想了解最新的源码，建议参考博客，自己去阅读源码。下面讨论一下Context这部分用装饰模式的优势</p>
<h3 id="ContextWrapper装饰模式的好处"><a href="#ContextWrapper装饰模式的好处" class="headerlink" title="ContextWrapper装饰模式的好处"></a>ContextWrapper装饰模式的好处</h3><p>其实看了Context的源码结构，知道他是使用了装饰模式，但是为什么这个部分使用装饰模式呢？在这里装饰模式能够很好地添加职责，比如遇到Receiver的时候，ReceiverRestrictedContext就能够限制Receiver调用startService，让应用程序的Receiver不能够启动Service。通过实现装饰器，能够提供各种各样的装饰，并且也为Android应用程序组件提供了应用环境。</p>
<h5 id="与继承的方式添加功能比较"><a href="#与继承的方式添加功能比较" class="headerlink" title="与继承的方式添加功能比较"></a>与继承的方式添加功能比较</h5><p>我们似乎可以考虑用继承去实现Context结构，但是如果用继承的方式给Context添加功能，则将Application, ThemeContext,Service等等直接集成自ContextImpl，假如我们需要一种新的Context实现方式，则会变得非常麻烦，新的ContextImpl实现了后，Application又得去继承新的ContextImpl，一方面麻烦，另外一方面导致子类树集成非常庞大。现在用装饰模式，直接将ContextWrapper装饰的对象替换掉就可以了。</p>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>我们的Context是需要不断在外面添加新的职责装饰的，而策略模式是将系统的内部替换掉，假如说我们需要的是多种Context的实现，则可以采用策略模式。Context是Android应用环境，在Android中，Android的应用环境是确定了的，它在对不同的应用程序，Android的应用环境是不会变化的。</p>
<p>不过话说回来，装饰模式可以添加不同的实现，Android里面也有MockContext，但那是用来测试的，这个地方也可以看作是用了策略的思想，但正常运行的时候是主要是侧重于不同的装饰。这其实也是装饰的好处。</p>
<hr>
<blockquote>
<p>纵然伤心，也不要愁眉不展，因为你不知是谁会爱上你的笑容    –泰戈尔《飞鸟集》</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/03/31/http-tcp-keep-alive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/31/http-tcp-keep-alive/" itemprop="url">Http keep-alive 与Tcp keep-alive</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-31T00:00:00+08:00">
                2016-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天面试遇到一个问题：如果让你对一个项目通信协议进行选择的话，你会选择Http还是Tcp(当时问的是套接字，其实套接字还有UDP啦，我好像也没去讲)协议？感觉当时脑子转的不太灵活。而且以为Http keep-alive与Tcp keep-alive是差不多的，所以根本没去讲两者之间的keep-alive。每次面试回答问题都有点着急，所以思考不够。实际上两者是不同的，下面分别介绍一下。</p>
<p>首先Http是建立在Tcp协议的基础上的，Tcp是传输层的协议，Http是应用层协议。Http底层也是通过Tcp传输的。</p>
<h3 id="HTTP-keep-alive"><a href="#HTTP-keep-alive" class="headerlink" title="HTTP keep-alive"></a>HTTP keep-alive</h3><p>Http是一个”请求-响应”协议，它的keep-alive主要是为了让多个http请求共享一个Tcp连接，以避免每个Http又新建一个Tcp连接。每个Http服务器默认的keep-alive时间可能是不一样的。</p>
<h3 id="TCP-keep-alive"><a href="#TCP-keep-alive" class="headerlink" title="TCP keep-alive"></a>TCP keep-alive</h3><p>Tcp的keep-alive是Tcp协议的一种保鲜装置，当Tcp请求响应结束后，经过tcp_keep-alive_time时间后，服务器会发出监测包去看看改Tcp连接是否还是继续连接的，是否已经出现了网络问题，是否客户端崩溃了等等问题。如果发现出现了问题，那么服务端就会去关闭连接，把这个Tcp连接关闭。</p>
<h4 id="关于TCP心跳"><a href="#关于TCP心跳" class="headerlink" title="关于TCP心跳"></a>关于TCP心跳</h4><p>在目前这两年的移动互联网火热的环境下，推送应用的非常多。推送实现的就是通过TCP长连接实现的，因为移动网络很多时候都会不稳定，另外NAT过一段时间就会刷新,所以而要如何保证客户端和服务器端连接就成了一个问题。TCP心跳包就是客户端监测连接的，它先发送一个心跳包到服务器，服务器再Ask，通过这种方式判断是否目前的长连接是否可用，如果断了，则通知上层应用，并关闭连接，另外发送心跳包也是避免一段时间都没有通信，NAT超时，NAT表被刷新，导致连接失效。</p>
<h3 id="HTTP与TCP-keep-alive联系"><a href="#HTTP与TCP-keep-alive联系" class="headerlink" title="HTTP与TCP keep-alive联系"></a>HTTP与TCP keep-alive联系</h3><p>直接介绍一个场景就可能更容易明白了。客户端发送了一个Http请求，服务器响应后，判断这个Http是否是keep-alive的，如果不是则关闭连接。如果是keep-alive，则等待keep-alive time后再关闭，如果这期间再收到一个http 请求，则继续等待最后一个请求的keep-alive time时间，直到keep-alive time时间内没有收到请求，则关闭。</p>
<p>上面是HTTP keep-alive的，而TCP是它下一层的协议，本身TCP是长连接的，除非主动关闭。HTTP的keep-alive time一般是15ms, 30ms之类的，如果是超过了HTTP的keep-alive time时间，则HTTP会关闭TCP连接。本身TCP是不会关闭连接的，TCP的keep alive是TCP的保鲜装置，在keep alive timeout 后服务端发送一个监测包来判断连接是否仍保持着，如果还是可连接，则继续保持，它不会主动关闭连接的。而心跳包是为了防止NAT超时。</p>
<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p>对于问题要多问为什么，要去细细探究，注意细节。了解与理解是不同的，另外也需要在遇到问题的时候，充分利用自己的知识分析问题，心态要好。找个时间看一下HttpUrlConnection跟okHttp的源码。</p>
<hr>
<p>加强表述</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/03/19/java-signature-reflect-jni/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/19/java-signature-reflect-jni/" itemprop="url">Java方法签名与JNI,反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-19T00:00:00+08:00">
                2016-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在这段时间写东西，必须要先吐槽一下找实习的杯具。找个实习不容易，没经验，各种跪。</p>
<p>一直都觉得在Java反射中，那些反射的方法调用都很有规律，每一个调用都需要相同的特性：函数对象（Method），函数参数，类对象。今天坐在电脑前又回忆了JNI的调用方式（C++调用Java），也需要相同的内容：函数ID（jmethodID），参数，类对象（jobject），JNIEnv。仔细一比较，其实两者就是一样的，都是<strong><em>Java方法签名</em></strong>。</p>
<p>记得刚学Java的时候，也有特别将Java方法签名，那时候就基本是记下了，但是根本没想到Java方法签名意味着什么，现在终于是能深切体会一些了。这个签名就表示了Java方法，相当于它的ID，适用于Java整个环境，能够通过指定这些内容，形容一次函数调用。我们平时采用普通方式调用Java函数，其实也就是先描述了函数，参数，类对象。其实在Java层，我觉得可以理解为隐含了一个线程描述（JVM）。在native里面，就有个JNIEnv（线程本地变量）描述一个Java虚拟机环境。至于到了java的.class文件里面也是一样的包含了这些标志。下面是截取了一段Constant poll中的内容，里面指定了类StringBuilder，方法参数String，</p>
<pre><code>#12 = Methodref          #7.#55         //  java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</code></pre><p>下面是.class文件方法段里面的stack代码，</p>
<pre><code>21: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
</code></pre><p>只是感性的认识，如果把全部的.class 文件通过javap -verbose 的内容都贴上来，实在太囧了。对于invokevirtual命令可以参考这里的<a href="http://book.51cto.com/art/200906/131732.htm" target="_blank" rel="external">http://book.51cto.com/art/200906/131732.htm</a>。如果想要了解，需要对虚拟机指令的操作方式有所了解，那个东东跟汇编有点类似。</p>
<p>关于java方法签名，官网上面有介绍<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html" target="_blank" rel="external">java method signatures</a>。Java的方法声明具有下面几个组件：</p>
<ol>
<li>访问标志（public，private…)</li>
<li>返回类型</li>
<li>方法名</li>
<li>参数列表</li>
<li>异常表</li>
<li>方法体</li>
</ol>
<p>但是Java方法中真正被判断是否是同一个方法的签名与上面是不一致的，就像我们熟知的方法重载一样。正如<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.2" target="_blank" rel="external">method signatures</a> 所说，它在内部真正具体标记意义的是方法名称和参数列表，因为这种都是在同一个类里面讲重载的，真正算起来应该还要加上具体的类方法，以及具体JVM线程。所以JNI和反射的调用其实就是指定了函数实际的标记：JVM,类对象,方法ID(Method,jmethodID),参数列表。</p>
<p>所以如果需要对各种方式的Java调用进行完全的认识，就需要熟记Java这几种签名标记的特性。如果在实际编码过程中，想要去调用一个方法，那么一定要获取对应的对象，方法名，方法参数。如果是可能存在不同的虚拟机环境，那还得加上虚拟机环境的标记（类似JNIEnv）。当然C/C++的虚拟机中，由于C/C++中int,Object并没有统一父对象，C/C++ JNI提供了针对不同的返回类型，对应不同的调用函数。</p>
<hr>
<p>好好学习</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/12/14/git-fabric-deploy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/14/git-fabric-deploy/" itemprop="url">利用git hook和fabric来构建自动发布系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-14T00:00:00+08:00">
                2015-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近实验室买了几台机器来做实验，每次都需要通过把代码拷到服务器上面，实在是太麻烦。另外在前一段时间因为想在多台机器上面监控supervisor，了解了一下fabric。所以正好现在使用hook跟fabric来构建一个自动发布系统。</p>
<h3 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h3><p>我是使用gitlab来建立git远程仓库的，之前也用过git跟ssh来构建。但是对于添加用户的时候，实在是太麻烦。gitlab我是通过omnibus的一键安装的。</p>
<ol>
<li>仓库位置。我把gitlab安装在/usr/local/gitlab里面，所以我的git代码仓库在 /usr/local/gitlab/apps/gitlab/repositories/。如果是其他方式安装的，找到repositories就好了。</li>
<li>使用<code>su - git</code>切换到git用户，普通用户无法进入repositories。然后在仓库里面找到自己对应的仓库，git仓库是以.git结尾的文件夹。</li>
<li>在仓库目录下面(.git后缀文件夹）新建一个custom_hooks文件夹。这个是因为gitlab已经占用了hooks。在custom_hooks里面新建post-receive文件，注意权限。为了避免权限问题，可以直接从hooks目录拷贝一个。</li>
<li>在post-receive里面写入命令，就可以在git push后执行。</li>
</ol>
<h3 id="fabric"><a href="#fabric" class="headerlink" title="fabric"></a>fabric</h3><p>fabric是一个python库，可以很方便的与机器进行ssh交互。利用run可以在远程机器上面运行命令。它可以通过<code>sudo pip install fabric</code>安装。<br>具体例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">env.hosts = [</div><div class="line">        <span class="string">'b3432@222.201.145.228'</span>,</div><div class="line">        <span class="string">'b3432@222.201.145.227'</span>]</div><div class="line">env.passwords = &#123;</div><div class="line">    <span class="string">'b3432@222.201.145.228:22'</span>:<span class="string">"***"</span>,  <span class="comment">#指定密码</span></div><div class="line">    <span class="string">'b3432@222.201.145.227:22'</span>:<span class="string">"***"</span>,   <span class="comment">#指定密码</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">experiment</span><span class="params">()</span>:</span></div><div class="line">    run(<span class="string">"cd /home/b3432/Code//experiment/houzhi/ &amp;&amp; git pull origin master"</span>)</div></pre></td></tr></table></figure>
<p>将上面的文件保存为pull.py。然后使用<code>fab -f pull.py experiment</code> 就可以运行了。-f 是指定文件位置。git pull是将代码从git仓库里面pull出来。这个命令是在对应的服务器上面运行的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>git的hook里面填入fab运行命令，就可以了。因为hook是运行在git用户的。而git用户如果没有安装fab可能就用不了fab。所以需要将git加入sudo文件，使用sudo。 <code>sudo fab -f pull.py experiment</code>。 这样就能够在客户端push代码到git服务器后，git服务器自动将代码发布到对应的运行服务器上面了。</p>
<p>另外也有很多已经很完整的持续集成系统，比如Jenkins。我没有使用Jenkins是因为想自己玩玩。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/11/19/compare-otto-with-eventbus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/19/compare-otto-with-eventbus/" itemprop="url">Otto与EventBus框架比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-19T00:00:00+08:00">
                2015-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近这几天经常在空闲时间看到了AOP编程，其实也就是对面向事件过程编程，一开始一直很难理解这个名次。不过看到Android正好有面向事件编程，程序解藕的开源库（Otto，EventBus）。所以闲暇时间就去看了一下这两个库的源码，写篇博客记录一下。其实很多时候，沉下心去做一件事就好了，收获会伴随着的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先从用法上面来说，两个框架的用法本质上其实是差不多的：注册（register），发布事件（post），接收事件（onEvent…)，事件类，取消注册（unregister)。两个框架都包含这几样东西。另外Otto有个不同点是Otto有个Produce，生成事件的函数。它们的事件都包含sticky事件。下面分别介绍两个简单的使用API。</p>
<h4 id="Otto"><a href="#Otto" class="headerlink" title="Otto"></a>Otto</h4><pre><code>public class TestActivity extends Activity{

    public static class TestEvent{
    }

    public void onCreate(Bundle b){
        /*...*/

        final Bus bus = new Bus();
        bus.register(this)
        findViewById(R.id.testpost).setOnClickListener(new View.OnClickListener(){
            public void onClick(View view){
                bus.post(new TestEvent());  //发布事件，消息
            }
        }
    }

    @Subscribe public void onTestEvent(TestEvent event){
        // TODO process the event.响应TestEvent发出的时候，@Subscribe注释标记订阅。
    }

    @Produce public TestEvent produceAnswer(){
        // Produce 表示产生事件
        return new TestEvent();
    }
}
</code></pre><h4 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h4><pre><code>public class TestActivity extends Activity{

    public static class TestEvent{
    }

    public void onCreate(Bundle b){
        /*...*/

        final EventBus bus = EventBus.getDefault();
        bus.register(this);
        findViewById(R.id.testpost).setOnClickListener(new View.OnClickListener(){
            public void onClick(View view){
                bus.post(new TestEvent());  //发布事件，消息
            }
        }
    }

    public void onEvent(TestEvent event){
        // 以onEvent开头就是接受事件，订阅
    }
}
</code></pre><p>上面仅仅是范例性的展示，除了这个简单的使用外，在Android比较关键的就是UI线程跟普通的线程。Otto会将处理的线程跟发送的线程保持一致，你也可以自己设置线程，Bus提供了一个那样的参数。而EventBus则可以自己指定线程，有四种方式，可以在onEvent后面加个后缀。比如:onEventMainThread。</p>
<p>另外一方面，EventBus也是提供了一个默认的单例EventBus（EventBus.getDefault())。我觉得这样能够更加方便地在Activity和Activity，Activity和Fragment解藕。</p>
<h3 id="框架流程"><a href="#框架流程" class="headerlink" title="框架流程"></a>框架流程</h3><p>本身这两个框架都不是很大，其核心代码都在接口类里面（Bus，EventBus）。这里就用流程的方式表示其具体结构。</p>
<p>Otto的框架流程</p>
<p><img src="http://xxxzhi.github.io/images/otto-struct.png" alt="Otto"></p>
<p>EventBus流程</p>
<p><img src="http://xxxzhi.github.io/images/EventBus-struct.png" alt="EventBus"></p>
<p>需要特别指出的是。</p>
<ol>
<li>Otto的订阅者运行的线程跟跟发送的线程是一致的，但是EventBus的会根据用户声明订阅的函数的时候指定的线程来去运行。</li>
<li>Otto只会查找当前类中的订阅者，跟Produce。但是EventBus会查找父类的订阅者。在post的时候，两个框架都会去查找Event的父类型，毕竟Event也是属于它的父类型类型。</li>
<li>两个框架都采用了很多缓存，比如查找订阅者的时候。事件与对应的订阅者也是缓存着的。</li>
</ol>
<h3 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h3><p>如果从源码上来看，两个框架都是比较简单的框架，代码量都比较小。使用起来的话，我觉得EventBus会更加适用一点。但是Otto更加简洁。</p>
<p>这两个框架通过事件驱动来将Activity，Fragment解藕。但是如果在一个Activity内部使用的话，我觉得效果可能不是很好，这个框架目的在于Android组件之间的解藕。</p>
<p>另外两种框架都是使用了一种先解析将订阅者缓存起来，提高查找速度。这个策略在其他的框架中也是使用的非常多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/11/04/talk-about-java-generic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/04/talk-about-java-generic/" itemprop="url">Java泛型Type体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-04T00:00:00+08:00">
                2015-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java泛型是从JDK1.5开始引入的，它与C++的模版非常类似。但是Java的模版完全在编译的时候实现，使用一种擦除的技术在编译的时候就将模版完全替换，由编译器执行类型检查和推断，编译成普通的非泛型字节码。正因为如此，虽然Java泛型是Java类型安全的一大进步，但是使用起来的时候可能会遇到各种非常困扰的问题。</p>
<p><img src="http://xxxzhi.github.io/images/beautiful7.jpg" alt="enter image description here"></p>
<h3 id="Java泛型不协变"><a href="#Java泛型不协变" class="headerlink" title="Java泛型不协变"></a>Java泛型不协变</h3><p>在Java中，因为Number是Integer的父类，所以Integer也是Number，不仅如此，而且Integer[]也Number[]。所以下面这段代码是没有任何问题的：</p>
<pre><code>Number[] nums = new Integer[5];
</code></pre><p>这就是协变，因为Integer是Number，所以Integer[]也是Number[]。Java的数组是支持协变的。但是Java泛型时不支持协变的。所以下面这段代码将会出现编译错误。</p>
<pre><code>List&lt;Number&gt; list = new ArrayList&lt;Integer&gt;(); //compile error
</code></pre><p>如果想要编译通过，这需要将List的申明改成如下</p>
<pre><code>List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();  //ok
</code></pre><p>这是通过<strong><em>通配符引用</em></strong>来解决这个编译不通过的问题，现在上面那段代码的泛型类型就是TypeVariable了。Integer也是符合<code>? extends Number</code>的。</p>
<h4 id="不能实例化泛型数组"><a href="#不能实例化泛型数组" class="headerlink" title="不能实例化泛型数组"></a>不能实例化泛型数组</h4><p>Java泛型的不协变导致的一个问题就是不能实例化泛型数组。因为数组是协变的，但是泛型不协变。这样如果可以实例化泛型数组，那么就会导致问题的出现，看下面这段代码</p>
<pre><code>List&lt;Character&gt;[] listArr = new List&lt;Character&gt;[10]; // illegal, 非法，假设可以通过编译
Object[] oa = listArr;       //数组协变，这句没有问题
oa[0] = new ArrayList&lt;Integer&gt;();    // 看似没问题，但已经出问题了
</code></pre><p>上面最后一句已经是有问题了，oa中每个元素的类型时List<character>，但是现在却将ArrayList<integer>赋值给了它。</integer></character></p>
<p>不能够实例化泛型数组，但是这种通配符类型(List&lt;?&gt;)除外，如：</p>
<pre><code>List&lt;?&gt;[] listArr = new List&lt;?&gt;[10];
</code></pre><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="构造变量"><a href="#构造变量" class="headerlink" title="构造变量"></a>构造变量</h4><p>我们不能直接new 泛型数组，也不能够直接实例化一个泛型类型对象，比如下面这种也是不能够通过编译的：</p>
<pre><code>T t = new T();  //error
</code></pre><p>对于泛型的初始化，可以考虑clone：</p>
<pre><code>static &lt;T extends Cloneable&gt; void create(T t1){
    T t = t1.clone();
}
</code></pre><p>但是必须将clone 的改为public。</p>
<h4 id="构造数组"><a href="#构造数组" class="headerlink" title="构造数组"></a>构造数组</h4><p>对于数组，我们可以通过下面的方式创新新的数组</p>
<pre><code>V[] arr = （V[]） new Object[10]
</code></pre><p>这种方式通过强制转换Object[]为V[]，但是太别扭，并不推荐这种方式。或者通过每次使用V的时候，将Object[]读取的时候进行强制转换。</p>
<p>最好的办法是向构造函数传递类文字（Foo.class），这样，该实现就能在运行时知道 T的值。不采用这种方法的原因在于向后兼容性 —— 新的泛型集合类不能与 Collections 框架以前的版本兼容。</p>
<p>所以在Collections中也有这么一种方式实现构造数组</p>
<pre><code>ArrayList&lt;V&gt; implements List&lt;V&gt; {

    public ArrayList(Class&lt;V&gt; elementType){
        blockArray = (V[])Array.newInstance(elementType,DEFAULT_LENGTH);
    }
}
</code></pre><p>其中Array.newInstance返回的是Object[]，这是为了向下兼容而做的妥协。</p>
<p>擦除也是造成上述构造问题的原因，即不能创建泛型类型的对象，因为编译器不知道要调用什么构造函数。如果泛型类需要构造用泛型类型参数来指定类型的对象，那么构造函数应该接受类文字（Foo.class）并将它们保存起来，以便通过反射创建实例。</p>
<h3 id="Java擦除"><a href="#Java擦除" class="headerlink" title="Java擦除"></a>Java擦除</h3><p>Java的泛型是在编译的时候就被擦除的，因为泛型基本上都是在 Java 编译器中而不是运行库中实现的，所以在生成字节码的时候，差不多所有关于泛型类型的类型信息都被“擦掉”了。换句话说，编译器生成的代码与您手工编写的不用泛型、检查程序的类型安全后进行强制类型转换所得到的代码基本相同。如List<string>与List<integer>这两个类型是一样的，也因为擦出，instanceof在范型是没有任何意义的。</integer></string></p>
<p>另外强制转换也是没什么作用，比如下面这段代码：</p>
<pre><code>public static &lt;T&gt; T nativeCast(Object o){
    return (T)o;
}
</code></pre><p>实际上编译之后T就被擦出了，其实就是直接返回o（是Object类型）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2015/10/30/java-type-reflect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Creative, Challenging and Cogitative">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/30/java-type-reflect/" itemprop="url">Java泛型Type体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-30T00:00:00+08:00">
                2015-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>最近看开源代码，看到里面很多Java泛型，并且通过反射去获取泛型信息。所以这两三天就不在不断地看Java泛型相关的东西。如果说想要明白通过反射去获取泛型信息，那么Type体系是必须要了解的。Java从1.5开始引入泛型，并且也引入了Type体系。首先给出Type的类型树UML图，以便有个整体的认识。</p>
<p><img src="http://xxxzhi.github.io/images/type-interface.png" alt="Type接口"></p>
<p>这些都在java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-tree.html" target="_blank" rel="external">reflect</a>包下面，图中带有s的接口返回的是数组，由于画图工具的原因，标记的只有一个类型，没有带[]。可以说是Java泛型反射的基础。这个UML图我只选取了这些类与接口与Type相关的部分。</p>
<h2 id="Method-Field-Constructor-Class与Type"><a href="#Method-Field-Constructor-Class与Type" class="headerlink" title="Method,Field,Constructor,Class与Type"></a>Method,Field,Constructor,Class与Type</h2><p>Method，Field，Constructor都是与Type关联的，而Class是Type的子类。从实际泛型中看也是这样的，因为方法，域，构造方法都可以是泛型。</p>
<p>如果从来没有接触过这些，那么一开始接触这些泛型的反射会非常突兀。如果从一些疑问，或者说需求开始思考可能会能够更好地了解这些东西的作用，比如说:我们已经知道能够通过反射（从1.1就开始支持了）获得一个Class里面的方法以及域，但是我们怎么获得一个带有模版参数的Class里面的模版参数呢？比如说下面这个类</p>
<pre><code>class Test&lt;T&gt; {
public &lt;R&gt; void testMethod(R params){
}
}
</code></pre><p>我们怎么根据Test.class获得T呢？获得T的具体类型？Class实现了接口GenericDeclaration。GenericDeclaration的getTypeParameters()方法就可以获得模版参数。</p>
<p>同样Method能够包含模版参数的地方有四个，模版参数，返回值，函数参数，异常。Method的四个方法分别对应这四个地方（有一个是继承自GenericDeclaration）。Field，Constructor也都是类似。</p>
<p>Method，Field，Constructor，Class都有获得声明的模版参数的方法，这样我们就可以通过反射来获取模版参数类型。</p>
<h2 id="Type的子接口"><a href="#Type的子接口" class="headerlink" title="Type的子接口"></a>Type的子接口</h2><p>Type有四个子接口：ParameterizedType，TypeVariable，WildcardType，GenericArrayType。下面分别介绍这四个类型的具体表示的意思。假设我们申明有下面这个类</p>
<pre><code>public class GenericTest&lt;T1,T2 extends Number&gt; {
    private Map&lt;T1 , Integer&gt; map = null;
}
</code></pre><p>下面我们开始举例说明。</p>
<h3 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h3><p>ParameterizedType是表示泛型类型，比如说Map<string,integer>,这就是一个ParameterizedType类型。</string,integer></p>
<p>ParameterizedType可以获得具体附带的泛型参数(也就是&lt;&gt;中的内容）。getActualTypeArguments就是获得具体的泛型参数。而getRawType是返回原始类型—申明了泛型参数的那个类，方法（也就是&lt;&gt;左边的那个部分，比如ParameterizedType类型Map<string ,="" integer="">, 那么getRawType返回的就是Map.class）。 而getOwnerType则是返回申明了这个类型的类（在内部类中就会返回父类）。下面是一段简单的测试代码。</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   	public static void testParameterizedType() throws NoSuchFieldException, SecurityException&#123;</div><div class="line"></div><div class="line">	Type mapGenericType = GenericTest.class.getDeclaredField(&quot;map&quot;).getGenericType();  //ParameterizedType</div><div class="line">	if(mapGenericType instanceof ParameterizedType)&#123;</div><div class="line">		Type basicType = ((ParameterizedType) mapGenericType).getRawType();</div><div class="line"></div><div class="line"></div><div class="line">		System.out.println(&quot;basicType equals Map.class is &quot; + (basicType ==Map.class)); //返回True</div><div class="line"></div><div class="line">		System.out.println(&quot;基本类型为：&quot;+basicType);  //Map</div><div class="line">		// 获取泛型类型的泛型参数, 分别为</div><div class="line">		Type[] types = ((ParameterizedType) mapGenericType).getActualTypeArguments();</div><div class="line">		for (int i = 0; i &lt; types.length; i++) &#123;</div><div class="line">			System.out.println(&quot;第&quot;+(i+1)+&quot;个泛型类型是：&quot;+types[i]);</div><div class="line">		&#125;</div><div class="line">		//返回为 T1, class java.lang.Integer</div><div class="line"></div><div class="line">		System.out.println(((ParameterizedType) mapGenericType).getOwnerType());  //null</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TypeVariable"><a href="#TypeVariable" class="headerlink" title="TypeVariable"></a>TypeVariable</h3><p>这个是泛型参数类型，比如Map<t1,integer>, 那么T1就是一个泛型参数，而Integer已经是放入了具体的参数了，所以不是TypeVariable。TypeVariable就是申明的泛型参数。像GenericTest的两个泛型参数T1，T2。可以理解为泛型变量，不是我们具体运行时的类型。</t1,integer></p>
<p>TypeVariable可以获得申明了此泛型参数的类型。通过getGenericDeclaration方法。比如GenericTest<t1,t2>， 两个TypeVariable的getGenericDeclaration都会返回GenericTest.class。<br>同时也可以获得申明的上界，getBounds就可以获得泛型参数的上界列表。下面是一个TypeVariable的例子。</t1,t2></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTypeVariable</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException</span>&#123;</div><div class="line"></div><div class="line">	Type mapGenericType = GenericTest.class.getDeclaredField(<span class="string">"map"</span>).getGenericType();  <span class="comment">//ParameterizedType</span></div><div class="line">	<span class="keyword">if</span>(mapGenericType <span class="keyword">instanceof</span> ParameterizedType)&#123;</div><div class="line">		<span class="comment">// 获取泛型类型的泛型参数, 分别为 T1, class java.lang.Integer</span></div><div class="line">		Type[] types = ((ParameterizedType) mapGenericType).getActualTypeArguments();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span>( types[i] <span class="keyword">instanceof</span> TypeVariable)&#123;</div><div class="line">				<span class="comment">// T1 is TypeVariable, and Integer is not.</span></div><div class="line">				System.out.println(<span class="string">"the "</span>+(i+<span class="number">1</span>)+<span class="string">"th is TypeVariable"</span>);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				System.out.println(<span class="string">"the "</span>+(i+<span class="number">1</span>)+<span class="string">"th is not TypeVariable"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"GenericTest TypeVariable"</span>);</div><div class="line"></div><div class="line">	TypeVariable&lt;Class&lt;GenericTest&gt;&gt;[] typeVariables = GenericTest.class.getTypeParameters();</div><div class="line"></div><div class="line">	<span class="comment">// console print  T1, T2</span></div><div class="line">	<span class="keyword">for</span>(TypeVariable tmp : typeVariables)&#123;</div><div class="line">		System.out.println(<span class="string">""</span>+tmp);</div><div class="line">		Type[] bounds = tmp.getBounds(); <span class="comment">//return upper bounds</span></div><div class="line">		<span class="keyword">if</span>(bounds.length &gt; <span class="number">0</span>)&#123;</div><div class="line">			<span class="comment">//T2 has upper bounds which is class java.lang.Number,</span></div><div class="line">			<span class="comment">//T1's upper bounds is Object which is default.</span></div><div class="line">			System.out.println(<span class="string">"bounds[0] is: "</span>+bounds[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"name is: "</span>+tmp.getName());  <span class="comment">//  T1, T2</span></div><div class="line">		System.out.println(<span class="string">"GenericDeclaration is equals GenericTest.class: "</span>+ (tmp.getGenericDeclaration()==GenericTest.class)); <span class="comment">//GenericTest</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="WildcardType"><a href="#WildcardType" class="headerlink" title="WildcardType"></a>WildcardType</h3><p>WildcardType是通配符类型，也就是<code>? extends Number</code>这种。可以获得上下界。具体使用如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private Map&lt;? extends Number, ? super Integer&gt; map1 = new HashMap&lt;Integer,Integer&gt;();</div><div class="line">public static void testWildcardType() throws NoSuchFieldException, SecurityException&#123;</div><div class="line">	Type mapGenericType = GenericTest.class.getDeclaredField(&quot;map1&quot;).getGenericType();</div><div class="line">	TypeVariable&lt;Class&lt;GenericTest&gt;&gt;[] typeVariables = GenericTest.class.getTypeParameters();</div><div class="line">	Type[] types = ((ParameterizedType) mapGenericType).getActualTypeArguments();</div><div class="line">	for(Type t : types)&#123;</div><div class="line">		if(t instanceof WildcardType)&#123;</div><div class="line">			System.out.println(&quot;wildcardType&quot;);</div><div class="line"></div><div class="line">			if( ((WildcardType) t).getLowerBounds().length &gt; 0 )</div><div class="line">			System.out.println((((WildcardType) t).getLowerBounds())[0]); //print java.lang.Integer</div><div class="line"></div><div class="line">			if( ((WildcardType) t).getUpperBounds().length &gt; 0 )</div><div class="line">				System.out.println((((WildcardType) t).getUpperBounds())[0]); //print java.lang.Number, Object</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="GenericArrayType"><a href="#GenericArrayType" class="headerlink" title="GenericArrayType"></a>GenericArrayType</h3><p>这个是数组泛型。比如<code>T1[] tArray</code>。这是变量的声明。比如下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private T1[] tArray = null;</div><div class="line">public static void testGenericArrayType() throws NoSuchFieldException, SecurityException&#123;</div><div class="line">	Type tArrayGenericType = GenericTest.class.getDeclaredField(&quot;tArray&quot;).getGenericType();</div><div class="line">	if(tArrayGenericType instanceof GenericArrayType)&#123;</div><div class="line">		System.out.println(&quot;is GenericArrayType&quot;);  //</div><div class="line">		Type t1 = ((GenericArrayType) tArrayGenericType).getGenericComponentType();</div><div class="line">		System.out.println(t1);   // print T1</div><div class="line">		if( t1 instanceof TypeVariable)&#123;</div><div class="line">			System.out.println(&quot;t1 is TypeVariable&quot;);</div><div class="line">			System.out.println(((TypeVariable) t1).getGenericDeclaration());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Class也是实现了Type接口。像前面的代码中得到了java.lang.Integer等，就是返回Class。Class也可以通过getGenericInterfaces()获取实现的接口，通过getGenericSuperclass()获取父类的类型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个Type体系主要就是前面介绍的内容了，从Method，Field，Class反射获取Type，然后Type本身又有很多子类型，标明具体的泛型类型。这个是我测试的<a href="https://gist.github.com/xxxzhi/18ed5fc3833dceb678ef" target="_blank" rel="external">代码源码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">houzhi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">houzhi</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
