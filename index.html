<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Thinker">
<meta property="og:url" content="http://houzhi.me/index.html">
<meta property="og:site_name" content="Thinker">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thinker">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://houzhi.me/"/>





  <title>Thinker</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Thinker</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Creative ,Challenging and Cogitative</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/10/17/android-messagequeue-sourcecode-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/17/android-messagequeue-sourcecode-analysis/" itemprop="url">Android MessageQueue源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-17T00:00:00+08:00">
                2016-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android应用开发中离不开Handler，而Handler实际上最终是将Message交给MessageQueue。MessageQueue是Android消息机制的核心，熟悉MessageQueue能够帮助我们更清楚详细地理解Android的消息机制。这篇文章会介绍MessageQueue消息的插入(enqueueMessage)和读取(next)，native层的消息机制，以及IdleHandler和SyncBarrier的逻辑原理。源码是基于6.0。</p>
<h3 id="MessageQueue的next与enqueueMessage方法"><a href="#MessageQueue的next与enqueueMessage方法" class="headerlink" title="MessageQueue的next与enqueueMessage方法"></a>MessageQueue的next与enqueueMessage方法</h3><h4 id="MessageQueue-enqueueMessage"><a href="#MessageQueue-enqueueMessage" class="headerlink" title="MessageQueue enqueueMessage"></a>MessageQueue enqueueMessage</h4><p>每次使用Handler发送一个Message的时候，最终会先调用MessageQueue的enqueueMessage方法将Message方法放入到MessageQueue里面。先看Handler的sendMessage方法，其他发送Message的内容也是一样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessage(Message msg)</div><div class="line">&#123;</div><div class="line">   return sendMessageDelayed(msg, 0); // 调用下面这个方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">&#123;</div><div class="line">   if (delayMillis &lt; 0) &#123;</div><div class="line">       delayMillis = 0;</div><div class="line">   &#125;</div><div class="line">   return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); // 调用下面方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">   MessageQueue queue = mQueue; //Handler中的mQueue</div><div class="line">   if (queue == null) &#123;</div><div class="line">       RuntimeException e = new RuntimeException(</div><div class="line">               this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">       Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">       return false;</div><div class="line">   &#125;</div><div class="line">   return enqueueMessage(queue, msg, uptimeMillis); // 下面方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">   msg.target = this;</div><div class="line">   if (mAsynchronous) &#123;</div><div class="line">       msg.setAsynchronous(true);</div><div class="line">   &#125;</div><div class="line">   return queue.enqueueMessage(msg, uptimeMillis); //调用MessageQueue的enqueueMessage</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后会调用Handler的mQueue的enqueueMessage方法，而Handler的mQueue是从哪里来的呢？在Handler的构造函数中设置的，看默认的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Handler() &#123;</div><div class="line">   this(null, false);</div><div class="line">&#125;</div><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">   if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">       final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">       if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">               (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">           Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">               klass.getCanonicalName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   mLooper = Looper.myLooper();</div><div class="line">   if (mLooper == null) &#123;</div><div class="line">       throw new RuntimeException(</div><div class="line">           &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">   &#125;</div><div class="line">   mQueue = mLooper.mQueue;</div><div class="line">   mCallback = callback;</div><div class="line">   mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无参Handler构造函数对应的是当前调用无参Handler构造函数线程的Looper，Looper是一个ThreadLocal变量，也就是说但是每个线程独有的，每个线程调用了Looper.prepare方法后，就会给当前线程设置一个Looper:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void prepare() &#123;</div><div class="line">   prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">   if (sThreadLocal.get() != null) &#123;</div><div class="line">       throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">   &#125;</div><div class="line">   sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper里面包含了一个MessageQueue,  在Handler的构造函数中，会将当前关联的Looper的MessageQueue赋值给Handler的成员变量mQueue，enqueueMessage的时候就是调用该mQueue的enqueueMessage。关于Handler与Looper可以理解为每个Handler会关联一个Looper，每个线程最多只有一个Looper。Looper创建的时候会创建一个MessageQueue，而发送消息的时候，Handler就会通过调用mQueue.enqueueMessage方法将Message放入它关联的Looper的MessageQueue里面。介绍了Handler与Looper，然后继续看看MessageQueue的enqueueMessage方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">   if (msg.target == null) &#123;</div><div class="line">       throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">   &#125;</div><div class="line">   if (msg.isInUse()) &#123;</div><div class="line">       throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   synchronized (this) &#123;</div><div class="line">       if (mQuitting) &#123;</div><div class="line">           IllegalStateException e = new IllegalStateException(</div><div class="line">                   msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">           Log.w(TAG, e.getMessage(), e);</div><div class="line">           msg.recycle();</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       msg.markInUse();</div><div class="line">       msg.when = when;</div><div class="line">       Message p = mMessages;</div><div class="line">       boolean needWake;</div><div class="line">       if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">           // New head, wake up the event queue if blocked.</div><div class="line">           msg.next = p;</div><div class="line">           mMessages = msg;</div><div class="line">           needWake = mBlocked;</div><div class="line">       &#125; else &#123;</div><div class="line">           // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">           // up the event queue unless there is a barrier at the head of the queue</div><div class="line">           // and the message is the earliest asynchronous message in the queue.</div><div class="line">           needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">           Message prev;</div><div class="line">           for (;;) &#123;</div><div class="line">               prev = p;</div><div class="line">               p = p.next;</div><div class="line">               if (p == null || when &lt; p.when) &#123;</div><div class="line">                   break;</div><div class="line">               &#125;</div><div class="line">               if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                   needWake = false;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           msg.next = p; // invariant: p == prev.next</div><div class="line">           prev.next = msg;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">       if (needWake) &#123;</div><div class="line">           nativeWake(mPtr);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个enqueueMessage方法的过程就是先持有MessageQueue.this锁，然后将Message放入队列中，放入队列的过程是：</p>
<ol>
<li>如果队列为空，或者当前处理的时间点为0（when的数值，when表示Message将要执行的时间点），或者当前Message需要处理的时间点先于队列中的首节点，那么就将Message放入队列首部，否则进行第2步。</li>
<li>遍历队列中Message，找到when比当前Message的when大的Message，将Message插入到该Message之前，如果没找到则将Message插入到队列最后。</li>
<li>判断是否需要唤醒，一般是当前队列为空的情况下，next那边会进入睡眠，需要enqueue这边唤醒next函数。后面会详细介绍</li>
</ol>
<p>执行完后，会释放持有的MessageQueue.this的锁。这样整个enqueueMessage方法算是完了，然后看看读取Message的MessageQueue的next方法。</p>
<h4 id="MessageQueue的next方法"><a href="#MessageQueue的next方法" class="headerlink" title="MessageQueue的next方法"></a>MessageQueue的next方法</h4><p>MessageQueue的next方法是从哪里调用的呢？先看一个线程对Looper的标准用法是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class LoopThread extends Thread&#123;</div><div class="line">public Handler mHandler;</div><div class="line">    public void run()&#123;</div><div class="line">        Looper.prepare();</div><div class="line">        mHandler = new Handler() &#123;</div><div class="line">              public void handleMessage(Message msg) &#123;</div><div class="line">                  // process incoming messages here</div><div class="line">              &#125;</div><div class="line">          &#125;;        </div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prepare方法我们前面已经看过了，就是初始化ThreadLocal变量Looper。loop()方法就是循环读取MessageQueue中Message，然后处理每一个Message。我们看看Looper.loop方法源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">   final Looper me = myLooper();</div><div class="line">   if (me == null) &#123;</div><div class="line">       throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">   &#125;</div><div class="line">   final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">   // Make sure the identity of this thread is that of the local process,</div><div class="line">   // and keep track of what that identity token actually is.</div><div class="line">   Binder.clearCallingIdentity();</div><div class="line">   final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">   for (;;) &#123;</div><div class="line">       Message msg = queue.next(); // might block 此处就是next方法调用的地方</div><div class="line">       if (msg == null) &#123;</div><div class="line">           // No message indicates that the message queue is quitting.</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // This must be in a local variable, in case a UI event sets the logger</div><div class="line">       Printer logging = me.mLogging;</div><div class="line">       if (logging != null) &#123;</div><div class="line">           logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                   msg.callback + &quot;: &quot; + msg.what);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">       if (logging != null) &#123;</div><div class="line">           logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Make sure that during the course of dispatching the</div><div class="line">       // identity of the thread wasn&apos;t corrupted.</div><div class="line">       final long newIdent = Binder.clearCallingIdentity();</div><div class="line">       if (ident != newIdent) &#123;</div><div class="line">           Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                   + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                   + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                   + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                   + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       msg.recycleUnchecked();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个loop函数大概的过程就是先调用MessageQueue.next方法获取一个Message，然后调用Message的target的dispatchMessage方法来处理Message，Message的target就是发送这个Message的Handler。处理的过程是先看Message的callback有没有实现，如果有，则使用调用callback的run方法，如果没有则看Handler的callback是否为空，如果非空，则使用handler的callback的handleMessage方法来处理Message，如果为空，则调用Handler的handleMessage方法处理。</p>
<p>我们主要看next，从注释来看，next方法可能会阻塞，先看next方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Message next() &#123;</div><div class="line">   // Return here if the message loop has already quit and been disposed.</div><div class="line">   // This can happen if the application tries to restart a looper after quit</div><div class="line">   // which is not supported.</div><div class="line">   final long ptr = mPtr;  //mPrt是native层的MessageQueue的指针</div><div class="line">   if (ptr == 0) &#123;</div><div class="line">       return null;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">   int nextPollTimeoutMillis = 0;</div><div class="line">   for (;;) &#123;</div><div class="line">       if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">           Binder.flushPendingCommands();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       nativePollOnce(ptr, nextPollTimeoutMillis); // jni函数</div><div class="line"></div><div class="line">       synchronized (this) &#123;</div><div class="line">           // Try to retrieve the next message.  Return if found.</div><div class="line">           final long now = SystemClock.uptimeMillis();</div><div class="line">           Message prevMsg = null;</div><div class="line">           Message msg = mMessages;</div><div class="line">           if (msg != null &amp;&amp; msg.target == null) &#123; //target 正常情况下都不会为null，在postBarrier会出现target为null的Message</div><div class="line">               // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">               do &#123;</div><div class="line">                   prevMsg = msg;</div><div class="line">                   msg = msg.next;</div><div class="line">               &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">           &#125;</div><div class="line">           if (msg != null) &#123;</div><div class="line">               if (now &lt; msg.when) &#123;</div><div class="line">                   // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class="line">                   nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">               &#125; else &#123;</div><div class="line">                   // Got a message.</div><div class="line">                   mBlocked = false;</div><div class="line">                   if (prevMsg != null) &#123;</div><div class="line">                       prevMsg.next = msg.next;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       mMessages = msg.next;</div><div class="line">                   &#125;</div><div class="line">                   msg.next = null;</div><div class="line">                   if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                   msg.markInUse();</div><div class="line">                   return msg;</div><div class="line">               &#125;</div><div class="line">           &#125; else &#123;</div><div class="line">               // No more messages.</div><div class="line">               nextPollTimeoutMillis = -1; // 等待时间无限长</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // Process the quit message now that all pending messages have been handled.</div><div class="line">           if (mQuitting) &#123;</div><div class="line">               dispose();</div><div class="line">               return null;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // If first time idle, then get the number of idlers to run.</div><div class="line">           // Idle handles only run if the queue is empty or if the first message</div><div class="line">           // in the queue (possibly a barrier) is due to be handled in the future.</div><div class="line">           if (pendingIdleHandlerCount &lt; 0</div><div class="line">                   &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">               pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">           &#125;</div><div class="line">           if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">               // No idle handlers to run.  Loop and wait some more.</div><div class="line">               mBlocked = true;</div><div class="line">               continue;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           if (mPendingIdleHandlers == null) &#123;</div><div class="line">               mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class="line">           &#125;</div><div class="line">           mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Run the idle handlers.</div><div class="line">       // We only ever reach this code block during the first iteration.</div><div class="line">       for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; //运行idle</div><div class="line">           final IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">           mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class="line"></div><div class="line">           boolean keep = false;</div><div class="line">           try &#123;</div><div class="line">               keep = idler.queueIdle();</div><div class="line">           &#125; catch (Throwable t) &#123;</div><div class="line">               Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           if (!keep) &#123;</div><div class="line">               synchronized (this) &#123;</div><div class="line">                   mIdleHandlers.remove(idler);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Reset the idle handler count to 0 so we do not run them again.</div><div class="line">       pendingIdleHandlerCount = 0;</div><div class="line"></div><div class="line">       // While calling an idle handler, a new message could have been delivered</div><div class="line">       // so go back and look again for a pending message without waiting.</div><div class="line">       nextPollTimeoutMillis = 0;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个next函数的主要是执行步骤是:</p>
<ul>
<li>step1: 初始化操作，如果mPtr为null，则直接返回null，设置nextPollTimeoutMillis为0，进入下一步。</li>
<li>step2: 调用nativePollOnce, nativePollOnce有两个参数,第一个为mPtr表示native层MessageQueue的指针，nextPollTimeoutMillis表示超时返回时间，调用这个nativePollOnce会等待wake，如果超过nextPollTimeoutMillis时间，则不管有没有被唤醒都会返回。-1表示一直等待，0表示立刻返回。下一小节单独介绍这个函数。</li>
<li>step3: 获取队列的头Message(msg)，如果头Message的target为null，则查找一个异步Message来进行下一步处理。当队列中添加了同步Barrier的时候target会为null。</li>
<li>step4: 判断上一步获取的msg是否为null，为null说明当前队列中没有msg，设置等待时间nextPollTimeoutMillis为-1。实际上是等待enqueueMessage的nativeWake来唤醒，执行step4。如果非null，则下一步</li>
<li>step5: 判断msg的执行时间(when)是否比当前时间(now)的大，如果小，则将msg从队列中移除，并且返回msg，结束。如果大则设置等待时间nextPollTimeoutMillis为(int) Math.min(msg.when - now, Integer.MAX_VALUE)，执行时间与当前时间的差与MAX_VALUE的较小值。执行下一步</li>
<li>step6: 判断是否MessageQueue是否已经取消，如果取消的话则返回null，否则下一步</li>
<li>step7: 运行idle Handle，idle表示当前有空闲时间的时候执行，而运行到这一步的时候，表示消息队列处理已经是出于空闲时间了（队列中没有Message，或者头部Message的执行时间(when)在当前时间之后）。如果没有idle，则继续step2，如果有则执行idleHandler的queueIdle方法，我们可以自己添加IdleHandler到MessageQueue里面（addIdleHandler方法），执行完后，回到step2。</li>
</ul>
<p>需要说的时候，我们平常只是使用Message，但是实际上IdleHandler如果使用的好，应该会达到意想不到的效果，它表示MessageQueue有空闲时间的时候执行一下。然后介绍一下nativePollOnce与nativeWake方法</p>
<h3 id="native层机制"><a href="#native层机制" class="headerlink" title="native层机制"></a>native层机制</h3><p>nativePollOnce与nativeWake是两个jni方法，这两个方法jni实现方法在frameworks/base/core/jni/android_os_MessageQueue.cpp。这个是MessageQueue的native层内容。native层的NativeMessageQueue初始化是在nativeInit方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</div><div class="line">   NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();</div><div class="line">   if (!nativeMessageQueue) &#123;</div><div class="line">       jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);</div><div class="line">       return 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   nativeMessageQueue-&gt;incStrong(env);</div><div class="line">   return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的java层方法是nativeInit，在MessageQueue构造函数的时候调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MessageQueue(boolean quitAllowed) &#123;</div><div class="line">   mQuitAllowed = quitAllowed;</div><div class="line">   mPtr = nativeInit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而NativeMessageQueue的构造函数是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NativeMessageQueue::NativeMessageQueue() :</div><div class="line">       mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</div><div class="line">   mLooper = Looper::getForThread();</div><div class="line">   if (mLooper == NULL) &#123;</div><div class="line">       mLooper = new Looper(false);</div><div class="line">       Looper::setForThread(mLooper);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了一个native层的Looper。Looper的源码在system/core/libutils/Looper.cpp。Looper通过epoll_create创建了一个mEpollFd作为epoll的fd，并且创建了一个mWakeEventFd，用来监听java层的wake，同时可以通过Looper的addFd方法来添加新的fd监听。</p>
<h4 id="nativePollOnce"><a href="#nativePollOnce" class="headerlink" title="nativePollOnce"></a>nativePollOnce</h4><p>nativePollOnce是每次调用next方法获取消息的时候调用的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</div><div class="line">       jlong ptr, jint timeoutMillis) &#123;</div><div class="line">   NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">   nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123;</div><div class="line">   mPollEnv = env;</div><div class="line">   mPollObj = pollObj;</div><div class="line">   mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">   mPollObj = NULL;</div><div class="line">   mPollEnv = NULL;</div><div class="line"></div><div class="line">   if (mExceptionObj) &#123;</div><div class="line">       env-&gt;Throw(mExceptionObj);</div><div class="line">       env-&gt;DeleteLocalRef(mExceptionObj);</div><div class="line">       mExceptionObj = NULL;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的native层方法最终会调用Looper的pollOnce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class="line">   int result = 0;</div><div class="line">   for (;;) &#123;</div><div class="line">       while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class="line">           const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class="line">           int ident = response.request.ident;</div><div class="line">           if (ident &gt;= 0) &#123;</div><div class="line">               int fd = response.request.fd;</div><div class="line">               int events = response.events;</div><div class="line">               void* data = response.request.data;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">               ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class="line">                       &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class="line">                       this, ident, fd, events, data);</div><div class="line">#endif</div><div class="line">               if (outFd != NULL) *outFd = fd;</div><div class="line">               if (outEvents != NULL) *outEvents = events;</div><div class="line">               if (outData != NULL) *outData = data;</div><div class="line">               return ident;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (result != 0) &#123;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">           ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class="line">#endif</div><div class="line">           if (outFd != NULL) *outFd = 0;</div><div class="line">           if (outEvents != NULL) *outEvents = 0;</div><div class="line">           if (outData != NULL) *outData = NULL;</div><div class="line">           return result;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       result = pollInner(timeoutMillis);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int Looper::pollInner(int timeoutMillis) &#123;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">   ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);</div><div class="line">#endif</div><div class="line"></div><div class="line">   // Adjust the timeout based on when the next message is due.</div><div class="line">   if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</div><div class="line">       nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">       int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</div><div class="line">       if (messageTimeoutMillis &gt;= 0</div><div class="line">               &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123;</div><div class="line">           timeoutMillis = messageTimeoutMillis;</div><div class="line">       &#125;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">       ALOGD(&quot;%p ~ pollOnce - next message in %&quot; PRId64 &quot;ns, adjusted timeout: timeoutMillis=%d&quot;,</div><div class="line">               this, mNextMessageUptime - now, timeoutMillis);</div><div class="line">#endif</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Poll.</div><div class="line">   int result = POLL_WAKE;</div><div class="line">   mResponses.clear();</div><div class="line">   mResponseIndex = 0;</div><div class="line"></div><div class="line">   // We are about to idle.</div><div class="line">   mPolling = true;</div><div class="line"></div><div class="line">   struct epoll_event eventItems[EPOLL_MAX_EVENTS];</div><div class="line">   int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class="line"></div><div class="line">   // No longer idling.</div><div class="line">   mPolling = false;</div><div class="line"></div><div class="line">   // Acquire lock.</div><div class="line">   mLock.lock();</div><div class="line"></div><div class="line">   // Rebuild epoll set if needed.</div><div class="line">   if (mEpollRebuildRequired) &#123;</div><div class="line">       mEpollRebuildRequired = false;</div><div class="line">       rebuildEpollLocked();</div><div class="line">       goto Done;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Check for poll error.</div><div class="line">   if (eventCount &lt; 0) &#123;</div><div class="line">       if (errno == EINTR) &#123;</div><div class="line">           goto Done;</div><div class="line">       &#125;</div><div class="line">       ALOGW(&quot;Poll failed with an unexpected error, errno=%d&quot;, errno);</div><div class="line">       result = POLL_ERROR;</div><div class="line">       goto Done;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Check for poll timeout.</div><div class="line">   if (eventCount == 0) &#123;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">       ALOGD(&quot;%p ~ pollOnce - timeout&quot;, this);</div><div class="line">#endif</div><div class="line">       result = POLL_TIMEOUT;</div><div class="line">       goto Done;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Handle all events.</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">   ALOGD(&quot;%p ~ pollOnce - handling events from %d fds&quot;, this, eventCount);</div><div class="line">#endif</div><div class="line"></div><div class="line">   for (int i = 0; i &lt; eventCount; i++) &#123;</div><div class="line">       int fd = eventItems[i].data.fd;</div><div class="line">       uint32_t epollEvents = eventItems[i].events;</div><div class="line">       if (fd == mWakeEventFd) &#123;</div><div class="line">           if (epollEvents &amp; EPOLLIN) &#123;</div><div class="line">               awoken();</div><div class="line">           &#125; else &#123;</div><div class="line">               ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents);</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           ssize_t requestIndex = mRequests.indexOfKey(fd);</div><div class="line">           if (requestIndex &gt;= 0) &#123;</div><div class="line">               int events = 0;</div><div class="line">               if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</div><div class="line">               if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</div><div class="line">               if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</div><div class="line">               if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</div><div class="line">               pushResponse(events, mRequests.valueAt(requestIndex));</div><div class="line">           &#125; else &#123;</div><div class="line">               ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</div><div class="line">                       &quot;no longer registered.&quot;, epollEvents, fd);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">Done: ;</div><div class="line"></div><div class="line">   // Invoke pending message callbacks.</div><div class="line">   mNextMessageUptime = LLONG_MAX;</div><div class="line">   while (mMessageEnvelopes.size() != 0) &#123;</div><div class="line">       nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">       const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);</div><div class="line">       if (messageEnvelope.uptime &lt;= now) &#123;</div><div class="line">           // Remove the envelope from the list.</div><div class="line">           // We keep a strong reference to the handler until the call to handleMessage</div><div class="line">           // finishes.  Then we drop it so that the handler can be deleted *before*</div><div class="line">           // we reacquire our lock.</div><div class="line">           &#123; // obtain handler</div><div class="line">               sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</div><div class="line">               Message message = messageEnvelope.message;</div><div class="line">               mMessageEnvelopes.removeAt(0);</div><div class="line">               mSendingMessage = true;</div><div class="line">               mLock.unlock();</div><div class="line"></div><div class="line">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</div><div class="line">               ALOGD(&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;,</div><div class="line">                       this, handler.get(), message.what);</div><div class="line">#endif</div><div class="line">               handler-&gt;handleMessage(message);</div><div class="line">           &#125; // release handler</div><div class="line"></div><div class="line">           mLock.lock();</div><div class="line">           mSendingMessage = false;</div><div class="line">           result = POLL_CALLBACK;</div><div class="line">       &#125; else &#123;</div><div class="line">           // The last message left at the head of the queue determines the next wakeup time.</div><div class="line">           mNextMessageUptime = messageEnvelope.uptime;</div><div class="line">           break;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Release lock.</div><div class="line">   mLock.unlock();</div><div class="line"></div><div class="line">   // Invoke all response callbacks.</div><div class="line">   for (size_t i = 0; i &lt; mResponses.size(); i++) &#123;</div><div class="line">       Response&amp; response = mResponses.editItemAt(i);</div><div class="line">       if (response.request.ident == POLL_CALLBACK) &#123;</div><div class="line">           int fd = response.request.fd;</div><div class="line">           int events = response.events;</div><div class="line">           void* data = response.request.data;</div><div class="line">#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</div><div class="line">           ALOGD(&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;,</div><div class="line">                   this, response.request.callback.get(), fd, events, data);</div><div class="line">#endif</div><div class="line">           // Invoke the callback.  Note that the file descriptor may be closed by</div><div class="line">           // the callback (and potentially even reused) before the function returns so</div><div class="line">           // we need to be a little careful when removing the file descriptor afterwards.</div><div class="line">           int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</div><div class="line">           if (callbackResult == 0) &#123;</div><div class="line">               removeFd(fd, response.request.seq);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // Clear the callback reference in the response structure promptly because we</div><div class="line">           // will not clear the response vector itself until the next poll.</div><div class="line">           response.request.callback.clear();</div><div class="line">           result = POLL_CALLBACK;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法超长，但实际上Looper的pollOnce方法主要有5步：</p>
<ol>
<li>调用epoll_wait方法等待所监听的fd的写入，其方法原型如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>调用的方法参数为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div></pre></td></tr></table></figure></p>
<p>eventItems里面就包含了mWakeEvent和通过addFd添加fd时加入的Event。该方法会阻塞，当timeoutMillis(对应java层的nextPollTimeoutMillis)到了时间，该方法会返回，或者eventItems有事件来了，该方法会返回。返回之后就是干下一件事</p>
<ol>
<li>判断有没有event，因为可能是timeoutMillis到了返回的，如果没有直接进行4.</li>
<li>读取eventItems的内容，如果eventItem的fd是mWakeEventFd，则调用awoken方法，读取Looper.wake写入的内容，如果是其他的fd，则使用pushResponse来读取，并且将内容放入Response当中。</li>
<li>处理NativeMessageQueue的消息，这些消息是native层的消息</li>
<li>处理pushResponse写入的内容。</li>
</ol>
<p>里面主要是干了三件事处理wakeEventFd的输入内容，其他fd的输入内容，以及NativeMessageQueue里面的Message。 </p>
<h4 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake"></a>nativeWake</h4><p>实际上最后就是调用了Looper的wake方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//android_os_MessageQueue.cpp</div><div class="line">static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123;</div><div class="line">   NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">   nativeMessageQueue-&gt;wake();</div><div class="line">&#125;</div><div class="line">void NativeMessageQueue::wake() &#123;</div><div class="line">   mLooper-&gt;wake();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Looper.cpp</div><div class="line">void Looper::wake() &#123;</div><div class="line">#if DEBUG_POLL_AND_WAKE</div><div class="line">   ALOGD(&quot;%p ~ wake&quot;, this);</div><div class="line">#endif</div><div class="line"></div><div class="line">   uint64_t inc = 1;</div><div class="line">   ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));</div><div class="line">   if (nWrite != sizeof(uint64_t)) &#123;</div><div class="line">       if (errno != EAGAIN) &#123;</div><div class="line">           ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样native层的消息队列就算是完了。</p>
<h3 id="SyncBarrier"><a href="#SyncBarrier" class="headerlink" title="SyncBarrier"></a>SyncBarrier</h3><p>我们在next方法里面看到有这么一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (msg != null &amp;&amp; msg.target == null) &#123; //target 正常情况下都不会为null，在postBarrier会出现target为null的Message</div><div class="line">               // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">               do &#123;</div><div class="line">                   prevMsg = msg;</div><div class="line">                   msg = msg.next;</div><div class="line">               &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>什么时候msg.target会为null呢？有sync barrier消息的时候，实际上msg.target为null表示sync barrier(同步消息屏障)。MessageQueue有一个postSyncBarrier方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public int postSyncBarrier() &#123;</div><div class="line">   return postSyncBarrier(SystemClock.uptimeMillis());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private int postSyncBarrier(long when) &#123;</div><div class="line">   // Enqueue a new sync barrier token.</div><div class="line">   // We don&apos;t need to wake the queue because the purpose of a barrier is to stall it.</div><div class="line">   synchronized (this) &#123;</div><div class="line">       final int token = mNextBarrierToken++;</div><div class="line">       final Message msg = Message.obtain();</div><div class="line">       msg.markInUse();</div><div class="line">       msg.when = when;</div><div class="line">       msg.arg1 = token;</div><div class="line"></div><div class="line">       Message prev = null;</div><div class="line">       Message p = mMessages;</div><div class="line">       if (when != 0) &#123;</div><div class="line">           while (p != null &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">               prev = p;</div><div class="line">               p = p.next;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       if (prev != null) &#123; // invariant: p == prev.next</div><div class="line">           msg.next = p;</div><div class="line">           prev.next = msg;</div><div class="line">       &#125; else &#123;</div><div class="line">           msg.next = p;</div><div class="line">           mMessages = msg;</div><div class="line">       &#125;</div><div class="line">       return token;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应有removeSyncBarrier方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public void removeSyncBarrier(int token) &#123;</div><div class="line">   // Remove a sync barrier token from the queue.</div><div class="line">   // If the queue is no longer stalled by a barrier then wake it.</div><div class="line">   synchronized (this) &#123;</div><div class="line">       Message prev = null;</div><div class="line">       Message p = mMessages;</div><div class="line">       while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123;</div><div class="line">           prev = p;</div><div class="line">           p = p.next;</div><div class="line">       &#125;</div><div class="line">       if (p == null) &#123;</div><div class="line">           throw new IllegalStateException(&quot;The specified message queue synchronization &quot;</div><div class="line">                   + &quot; barrier token has not been posted or has already been removed.&quot;);</div><div class="line">       &#125;</div><div class="line">       final boolean needWake;</div><div class="line">       if (prev != null) &#123;</div><div class="line">           prev.next = p.next;</div><div class="line">           needWake = false;</div><div class="line">       &#125; else &#123;</div><div class="line">           mMessages = p.next;</div><div class="line">           needWake = mMessages == null || mMessages.target != null;</div><div class="line">       &#125;</div><div class="line">       p.recycleUnchecked();</div><div class="line"></div><div class="line">       // If the loop is quitting then it is already awake.</div><div class="line">       // We can assume mPtr != 0 when mQuitting is false.</div><div class="line">       if (needWake &amp;&amp; !mQuitting) &#123;</div><div class="line">           nativeWake(mPtr);  // 需要唤醒，因为队首元素是SyncBarrier，队列中有消息但是没有异步消息的时候，next方法同样会阻塞等待。</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看next方法的源码，每次消息队列中有barrier的时候，next会寻找队列中的异步消息来处理。如果没有异步消息，设置nextPollTimeoutMillis = -1，进入阻塞等待新消息的到来。异步消息主要是系统发送的，而系统中的异步消息主要有触摸事件，按键事件的消息。系统中调用postSyncBarrier和removeSyncBarrier主要实在ViewRootImpl的scheduleTraversals和unscheduleTraversals，以及doTraversals方法中。从源码可以猜到每次调用postSyncBarrier后都会调用removeSyncBarrier，不然同步消息就没法执行了（看next源码理解这一点）。可以看一下scheduleTraversal方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//ViewRootImpl.java</div><div class="line">void scheduleTraversals() &#123;</div><div class="line">   if (!mTraversalScheduled) &#123;</div><div class="line">       mTraversalScheduled = true;</div><div class="line">       mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</div><div class="line">       mChoreographer.postCallback(</div><div class="line">               Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</div><div class="line">       if (!mUnbufferedInputDispatch) &#123;</div><div class="line">           scheduleConsumeBatchedInput();</div><div class="line">       &#125;</div><div class="line">       notifyRendererOfFramePending();</div><div class="line">       pokeDrawLockIfNeeded();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上MessageQueue的源码一直在变化的，2.3才加入了native层的Message，在4.0.1还没有SyncBarrier，4.1才开始加入SyncBarrier的，而且MessageQueue没有postSyncBarrier方法，只有enqueueSyncBarrier方法，Looper里面有个postSyncBarrier方法。</p>
<h4 id="SyncBarrier的意义"><a href="#SyncBarrier的意义" class="headerlink" title="SyncBarrier的意义"></a>SyncBarrier的意义</h4><p>前面介绍了一下每个版本的特点，我想介绍一种SyncBarrier的意义，我们介绍了使用SyncBarrier主要是ViewRootImpl中的scheduleTraversal的时候，那是跟UI事件相关的，像派发消息会通过发送Message发到主线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver) &#123;</div><div class="line">   SomeArgs args = SomeArgs.obtain();</div><div class="line">   args.arg1 = event;</div><div class="line">   args.arg2 = receiver;</div><div class="line">   Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args);</div><div class="line">   msg.setAsynchronous(true);</div><div class="line">   mHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意它这里就是使用的异步Message，使用了<code>msg.setAsyncronous(true)</code>。 而SyncBarrier有什么用处呢？我们刚刚介绍的时候，当消息队列的第一个Message的target的时候，表示它是一个SyncBarrier，它会阻拦同步消息，而选择队列中第一个异步消息处理，如果没有则会阻塞。这表示什么呢？这是表示第一个Message是SyncBarrier的时候，会只处理异步消息。而我们前面介绍了InputEvent的时候，它就是异步消息，在有SyncBarrier的时候就会被优先处理。所以在调用了scheduleTraversal的时候，就会只处理触摸事件这些消息了，保证用户体验。保证了触摸事件及时处理，实际上这也能减少ANR。如果这个时候MessageQueue中有很多Message，也能够及时处理那些触摸事件的Message了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MessageQueue是Android消息消息机制的内部核心，理解好MessageQueue更能理解好Android应用层的消息逻辑。另外MessageQueue的代码一直在不断地变化，对照不同版本的代码，真的能领略代码改变时的目的，从演变中学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/10/05/hugo-sourcecode-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/05/hugo-sourcecode-analysis/" itemprop="url">Hugo源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-05T00:00:00+08:00">
                2016-10-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">Hugo</a>是JakeWharton大神开发的一个通过注解触发的Debug日志库。它是一个非常好的AOP框架，在Debug模式下，Hugo利用aspectj库来进行切面编程，插入日志代码。通过分析Hugo的代码能够对gradle以及aspectj有一个非常好的了解。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>通过使用来看Hugo具体的功能，这样也能够更好的明白Hugo的实现方式。</p>
<p>首先把下面的编译配置文件添加到项目当中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">  repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dependencies &#123;</div><div class="line">    classpath &apos;com.jakewharton.hugo:hugo-plugin:1.2.1&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line">apply plugin: &apos;com.jakewharton.hugo&apos;</div></pre></td></tr></table></figure>
<p>使用的时候直接使用@DebugLog注解给想要调试的方法就好了，它会打印函数的参数，执行时间，以及返回值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@DebugLog</div><div class="line">public String getName(String first, String last) &#123;</div><div class="line">  SystemClock.sleep(15); // Don&apos;t ever really do this!</div><div class="line">  return first + &quot; &quot; + last;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">V/Example: ⇢ getName(first=&quot;Jake&quot;, last=&quot;Wharton&quot;)</div><div class="line">V/Example: ⇠ getName [16ms] = &quot;Jake Wharton&quot;</div></pre></td></tr></table></figure>
<p>需要指出的，Hugo只会在Debug模式下打印log。DebugLog的源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package hugo.weaving;</div><div class="line"></div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.Target;</div><div class="line">import static java.lang.annotation.ElementType.CONSTRUCTOR;</div><div class="line">import static java.lang.annotation.ElementType.METHOD;</div><div class="line">import static java.lang.annotation.ElementType.TYPE;</div><div class="line">import static java.lang.annotation.RetentionPolicy.CLASS;</div><div class="line"></div><div class="line">@Target(&#123;TYPE, METHOD, CONSTRUCTOR&#125;) @Retention(CLASS)</div><div class="line"></div><div class="line">public @interface DebugLog &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是注解，Target也包含了TYPE，DebugLog也可以添加到类上面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@DebugLog</div><div class="line"></div><div class="line">static class Greeter &#123;</div><div class="line"></div><div class="line">  private final String name;</div><div class="line"></div><div class="line">  Greeter(String name) &#123;</div><div class="line"></div><div class="line">    this.name = name;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  private String sayHello() &#123;</div><div class="line"></div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>AspectJ是一个面向切面的框架，它有一个专门的编译器用来生成遵守Java字节编码规范的class文件。在<a href="http://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="external">这里</a>下载安装，实际上它有自己的语法。看个简单的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 我们有一个TestService类，TestService.java</div><div class="line"></div><div class="line">public class TestService&#123;</div><div class="line"></div><div class="line">    public void test()&#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;test&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[]args)&#123;</div><div class="line"></div><div class="line">            new TestService().test();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们想要给test()方法增加一些东西，比如打印test方法进入的时间。如果用aspectj则可以增加一个文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public aspect LogAspect &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        pointcut logPointcut():execution(void TestService.test());</div><div class="line"></div><div class="line">        void around():logPointcut()&#123;</div><div class="line"></div><div class="line">                System.out.println(&quot;start time: &quot; + System.currentTimeMillis());</div><div class="line"></div><div class="line">                proceed();</div><div class="line"></div><div class="line">                System.out.println(&quot;end time: &quot; + System.currentTimeMillis());</div><div class="line"></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>通过执行命令 ajc -d . TestService.java LogAspect.java生成TestService.class，然后执行命令java TestService，输出为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">start time: 1478071231659</div><div class="line"></div><div class="line">test</div><div class="line"></div><div class="line">end time: 1478071231659</div></pre></td></tr></table></figure>
<p>实际上将ajc理解为类似于javac的编译工具就好了，它编译的目标跟javac一样的都是java class文件，只是源文件的语法是符合aspect语法的。可以看看TestService.class反编译后的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">org.aspectj.runtime.internal.AroundClosureTestService &#123;</div><div class="line">    TestService() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    test() &#123;</div><div class="line">        test_aroundBody1$advice(LogAspect.aspectOf()(AroundClosure))&#125;</div><div class="line"></div><div class="line">    main(String[] args) &#123;</div><div class="line">        (TestService()).test()&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将aspect理解编译时期对源文件按照指定的描述（aspect语法文件）进行编译，得到进行切入后的字节码文件。详细的介绍可以参看这篇文章<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="external">spring aop</a>。</p>
<p>我们看看Hugo项目中是如何使用aspect，实际的aspect部分代码是在hugo-runtime子模块当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package hugo.weaving.internal;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import android.os.Build;</div><div class="line"></div><div class="line">import android.os.Looper;</div><div class="line"></div><div class="line">import android.os.Trace;</div><div class="line"></div><div class="line">import android.util.Log;</div><div class="line"></div><div class="line">import org.aspectj.lang.JoinPoint;</div><div class="line">import org.aspectj.lang.ProceedingJoinPoint;</div><div class="line">import org.aspectj.lang.Signature;</div><div class="line">import org.aspectj.lang.annotation.Around;</div><div class="line"></div><div class="line">import org.aspectj.lang.annotation.Aspect;</div><div class="line"></div><div class="line">import org.aspectj.lang.annotation.Pointcut;</div><div class="line"></div><div class="line">import org.aspectj.lang.reflect.CodeSignature;</div><div class="line"></div><div class="line">import org.aspectj.lang.reflect.MethodSignature;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@Aspect</div><div class="line"></div><div class="line">public class Hugo &#123;</div><div class="line"></div><div class="line">  private static volatile boolean enabled = true;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Pointcut(&quot;within(@hugo.weaving.DebugLog *)&quot;)</div><div class="line">  public void withinAnnotatedClass() &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Pointcut(&quot;execution(!synthetic * *(..)) &amp;&amp; withinAnnotatedClass()&quot;)</div><div class="line">  public void methodInsideAnnotatedType() &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Pointcut(&quot;execution(!synthetic *.new(..)) &amp;&amp; withinAnnotatedClass()&quot;)</div><div class="line">  public void constructorInsideAnnotatedType() &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Pointcut(&quot;execution(@hugo.weaving.DebugLog * *(..)) || methodInsideAnnotatedType()&quot;)</div><div class="line">  public void method() &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Pointcut(&quot;execution(@hugo.weaving.DebugLog *.new(..)) || constructorInsideAnnotatedType()&quot;)</div><div class="line">  public void constructor() &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  public static void setEnabled(boolean enabled) &#123;</div><div class="line"></div><div class="line">    Hugo.enabled = enabled;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  @Around(&quot;method() || constructor()&quot;)</div><div class="line"></div><div class="line">  public Object logAndExecute(ProceedingJoinPoint joinPoint) throws Throwable &#123;</div><div class="line"></div><div class="line">    enterMethod(joinPoint);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    long startNanos = System.nanoTime();</div><div class="line"></div><div class="line">    Object result = joinPoint.proceed();</div><div class="line"></div><div class="line">    long stopNanos = System.nanoTime();</div><div class="line"></div><div class="line">    long lengthMillis = TimeUnit.NANOSECONDS.toMillis(stopNanos - startNanos);</div><div class="line"></div><div class="line">    exitMethod(joinPoint, result, lengthMillis);</div><div class="line"></div><div class="line">    return result;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  private static void enterMethod(JoinPoint joinPoint) &#123;</div><div class="line"></div><div class="line">    if (!enabled) return;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">     // ...</div><div class="line"></div><div class="line">    //组织相关信息到builder当中</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    if (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line"></div><div class="line">      builder.append(&quot; [Thread:\&quot;&quot;).append(Thread.currentThread().getName()).append(&quot;\&quot;]&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    Log.v(asTag(cls), builder.toString());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</div><div class="line"></div><div class="line">      final String section = builder.toString().substring(2);</div><div class="line"></div><div class="line">      Trace.beginSection(section);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  private static void exitMethod(JoinPoint joinPoint, Object result, long lengthMillis) &#123;</div><div class="line"></div><div class="line">    if (!enabled) return;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</div><div class="line"></div><div class="line">      Trace.endSection();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // ...</div><div class="line"></div><div class="line">    //组织相关信息为builder</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    Log.v(asTag(cls), builder.toString());</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private static String asTag(Class&lt;?&gt; cls) &#123;</div><div class="line"></div><div class="line">    if (cls.isAnonymousClass()) &#123;</div><div class="line"></div><div class="line">      return asTag(cls.getEnclosingClass());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return cls.getSimpleName();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面只是给出的代码去除了相关详细内容，具体代码可以直接看源码<a href="https://github.com/JakeWharton/hugo/blob/master/hugo-runtime/src/main/java/hugo/weaving/internal/Hugo.java" target="_blank" rel="external">Hugo.java</a>。</p>
<p>上面是使用了<strong><em>aspect注解</em></strong>来描述相关插入代码的:</p>
<p>@Aspect 表示这个类由AspectJ处理</p>
<p>@Pointcut 描述切面内容，可以理解为针对哪些方法，类，进行拦截，插入代码。</p>
<p>@Around 实际上拦截方法，这个注解可以同时拦截方法的执行前后，另外有@Before, @After，顾名思义，表示方法执行前跟方法执行后拦截。</p>
<p>关于aspectj，邓凡平的这篇文章<a href="http://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="external">深入理解Android之AOP</a>介绍的挺详细的。aspectj编译器会根据这些描述信息对项目中的源码进行插入。另外还有cglib能够有类似的功能，CGlib是在运行期对类进行动态代理（Proxy.newProxyInstance只能对接口进行动态代理），具体可以Google一下。</p>
<h3 id="gradle代码"><a href="#gradle代码" class="headerlink" title="gradle代码"></a>gradle代码</h3><p>Hugo源码中除了aspect的使用，我觉得另外就是项目的编译控制了，因为Hugo只会在Debug模式下打印日志，而控制只在Debug模式下打印日志是在编译脚本中实现的。Hugo源码中目录树主要是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">|- hugo-plugin</div><div class="line"></div><div class="line">|- hugo-runtime</div><div class="line"></div><div class="line">|- hugo-annotations</div><div class="line"></div><div class="line">|- hugo-example</div></pre></td></tr></table></figure>
<p>我们使用过程的方式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">  repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dependencies &#123;</div><div class="line">    classpath &apos;com.jakewharton.hugo:hugo-plugin:1.2.1&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line">apply plugin: &apos;com.jakewharton.hugo&apos;</div></pre></td></tr></table></figure>
<h4 id="Gradle-实现Debug插入代码"><a href="#Gradle-实现Debug插入代码" class="headerlink" title="Gradle 实现Debug插入代码"></a>Gradle 实现Debug插入代码</h4><p>所以先看com.jakewharton.hugo插件，这个插件的实现是在hugo-plugin当中，hugo-plugin模块的hugo-plugin/src/main/resources/META-INF/gradle-plugins/目录下面有com.jakewharton.hugo.properties，这就表示插件的声明。该文件的内容是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">implementation-class=hugo.weaving.plugin.HugoPlugin</div></pre></td></tr></table></figure>
<p>指定了插件实现的代码。然后看hugo.weaving.plugin.HugoPlugin的内容(对应hugo-plugin/src/main/groovy/hugo/weaving/plugin/HugoPlugin.groovy文件)，这是groovy源文件，groovy也是一种编程语言，跟Java差不多。关于gradle插件声明使用可以参看gradle源码目录下面的samples/customPlugin项目(比如~/.gradle/wrapper/dists/gradle-2.10-all/a4w5fzrkeut1ox71xslb49gst/gradle-2.10/samples)。HugoPlugin.groovy的文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class HugoPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line"></div><div class="line">  @Override void apply(Project project) &#123;</div><div class="line"></div><div class="line">    def hasApp = project.plugins.withType(AppPlugin)</div><div class="line"></div><div class="line">    def hasLib = project.plugins.withType(LibraryPlugin)</div><div class="line"></div><div class="line">    if (!hasApp &amp;&amp; !hasLib) &#123;</div><div class="line"></div><div class="line">      throw new IllegalStateException(&quot;&apos;android&apos; or &apos;android-library&apos; plugin required.&quot;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    final def log = project.logger</div><div class="line"></div><div class="line">    final def variants // variants是构造变种版本，为同一个应用创建不同的版本。</div><div class="line"></div><div class="line">    if (hasApp) &#123;</div><div class="line"></div><div class="line">      variants = project.android.applicationVariants</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">      variants = project.android.libraryVariants</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    project.dependencies &#123; // 声明的项目依赖</div><div class="line"></div><div class="line">      debugCompile &apos;com.jakewharton.hugo:hugo-runtime:1.2.2-SNAPSHOT&apos;</div><div class="line"></div><div class="line">      // TODO this should come transitively</div><div class="line"></div><div class="line">      debugCompile &apos;org.aspectj:aspectjrt:1.8.6&apos;</div><div class="line"></div><div class="line">      compile &apos;com.jakewharton.hugo:hugo-annotations:1.2.2-SNAPSHOT&apos;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    project.extensions.create(&apos;hugo&apos;, HugoExtension)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    variants.all &#123; variant -&gt;</div><div class="line"></div><div class="line">      if (!variant.buildType.isDebuggable()) &#123; // 非Debug情况下，直接返回</div><div class="line"></div><div class="line">        log.debug(&quot;Skipping non-debuggable build type &apos;$&#123;variant.buildType.name&#125;&apos;.&quot;)</div><div class="line"></div><div class="line">        return;</div><div class="line"></div><div class="line">      &#125; else if (!project.hugo.enabled) &#123; //关闭Hugo</div><div class="line"></div><div class="line">        log.debug(&quot;Hugo is not disabled.&quot;)</div><div class="line"></div><div class="line">        return;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 使用Hugo的情况下，调用aspect编译，args指定了aspect相关参数。</div><div class="line"></div><div class="line">      JavaCompile javaCompile = variant.javaCompile</div><div class="line"></div><div class="line">      javaCompile.doLast &#123;</div><div class="line"></div><div class="line">        String[] args = [</div><div class="line"></div><div class="line">            &quot;-showWeaveInfo&quot;,</div><div class="line"></div><div class="line">            &quot;-1.5&quot;,</div><div class="line"></div><div class="line">            &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</div><div class="line"></div><div class="line">            &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</div><div class="line"></div><div class="line">            &quot;-d&quot;, javaCompile.destinationDir.toString(),</div><div class="line"></div><div class="line">            &quot;-classpath&quot;, javaCompile.classpath.asPath,</div><div class="line"></div><div class="line">            &quot;-bootclasspath&quot;, project.android.bootClasspath.join(File.pathSeparator)</div><div class="line"></div><div class="line">        ]</div><div class="line"></div><div class="line">        log.debug &quot;ajc args: &quot; + Arrays.toString(args)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        MessageHandler handler = new MessageHandler(true);</div><div class="line"></div><div class="line">        new Main().run(args, handler);// 运行aspect</div><div class="line"></div><div class="line">        // ... 省略了log运行结果的代码</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个HogoPlugin.groovy指定了编译的时候区分Debug和release版本编译。非Debug并且没有disable Hugo的时候，使用aspect给应用中的代码插入。aspect会找到有@Aspect注解的类，然后解析这个类，处理代码。这样整个过程就完了。</p>
<h4 id="Gradle与maven"><a href="#Gradle与maven" class="headerlink" title="Gradle与maven"></a>Gradle与maven</h4><p>在hugo目录下面有个build.gradle，先看一下dependencies:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">buildscript &#123;</div><div class="line"></div><div class="line">  repositories &#123;</div><div class="line"></div><div class="line">    mavenCentral()</div><div class="line"></div><div class="line">    jcenter()</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  dependencies &#123;</div><div class="line"></div><div class="line">    classpath &apos;org.gradle.api.plugins:gradle-nexus-plugin:0.7&apos;</div><div class="line"></div><div class="line">    classpath &apos;com.android.tools.build:gradle:1.3.1&apos;</div><div class="line"></div><div class="line">    classpath &apos;org.aspectj:aspectjtools:1.8.6&apos;</div><div class="line"></div><div class="line">    classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.3&apos;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mavenCentral()和jcenter是指定了repositories，也就是远程仓库，gradle编译的时候，可以从这些仓库里面获取引用库的包。</p>
<ul>
<li><p>org.aspectj:aspectjtools : 是aspectj的库</p>
</li>
<li><p>com.github.dcendents:android-maven-gradle-plugin: 修改自maven插件，是一个让maven与android库(arr)相兼容的库。</p>
</li>
<li><p>gradle-nexus-plugin: 是配置和上传组件的gradle插件</p>
</li>
</ul>
<p>build.gradle里面定义了几个Task，我们看一下cleanExample的定义来简单了解一下Task:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">task cleanExample(type: Exec) &#123;</div><div class="line"></div><div class="line">  executable = &apos;../gradlew&apos;</div><div class="line"></div><div class="line">  workingDir = project.file(&apos;hugo-example&apos;)</div><div class="line"></div><div class="line">  args = [ &apos;clean&apos; ]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Task cleanExample 是清理example项目的task，上述代码使用gradlew脚本，将工作目录设置为hugo-example目录下面，设置gradle的参数为clean，这样就清理hugo-example项目了。</p>
<p>这里只是简单介绍一下gradle，如果不了解gradle，建议先看看gradle的介绍文档，比如<a href="https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html" target="_blank" rel="external">Gradle for Android中文</a>，另外就是邓凡平的<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="external">深入理解Android（一）：Gradle详解</a>。</p>
<p>我觉得对于gradle，正确的理解方式是它是基于groovy脚本的一种构建框架，它提供了Android编译的框架及其API。另外groovy种充满了闭包，理解好闭包的概念，然后查看API，这样入手和理解Gradle会很容易明白。</p>
<h3 id="Hugo-改进"><a href="#Hugo-改进" class="headerlink" title="Hugo 改进"></a>Hugo 改进</h3><p>因为Hugo当中DebugLog使用的Retention是CLASS类型，所以打包之后，注解还是会存在，这样release的apk包就会增加一些大小。就拿Hugo的example来说，如果DebugLog的Retention是CLASS，release包大概是3476bytes，如果DebugLog的retention是Source的时候，release包是3444bytes。还是能够减少一点包大小的。目前我还没有完全地弄好这个问题，不过如果是导入library的方式使用Hugo的话，可以这样来弄:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">debugCompile &apos;com.jakewharton.hugo:hugo-annotations:1.2.2-SNAPSHOT&apos;</div><div class="line">releaseCompile &apos;com.jakewharton.hugo:hugo-annotations-release:1.2.2-SNAPSHOT&apos;</div></pre></td></tr></table></figure>
<p>hugo-annotations-release里面使用SOURCE retention的DebugLog。这样就能够在debug版本使用CLASS retention的DebugLog，而release版本使用SOURCE retention的DebugLog。不过这种配置只能适合debug和release打包时。如果有更好地idea，我在hugo上面提了个issues：<a href="https://github.com/JakeWharton/hugo/issues/146" target="_blank" rel="external">support release build type use DebugLog with SOURCE Retention</a> ，直接评论。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Hugo是一个比较小的项目，但是里面却包含了优秀的思想以及先进的技术。AOP编程，注解的理解，Gradle编译的理解，Aspect的使用，以及gradle-maven在Hugo项目中都用到了，看一下Hugo的源码是学习这些东西的一个非常好的方式。</p>
<p>参考:</p>
<ol>
<li><p><a href="http://www.jianshu.com/p/fe8d1e8bd63e" target="_blank" rel="external">Spring AOP,AspectJ, CGLIB 有点晕:http://www.jianshu.com/p/fe8d1e8bd63e</a></p>
</li>
<li><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="external">Spring AOP 实现原理与 CGLIB 应用:https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/</a></p>
</li>
<li><p><a href="http://blog.csdn.net/innost/article/details/49387395" target="_blank" rel="external">深入理解Android之AOP:http://blog.csdn.net/innost/article/details/49387395</a></p>
</li>
<li><p><a href="https://yq.aliyun.com/articles/7104" target="_blank" rel="external">Hugo 探究:https://yq.aliyun.com/articles/7104</a></p>
</li>
<li><p><a href="https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html" target="_blank" rel="external">Gradle for Android中文:https://avatarqing.gitbooks.io/gradlepluginuserguidechineseverision/content/introduction/README.html</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="external">深入理解Android（一）：Gradle详解:http://www.infoq.com/cn/articles/android-in-depth-gradle</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/08/13/android-appwidget-sourcecode2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/13/android-appwidget-sourcecode2/" itemprop="url">AppWidget源码分析（2）---updateAppWidget过程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-13T00:00:00+08:00">
                2016-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面一篇文章，分析了AppWidgetProvider和RemoteView的源码，从中我们可以知道它们的实现原理，AppWidgetProvider是一个BroadcastReceiver，所以它是通过广播接收通知的，收到更新通知后，AppWidgetProvider需要去提供View供远程进程显示，而提供的View则是使用RemoteView来代替，通过RemoteView（是一个Parcelable，可跨进程传输数据类型）来作为媒介去传递给远程进程。由远程进程解析RemoteView，然后显示RemoteView表示的真正的View。在这篇文章将分析这个传输过程。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>还是先看一下上一篇给出的一个过程图示：</p>
<p><img src="http://img.blog.csdn.net/20160813013648728" alt="这里写图片描述"></p>
<p>实际上，AppWidgetProvider是通过AppWidgetManager来更新View的，而AppWidgetManager里面是有一个IAppWidgetService，一看就知道这是一个idle生成的，是一个Binder通信。关于Binder通信我之前也写过一篇文章叫<a href="http://blog.houzhi.me/2016/04/23/android-sourcecode-proxy-binder" target="_blank" rel="external">Android源码代理模式—Binder</a>，可以参考一下。而服务端的AppWidgetService是AppWidgetServiceImpl，AppWidgetServiceImpl又会通过一个IAppWidgetHost来跨进程通知AppWidgetHost，AppWidgetHost内部的IAppWidgetHost是AppWidgetHost.Callback。这样就到了显示我们的AppWidget的进程（大部分是Launcher应用）。</p>
<p>分清楚每个部分是在什么进程运行的对于理解整个流程是非常有帮助的，AppWidgetProvider是在我们自己的应用程序进程当中，而AppWidgetService是运行在SystemServer进程，AppWidgetHost则是运行在显示AppWidget的进程中，比如Launcher应用（桌面）。整个流程相当于是跨越了三个进程。</p>
<h2 id="updateAppWidgetIds过程分析"><a href="#updateAppWidgetIds过程分析" class="headerlink" title="updateAppWidgetIds过程分析"></a>updateAppWidgetIds过程分析</h2><p>这是AppWidgetManager的一个接口函数，根据id来更新AppWidget。先把整个更新过程的时序图拿出来看一下：</p>
<p><img src="http://img.blog.csdn.net/20160813013708416" alt="这里写图片描述"></p>
<p>从我们普通的调用AppWidgetManager的updateAppWidget看起吧：</p>
<pre><code>appWidgetManager.updateAppWidget(appwidgetids,remoteViews);
</code></pre><ol>
<li>这里进入updateAppWidget方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void updateAppWidget(int[] appWidgetIds, RemoteViews views) &#123;</div><div class="line">   if (mService == null) &#123;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line">   try &#123;</div><div class="line">       mService.updateAppWidgetIds(mPackageName, appWidgetIds, views);</div><div class="line">   &#125;</div><div class="line">   catch (RemoteException e) &#123;</div><div class="line">       throw new RuntimeException(&quot;system server dead?&quot;, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mService是一个IAppWidgetService类型，初始化是在SystemServiceRegistry（6.0才出现的，之前在ContextImpl里面）里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">registerService(Context.APPWIDGET_SERVICE, AppWidgetManager.class,</div><div class="line">       new CachedServiceFetcher&lt;AppWidgetManager&gt;() &#123;</div><div class="line">   @Override</div><div class="line">   public AppWidgetManager createService(ContextImpl ctx) &#123;</div><div class="line">       IBinder b = ServiceManager.getService(Context.APPWIDGET_SERVICE);</div><div class="line">       return new AppWidgetManager(ctx, IAppWidgetService.Stub.asInterface(b));</div><div class="line">   &#125;&#125;);</div></pre></td></tr></table></figure>
<p>注册服务的时候获取APPWIDGET_SERVICE。所以mService.updateAppWidgetIds最后会调用到远程进程，而IAppWidgetService的实现者是AppWidgetServiceImpl，所以最终会调用AppWidgetServiceImpl的updateAppWidgetIds。</p>
<ol>
<li>AppWidgetServiceImpl中的updateAppWidgetIds:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">public void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,</div><div class="line">       RemoteViews views) &#123;</div><div class="line">   if (DEBUG) &#123;</div><div class="line">       Slog.i(TAG, &quot;updateAppWidgetIds() &quot; + UserHandle.getCallingUserId());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   updateAppWidgetIds(callingPackage, appWidgetIds, views, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是AppWidgetServiceImpl的updateAppWidgetIds方法。程序已经开始进入到AppWidgetServiceImpl所在的进程了，实际上是SystemServer进程。怎么看出AppWidgetServiceImpl是运行在SystemServer进程呢？AppWidgetService类new了一个AppWidgetServiceImpl，并且注册到ServiceManager中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class AppWidgetService extends SystemService &#123;</div><div class="line">   private final AppWidgetServiceImpl mImpl;</div><div class="line"></div><div class="line">   public AppWidgetService(Context context) &#123;</div><div class="line">       super(context);</div><div class="line">       mImpl = new AppWidgetServiceImpl(context);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onStart() &#123;</div><div class="line">       publishBinderService(Context.APPWIDGET_SERVICE, mImpl); //注册mImpl到ServiceManager当中</div><div class="line">       AppWidgetBackupBridge.register(mImpl);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void onBootPhase(int phase) &#123;</div><div class="line">       if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</div><div class="line">           mImpl.setSafeMode(isSafeMode());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而AppWidgetService在SystemServer.java中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final String APPWIDGET_SERVICE_CLASS =</div><div class="line">       &quot;com.android.server.appwidget.AppWidgetService&quot;;</div></pre></td></tr></table></figure>
<p>SystemServer是通过反射的方式new一个AppWidgetService对象，然后调用它的start函数。很多service类都是这样启动的。</p>
<p>回到updateAppWidgetIds方法，最后它会调用四个参数的updateAppWidgetIds方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds,</div><div class="line">       RemoteViews views, boolean partially) &#123;</div><div class="line">   final int userId = UserHandle.getCallingUserId();</div><div class="line"></div><div class="line">   if (appWidgetIds == null || appWidgetIds.length == 0) &#123;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Make sure the package runs under the caller uid.</div><div class="line">   mSecurityPolicy.enforceCallFromPackage(callingPackage);</div><div class="line"></div><div class="line">   final int bitmapMemoryUsage = (views != null) ? views.estimateMemoryUsage() : 0;</div><div class="line">   if (bitmapMemoryUsage &gt; mMaxWidgetBitmapMemory) &#123;</div><div class="line">       throw new IllegalArgumentException(&quot;RemoteViews for widget update exceeds&quot;</div><div class="line">               + &quot; maximum bitmap memory usage (used: &quot; + bitmapMemoryUsage</div><div class="line">               + &quot;, max: &quot; + mMaxWidgetBitmapMemory + &quot;)&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   synchronized (mLock) &#123;</div><div class="line">       ensureGroupStateLoadedLocked(userId);</div><div class="line"></div><div class="line">       final int N = appWidgetIds.length;</div><div class="line">       for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">           final int appWidgetId = appWidgetIds[i];</div><div class="line"></div><div class="line">           // NOTE: The lookup is enforcing security across users by making</div><div class="line">           // sure the caller can only access widgets it hosts or provides.</div><div class="line">           Widget widget = lookupWidgetLocked(appWidgetId,</div><div class="line">                   Binder.getCallingUid(), callingPackage);</div><div class="line"></div><div class="line">           if (widget != null) &#123;</div><div class="line">               updateAppWidgetInstanceLocked(widget, views, partially);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先会做些安全性检查，以及图片大小限制检查。最后会针对每一个appWidgetId，通过lookupWidgetLocked找到其对应的Widget。</p>
<ol>
<li>Widget是一个带有很多信息的类，我们看看lookupWidgetLocked方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private Widget lookupWidgetLocked(int appWidgetId, int uid, String packageName) &#123;</div><div class="line">   final int N = mWidgets.size();</div><div class="line">   for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">       Widget widget = mWidgets.get(i);</div><div class="line">       if (widget.appWidgetId == appWidgetId</div><div class="line">               &amp;&amp; mSecurityPolicy.canAccessAppWidget(widget, uid, packageName)) &#123;</div><div class="line">           return widget;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上它是从mWidgets找到对应的Widget，先看看Widget类，它是AppWidgetServiceImpl的非静态内部类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final class Widget &#123;</div><div class="line">   int appWidgetId;</div><div class="line">   int restoredId;  // tracking &amp; remapping any restored state</div><div class="line">   Provider provider; // 对应AppWidgetProvider，里面有AppWidgetProvider信息。</div><div class="line">   RemoteViews views; //表示View的RemoteView</div><div class="line">   Bundle options;</div><div class="line">   Host host; //显示的地方</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public String toString() &#123;</div><div class="line">       return &quot;AppWidgetId&#123;&quot; + appWidgetId + &apos;:&apos; + host + &apos;:&apos; + provider + &apos;&#125;&apos;;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而是从什么时候把Widget添加到mWidgets的呢？主要有三个地方，一个是绑定AppWidgetProvider跟id时，初始化时加载AppWidget与对应的host;一个是第一次添加AppWidget到桌面时，给AppWidget分配id的时候;一个是restore AppWidget的时候。我们看看分配id时，添加Widget的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public int allocateAppWidgetId(String callingPackage, int hostId) &#123;</div><div class="line">   final int userId = UserHandle.getCallingUserId();</div><div class="line"></div><div class="line">   // Make sure the package runs under the caller uid.</div><div class="line">   mSecurityPolicy.enforceCallFromPackage(callingPackage);</div><div class="line"></div><div class="line">   synchronized (mLock) &#123;</div><div class="line">       ensureGroupStateLoadedLocked(userId);</div><div class="line"></div><div class="line">       if (mNextAppWidgetIds.indexOfKey(userId) &lt; 0) &#123;</div><div class="line">           mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId); //增量分配一个id，保证不冲突</div><div class="line"></div><div class="line">       // NOTE: The lookup is enforcing security across users by making</div><div class="line">       // sure the caller can only access hosts it owns.</div><div class="line">       HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage); //得到hostid</div><div class="line">       Host host = lookupOrAddHostLocked(id); //根据id获取host</div><div class="line"></div><div class="line">       Widget widget = new Widget();</div><div class="line">       widget.appWidgetId = appWidgetId;</div><div class="line">       widget.host = host;</div><div class="line"></div><div class="line">       host.widgets.add(widget);   //把widget添加到host的widgets列表中</div><div class="line">       addWidgetLocked(widget); //添加</div><div class="line"></div><div class="line">       saveGroupStateAsync(userId);</div><div class="line"></div><div class="line">       return appWidgetId;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上这里还没有添加对应的provider，所以在Launcher开发的时候，我们需要先调用allocateAppWidgetId方法，然后调用bindAppWidgetId方法绑定id与AppWidgetProvider。而当View有变化的时候，Host需要接收AppWidgetServiceImpl的通知，如何实现的呢？Host（Launcher应用）会跨进程调用AppWidgetServiceImpl的startListening方法，将AppWidgetHost端的Callback服务传递给AppWidgetServiceImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 在AppWidgetHost类当中，AppWidgetHost是Host端的代码</div><div class="line"></div><div class="line">public void startListening() &#123;</div><div class="line">   int[] updatedIds;</div><div class="line">   ArrayList&lt;RemoteViews&gt; updatedViews = new ArrayList&lt;RemoteViews&gt;();</div><div class="line">   try &#123;</div><div class="line">       updatedIds = sService.startListening(mCallbacks, mContextOpPackageName, mHostId,</div><div class="line">               updatedViews); //把AppWidgetHost端的mCallbacks传递给AppWidgetService，mCallbacks是Binder对象。</div><div class="line">   &#125;</div><div class="line">   catch (RemoteException e) &#123;</div><div class="line">       throw new RuntimeException(&quot;system server dead?&quot;, e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   final int N = updatedIds.length;</div><div class="line">   for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">       updateAppWidgetView(updatedIds[i], updatedViews.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在AppWidgetServiceImpl里面会将mCallbacks保存在对应的Host当中。</p>
<ol>
<li>从mWidgets里面找到Widget后，会调用updateAppWidgetInstanceLocked方法来更新Widget。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,</div><div class="line">       boolean isPartialUpdate) &#123;</div><div class="line">   if (widget != null &amp;&amp; widget.provider != null</div><div class="line">           &amp;&amp; !widget.provider.zombie &amp;&amp; !widget.host.zombie) &#123; // 保证widget有效，并且host也有效</div><div class="line"></div><div class="line">       if (isPartialUpdate &amp;&amp; widget.views != null) &#123;</div><div class="line">           // For a partial update, we merge the new RemoteViews with the old. 这里是对于partial update的。</div><div class="line">           widget.views.mergeRemoteViews(views);</div><div class="line">       &#125; else &#123;</div><div class="line">           // For a full update we replace the RemoteViews completely.</div><div class="line">           widget.views = views;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       scheduleNotifyUpdateAppWidgetLocked(widget, views);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>而scheduleNotifyUpdateAppWidgetLocked 则是使用handler发送一个消息给主线程处理：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, RemoteViews updateViews) &#123;</div><div class="line">   if (widget == null || widget.provider == null || widget.provider.zombie</div><div class="line">           || widget.host.callbacks == null || widget.host.zombie) &#123;</div><div class="line">       return;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   SomeArgs args = SomeArgs.obtain();</div><div class="line">   args.arg1 = widget.host;</div><div class="line">   args.arg2 = widget.host.callbacks; //callbacks 是host的跨进程调用接口，来自于startListening</div><div class="line"></div><div class="line">   args.arg3 = updateViews;</div><div class="line">   args.argi1 = widget.appWidgetId;</div><div class="line"></div><div class="line">   mCallbackHandler.obtainMessage(</div><div class="line">           CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET,</div><div class="line">           args).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用mCallbackHandler发送一条MSG_NOTIFY_UPDATE_APP_WIDGET的消息，mCallbackHandler是AppWidgetServiceImpl.CallbackHandler的实例。如果处理，具体就到CallbackHandler的handleMessage方法中，就是一个Handler机制，让代码运行在主线程：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">public void handleMessage(Message message) &#123;</div><div class="line">   switch (message.what) &#123;</div><div class="line">       case MSG_NOTIFY_UPDATE_APP_WIDGET: &#123;</div><div class="line">           SomeArgs args = (SomeArgs) message.obj;</div><div class="line">           Host host = (Host) args.arg1;</div><div class="line">           IAppWidgetHost callbacks = (IAppWidgetHost) args.arg2;</div><div class="line">           RemoteViews views = (RemoteViews) args.arg3;</div><div class="line">           final int appWidgetId = args.argi1;</div><div class="line">           args.recycle();</div><div class="line"></div><div class="line">           handleNotifyUpdateAppWidget(host, callbacks, appWidgetId, views);</div><div class="line">       &#125; break;</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>handleNotifyUpdateAppWidget方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks,</div><div class="line">       int appWidgetId, RemoteViews views) &#123;</div><div class="line">   try &#123;</div><div class="line">       callbacks.updateAppWidget(appWidgetId, views); //通知AppWidgtHost</div><div class="line">   &#125; catch (RemoteException re) &#123;</div><div class="line">       synchronized (mLock) &#123;</div><div class="line">           Slog.e(TAG, &quot;Widget host dead: &quot; + host.id, re);</div><div class="line">           host.callbacks = null;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实际上就是调用IAppWidgetHost类型的updateAppWidget，进行跨进程调用。而callbacks就是在AppWidgetServiceImpl的startListening设置的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">public int[] startListening(IAppWidgetHost callbacks, String callingPackage,</div><div class="line">       int hostId, List&lt;RemoteViews&gt; updatedViews) &#123;</div><div class="line">   final int userId = UserHandle.getCallingUserId();</div><div class="line"></div><div class="line">   if (DEBUG) &#123;</div><div class="line">       Slog.i(TAG, &quot;startListening() &quot; + userId);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Make sure the package runs under the caller uid.</div><div class="line">   mSecurityPolicy.enforceCallFromPackage(callingPackage);</div><div class="line"></div><div class="line">   synchronized (mLock) &#123;</div><div class="line">       ensureGroupStateLoadedLocked(userId);</div><div class="line"></div><div class="line">       // NOTE: The lookup is enforcing security across users by making</div><div class="line">       // sure the caller can only access hosts it owns.</div><div class="line">       HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage);</div><div class="line">       Host host = lookupOrAddHostLocked(id);</div><div class="line"></div><div class="line">       host.callbacks = callbacks; //设置callbacks</div><div class="line"></div><div class="line">       updatedViews.clear();</div><div class="line"></div><div class="line">       ArrayList&lt;Widget&gt; instances = host.widgets;</div><div class="line">       int N = instances.size();</div><div class="line">       int[] updatedIds = new int[N];</div><div class="line">       for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">           Widget widget = instances.get(i);</div><div class="line">           updatedIds[i] = widget.appWidgetId;</div><div class="line">           updatedViews.add(cloneIfLocalBinder(widget.views));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return updatedIds;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>最终updateAppWidget的实现代码是：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static class Callbacks extends IAppWidgetHost.Stub &#123;</div><div class="line">   private final WeakReference&lt;Handler&gt; mWeakHandler;</div><div class="line"></div><div class="line">   public Callbacks(Handler handler) &#123;</div><div class="line">       mWeakHandler = new WeakReference&lt;&gt;(handler);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void updateAppWidget(int appWidgetId, RemoteViews views) &#123;</div><div class="line">       if (isLocalBinder() &amp;&amp; views != null) &#123;</div><div class="line">           views = views.clone();</div><div class="line">       &#125;</div><div class="line">       Handler handler = mWeakHandler.get();</div><div class="line">       if (handler == null) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       Message msg = handler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views);</div><div class="line">       msg.sendToTarget();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>最后使用Handler发送消息给主线程，然后在handleMessage中有具体的处理程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class UpdateHandler extends Handler &#123;</div><div class="line">   public UpdateHandler(Looper looper) &#123;</div><div class="line">       super(looper);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void handleMessage(Message msg) &#123;</div><div class="line">       switch (msg.what) &#123;</div><div class="line">           case HANDLE_UPDATE: &#123;</div><div class="line">               updateAppWidgetView(msg.arg1, (RemoteViews)msg.obj);</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>然后调用AppWidgetHost的updateAppWidgetView方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void updateAppWidgetView(int appWidgetId, RemoteViews views) &#123;</div><div class="line">   AppWidgetHostView v;</div><div class="line">   synchronized (mViews) &#123;</div><div class="line">       v = mViews.get(appWidgetId);</div><div class="line">   &#125;</div><div class="line">   if (v != null) &#123;</div><div class="line">       v.updateAppWidget(views);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>根据appWidgetId找到对应的AppWidgetHostView，然后调用AppWidgetHostView的updateAppWidget来根据RemoteView来更新AppWidgetHostView：</li>
</ol>
<p>﻿</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">* Process a set of &#123;@link RemoteViews&#125; coming in as an update from the</div><div class="line">* AppWidget provider. Will animate into these new views as needed</div><div class="line">*/</div><div class="line">public void updateAppWidget(RemoteViews remoteViews) &#123;</div><div class="line"></div><div class="line">   boolean recycled = false;</div><div class="line">   View content = null;</div><div class="line">   Exception exception = null;</div><div class="line"></div><div class="line">   // Capture the old view into a bitmap so we can do the crossfade.</div><div class="line">    ... 省去old view to bitmap</div><div class="line"></div><div class="line">   if (remoteViews == null) &#123;</div><div class="line">       if (mViewMode == VIEW_MODE_DEFAULT) &#123;</div><div class="line">           // We&apos;ve already done this -- nothing to do.</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       content = getDefaultView();  // 默认的View</div><div class="line">       mLayoutId = -1;</div><div class="line">       mViewMode = VIEW_MODE_DEFAULT;</div><div class="line">   &#125; else &#123;</div><div class="line">       // Prepare a local reference to the remote Context so we&apos;re ready to</div><div class="line">       // inflate any requested LayoutParams.</div><div class="line">       mRemoteContext = getRemoteContext();</div><div class="line">       int layoutId = remoteViews.getLayoutId();</div><div class="line"></div><div class="line">       // If our stale view has been prepared to match active, and the new</div><div class="line">       // layout matches, try recycling it</div><div class="line">       if (content == null &amp;&amp; layoutId == mLayoutId) &#123;</div><div class="line">           try &#123;</div><div class="line">               remoteViews.reapply(mContext, mView, mOnClickHandler);</div><div class="line">               content = mView;</div><div class="line">               recycled = true;</div><div class="line">               if (LOGD) Log.d(TAG, &quot;was able to recycled existing layout&quot;);</div><div class="line">           &#125; catch (RuntimeException e) &#123;</div><div class="line">               exception = e;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Try normal RemoteView inflation</div><div class="line">       if (content == null) &#123;</div><div class="line">           try &#123;</div><div class="line">               content = remoteViews.apply(mContext, this, mOnClickHandler);</div><div class="line">               if (LOGD) Log.d(TAG, &quot;had to inflate new layout&quot;);</div><div class="line">           &#125; catch (RuntimeException e) &#123;</div><div class="line">               exception = e;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       mLayoutId = layoutId;</div><div class="line">       mViewMode = VIEW_MODE_CONTENT;</div><div class="line">   &#125;</div><div class="line">   if (content == null) &#123;</div><div class="line">       if (mViewMode == VIEW_MODE_ERROR) &#123;</div><div class="line">           // We&apos;ve already done this -- nothing to do.</div><div class="line">           return ;</div><div class="line">       &#125;</div><div class="line">       Log.w(TAG, &quot;updateAppWidget couldn&apos;t find any view, using error view&quot;, exception);</div><div class="line">       content = getErrorView();  // 在失败的情况下，会使用ErrorView。</div><div class="line">       mViewMode = VIEW_MODE_ERROR;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (!recycled) &#123;</div><div class="line">       prepareView(content);</div><div class="line">       addView(content);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (mView != content) &#123;</div><div class="line">       removeView(mView);</div><div class="line">       mView = content;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (CROSSFADE) &#123;</div><div class="line">       if (mFadeStartTime &lt; 0) &#123;</div><div class="line">           // if there is already an animation in progress, don&apos;t do anything --</div><div class="line">           // the new view will pop in on top of the old one during the cross fade,</div><div class="line">           // and that looks okay.</div><div class="line">           mFadeStartTime = SystemClock.uptimeMillis();</div><div class="line">           invalidate();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码有点长，但我觉得值得认真一看，可以从源码中发现当我们的AppWidget在桌面显示异常时究竟可能是什么原因。更新view的整个策略主要就是：</p>
<ol>
<li><p>如果remoteView为空，则看是否已经使用了默认视图，如果已经使用了直接返回，如果没有则使用默认的视图。</p>
</li>
<li><p>如果remoteView不为空，则看layoutid是否跟现在已经使用的视图的layoutid一致，一致则重用旧的视图，调用remoteView.reapply方法重用视图，并且设置视图内容。</p>
</li>
<li><p>如果layoutid跟现使用的视图不一致，则调用remoteView.apply方法得到新的视图。</p>
</li>
<li><p>如果上面的步骤都没有得到视图，则使用错误视图。</p>
</li>
<li><p>如果新的视图与旧的视图不一致，则添加新的视图，删除旧的视图。</p>
</li>
</ol>
<p>其实这里更新视图的策略非常简单，尽量重用已有的视图。里面会有三种视图，一种是我们自己设置的，一种是默认的，一种是有错误的情况的。当我们在桌面上看到我们的AppWidget显示异常时，应该还是有两种不同的表现的，一种是错误情况，一种是是用来额默认的视图，如果remoteView为null的时候会使用默认视图，如果是从remoteView中读取视图失败时，则会使用错误视图。</p>
<p>所以看到错误视图时，我们可能需要考虑remoteView里面的View设置是否合理。如果看到的是默认视图，我们应该想想是否在AppWidgetProvider中调用了AppWidgetManager.updateAppWidget方法，是否remoteView参数为null？可能有的手机两种视图是一样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个updateAppWidget的分析就到这里了，AppWidget其他的更新也是一样的，整个更新过程跨越了三个进程，而RemoteView作为一种View跨进程传递的媒介。另外我觉得从AppWidget去理解Binder机制的使用可能也是一个非常好的切入点。因为这部分我们在应用开发当中经常使用，而且是View，能够看到效果。接下来我想写一篇关于Binder多线程的理解。我看AppWidget这部分的源码，也是项目中的AppWidget存在问题，熟悉AppWidget才能解决好问题，预测代码中可能潜在的问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/08/09/android-appwidget-api-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/09/android-appwidget-api-source-code/" itemprop="url">AppWidget源码分析---接口类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-09T00:00:00+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目中接触到AppWidget，相对来说这部分比较简单，所以趁着空余时间详细阅读了AppWidget的源码。这篇文章主要是从源码上分析AppWidget中API类的相关原理，相关类的简单功能介绍和实现原理。关于使用，建议看<a href="https://developer.android.com/guide/topics/appwidgets/index.html" target="_blank" rel="external">指导文档</a>。</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>AppWidget相关的API类（供我们应用开发者使用的类）主要有：</p>
<p>AppWidgetProvider：继承这个类，来提供Appwidget。</p>
<p>AppWidgetManager：提供了AppWidget的管理接口，比如更新，绑定AppWidget id，根据Component获取AppWidget id等等。</p>
<p>RemoteView：能够跨进程更新的View。</p>
<p>AppWidgetHost：与AppWidgt 服务交互的类，获取App widget，显示出来</p>
<p>AppwidgetHostView：实际上显示出来的View</p>
<p>他们之间的关系简略来讲如下：</p>
<p><img src="http://img.blog.csdn.net/20160809231430250" alt="这里写图片描述"></p>
<p>AppWidget Service 是一些类的集合，是AppWidget的核心服务，在之后的文章会介绍，这篇就不介绍了。下面详细介绍每个类的功能以及实现原理。</p>
<h3 id="AppWidgetProvider"><a href="#AppWidgetProvider" class="headerlink" title="AppWidgetProvider"></a>AppWidgetProvider</h3><p>这是我们在建立AppWidget的时候，需要去实现的类，它有几个重要的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager,</div><div class="line">       int appWidgetId, Bundle newOptions) // 当Widget的布局到新的大小的时候会被调用</div><div class="line"></div><div class="line">public void onDeleted(Context context, int[] appWidgetIds) // 当某个Widget被移除的时候回调</div><div class="line"></div><div class="line">public void onDisabled(Context context) // 当最后一个Widget被移除的时候回调</div><div class="line"></div><div class="line">public void onEnabled(Context context) // 当第一个Widget被添加的时候回调</div><div class="line"></div><div class="line">public void onRestored(Context context, int[] oldWidgetIds, int[] newWidgetIds) // 当Widget从缓存的Widget恢复时</div><div class="line"></div><div class="line">public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) //当Widget需要被提供RemoteView的时候，每次添加Widget的时候会调用</div><div class="line"></div><div class="line">public void onReceive(Context context, Intent intent) // 后面介绍</div></pre></td></tr></table></figure>
<p>这几个方法是我们在继承AppWidgetProvider的时候，可以根据自己的需要来实现的方法。注释里面是每个方法被回调的时机。</p>
<p>实际上如果去查看AppWidgetProvider的源码，你会发现AppWidgetProvider是继承自BroadcastReceiver的，也就是说它是一种广播。所以它也有一个onReceive方法，这个方法我前面特意没有说明什么时候调用，其实就是收到广播的时候回调。看看onReceive方法的实现，你会发现前面的那几个方法都是在onReceiver中调用的，每一种方法都对应着一种广播Action:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void onReceive(Context context, Intent intent) &#123;</div><div class="line">   // Protect against rogue update broadcasts (not really a security issue,</div><div class="line">   // just filter bad broacasts out so subclasses are less likely to crash).</div><div class="line">   String action = intent.getAction();</div><div class="line">   if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</div><div class="line">       Bundle extras = intent.getExtras();</div><div class="line">       if (extras != null) &#123;</div><div class="line">           int[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);</div><div class="line">           if (appWidgetIds != null &amp;&amp; appWidgetIds.length &gt; 0) &#123;</div><div class="line">               this.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) &#123;</div><div class="line">       Bundle extras = intent.getExtras();</div><div class="line">       if (extras != null &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) &#123;</div><div class="line">           final int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);</div><div class="line">           this.onDeleted(context, new int[] &#123; appWidgetId &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125; else if (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) &#123;</div><div class="line">       Bundle extras = intent.getExtras();</div><div class="line">       if (extras != null &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)</div><div class="line">               &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) &#123;</div><div class="line">           int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);</div><div class="line">           Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);</div><div class="line">           this.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context),</div><div class="line">                   appWidgetId, widgetExtras);</div><div class="line">       &#125;</div><div class="line">   &#125; else if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) &#123;</div><div class="line">       this.onEnabled(context);</div><div class="line">   &#125; else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) &#123;</div><div class="line">       this.onDisabled(context);</div><div class="line">   &#125; else if (AppWidgetManager.ACTION_APPWIDGET_RESTORED.equals(action)) &#123;</div><div class="line">       Bundle extras = intent.getExtras();</div><div class="line">       if (extras != null) &#123;</div><div class="line">           int[] oldIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS);</div><div class="line">           int[] newIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);</div><div class="line">           if (oldIds != null &amp;&amp; oldIds.length &gt; 0) &#123;</div><div class="line">               this.onRestored(context, oldIds, newIds);</div><div class="line">               this.onUpdate(context, AppWidgetManager.getInstance(context), newIds);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AppWidgetProvider是一个BroadcastReceiver，所以它的<code>onUpdate, onEnabled</code>等方法每次被调用前，都会调用onReceive方法。我们继承AppWidgetProvider，也可以重载onReceiver方法，修改<code>onUpdate</code>等方法被调用的时机，当然并不推荐这么做，破坏接口的语义会非常危险。另外一方面它是一个BroadcastReceiver，所以它就具备BroadcastReceiver的各种特性（需要说明的是AppWidgetProvider要在manifest文件中静态注册，因为系统在安装apk时需要知道应用有哪些方法桌面Widget），它能够注册自定义的ACTION，每次执行的时候是会创建一个新的AppWidgetProvider实例，Context不能绑定服务，执行时间不能超过10秒等等。</p>
<p>AppWidgetProvider是一个BroadcastReceiver，明白这一点其实也就是理解AppWidget实现原理了。在onUpdate中提供了AppWidgetManager参数，这个AppWidgetMananger又是什么呢？下面来介绍一下。</p>
<h2 id="AppWidgetManager"><a href="#AppWidgetManager" class="headerlink" title="AppWidgetManager"></a>AppWidgetManager</h2><p>名如其义，AppWidgetManager你可以理解为AppWidget的管理接口（实际上它只提供了管理AppWidget的部分接口，后面的文章会介绍真正管理AppWidget的接口，也就是AppWidget 的client）。我们可以用AppWidgetManager来更新AppWidget的内容，给AppWidget绑定id。AppWidgetManager是在实现AppWidgetProvider的时候，经常会用到的类，可以用<code>AppWidgetManager.updateAppWidget</code>来更新AppWidget。如果是有AdapterView的AppWidget，可以用<code>AppWidgetManager.notifyAppWidgetViewDataChanged</code>来通知Adapter的变化，用<code>partiallyUpdateAppWidget</code>部分更新Widget。这几个方法是经常在AppWidgetProvider的<code>onUpdate</code>方法中使用的。这几个方法的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public void notifyAppWidgetViewDataChanged(int appWidgetId, int viewId)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public void partiallyUpdateAppWidget(int appWidgetId, RemoteViews views)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public void updateAppWidget(int[] appWidgetIds, RemoteViews views)</div></pre></td></tr></table></figure>
<p>另外可以通过<code>getAppWidgetIds</code>获取AppWidgetProvider组件对应的AppWidget的Id数组，我们经常通过这个方法获取所有的id，然后来更新所有的跟AppWidgetProvider相关的AppWidget。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">public int[] getAppWidgetIds(ComponentName provider)</div></pre></td></tr></table></figure>
<p>另外还有<code>bindAppWidgetIdIfAllowed</code>方法和<code>getInstalledProviders</code>,这两个方法主要是在Launcher应用当中使用，分配AppWidget的id，然后用<code>bindAppWidgetIdIfAllowed</code>绑定AppWidgetProvider与id。用<code>getInstalledProviders</code>方法获取已经插入的AppWidgetProvider，可以用来供用户选择添加到桌面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public boolean bindAppWidgetIdIfAllowed(int appWidgetId, ComponentName provider,</div><div class="line">       Bundle options)</div><div class="line"></div><div class="line">public List&lt;AppWidgetProviderInfo&gt; getInstalledProviders()</div></pre></td></tr></table></figure>
<p>关于launcher可以参考aosp的源码:<a href="http://arnab.ch/blog/2013/08/how-to-write-custom-launcher-app-in-android/" target="_blank" rel="external">http://arnab.ch/blog/2013/08/how-to-write-custom-launcher-app-in-android/</a>。我们也可以自己开发launcher应用。</p>
<h2 id="RemoteView"><a href="#RemoteView" class="headerlink" title="RemoteView"></a>RemoteView</h2><p>RemoteView顾名思义就是指远程View，通过本地进程修改RemoteView，能够使这些修改通过RemoteView为载体传递到远程进程。RemoteView不仅仅在AppWidget中有使用，Notification中也是使用了RemoteView。下面简单介绍一下RemoteView的实现原理。</p>
<p>RemoteView继承自Parcelable，所以RemoteView本身就是可以跨进程传递的。RemoteView有个内部类叫做Action，它也是继承自Parcelable，对于不同的操作，RemoteView内部实现了不同的Action。</p>
<p>比如点击事件，RemoteView内部有一个SetOnClickPendingIntent，它也是继承自Action，设置点击事件就是将点击事件保存在这里面，把点击事件作为一个Action。可以看看它的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private class SetOnClickPendingIntent extends Action &#123;</div><div class="line">   public SetOnClickPendingIntent(int id, PendingIntent pendingIntent) &#123;</div><div class="line">       this.viewId = id;</div><div class="line">       this.pendingIntent = pendingIntent;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public SetOnClickPendingIntent(Parcel parcel) &#123;</div><div class="line">       viewId = parcel.readInt();</div><div class="line"></div><div class="line">       // We check a flag to determine if the parcel contains a PendingIntent.</div><div class="line">       if (parcel.readInt() != 0) &#123;</div><div class="line">           pendingIntent = PendingIntent.readPendingIntentOrNullFromParcel(parcel);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">       dest.writeInt(TAG);</div><div class="line">       dest.writeInt(viewId);</div><div class="line"></div><div class="line">       // We use a flag to indicate whether the parcel contains a valid object.</div><div class="line">       dest.writeInt(pendingIntent != null ? 1 : 0);</div><div class="line">       if (pendingIntent != null) &#123;</div><div class="line">           pendingIntent.writeToParcel(dest, 0 /* no flags */);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void apply(View root, ViewGroup rootParent, final OnClickHandler handler) &#123;</div><div class="line">       final View target = root.findViewById(viewId);</div><div class="line">       if (target == null) return;</div><div class="line"></div><div class="line">       // If the view is an AdapterView, setting a PendingIntent on click doesn&apos;t make much</div><div class="line">       // sense, do they mean to set a PendingIntent template for the AdapterView&apos;s children?</div><div class="line">       if (mIsWidgetCollectionChild) &#123;</div><div class="line">           Log.w(LOG_TAG, &quot;Cannot setOnClickPendingIntent for collection item &quot; +</div><div class="line">                   &quot;(id: &quot; + viewId + &quot;)&quot;);</div><div class="line">           ApplicationInfo appInfo = root.getContext().getApplicationInfo();</div><div class="line"></div><div class="line">           // We let this slide for HC and ICS so as to not break compatibility. It should have</div><div class="line">           // been disabled from the outset, but was left open by accident.</div><div class="line">           if (appInfo != null &amp;&amp;</div><div class="line">                   appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // If the pendingIntent is null, we clear the onClickListener</div><div class="line">       OnClickListener listener = null;</div><div class="line">       if (pendingIntent != null) &#123;</div><div class="line">           listener = new OnClickListener() &#123;</div><div class="line">               public void onClick(View v) &#123;</div><div class="line">                   // Find target view location in screen coordinates and</div><div class="line">                   // fill into PendingIntent before sending.</div><div class="line">                   final Rect rect = getSourceBounds(v);</div><div class="line"></div><div class="line">                   final Intent intent = new Intent();</div><div class="line">                   intent.setSourceBounds(rect);</div><div class="line">                   handler.onClickHandler(v, pendingIntent, intent);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line">       &#125;</div><div class="line">       target.setOnClickListener(listener);</div><div class="line">   &#125;</div><div class="line">...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中以Parcel为参数的构造函数相当于是从Parcel当中读取内容，而writeToParcel是将Action写入到Parcel。这两个函数是用来传递Action用的。而apply方法则是将Action解析出来，设置监听（这种监听是远程监听，在onClick方法里面发送一个PendingIntent），具体实现在RemoteView的OnClickHandler中。其他的Action也是类似的。关于Parcel实现原理可以借鉴我之前写的两篇关于Bitmap传输的文章:<a href="http://blog.csdn.net/xxxzhi/article/details/51531098" target="_blank" rel="external"> Android4.0 Bitmap Parcel传输源码分析</a>,<a href="http://blog.csdn.net/xxxzhi/article/details/51490253" target="_blank" rel="external">Android6.0 Bitmap存储以及Parcel传输源码分析</a></p>
<p>RemoteView里面有一个mActions变量，是Action的列表。通过Parcel传递RemoteView的时候，RemoteView会将mActions里面的内容都写入到Parcel中。在readParcel的时候，使用Action的带Parcel参数的构造函数从Parcel里面读取Action，进行设置。Action其实就是一种模板方法模式。RemoteView很多设置是跟普通的View不一样的，RemoteView是一个能够跨进程设置相关内容的，如果需要设置监听函数之类的，只能设置PendingIntent。可以看看RemoteView里面的CREATOR和RemoteView对应的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line">* Parcelable.Creator that instantiates RemoteViews objects</div><div class="line">*/</div><div class="line">public static final Parcelable.Creator&lt;RemoteViews&gt; CREATOR = new Parcelable.Creator&lt;RemoteViews&gt;() &#123;</div><div class="line">   public RemoteViews createFromParcel(Parcel parcel) &#123;</div><div class="line">       return new RemoteViews(parcel);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public RemoteViews[] newArray(int size) &#123;</div><div class="line">       return new RemoteViews[size];</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public RemoteViews(Parcel parcel) &#123;</div><div class="line">   this(parcel, null);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private RemoteViews(Parcel parcel, BitmapCache bitmapCache) &#123;//实际上在构造函数中读取Parcel的内容，重新创建一个mActions</div><div class="line">   int mode = parcel.readInt();</div><div class="line"></div><div class="line">   // We only store a bitmap cache in the root of the RemoteViews.</div><div class="line">   if (bitmapCache == null) &#123;</div><div class="line">       mBitmapCache = new BitmapCache(parcel);</div><div class="line">   &#125; else &#123;</div><div class="line">       setBitmapCache(bitmapCache);</div><div class="line">       setNotRoot();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (mode == MODE_NORMAL) &#123;</div><div class="line">       mApplication = parcel.readParcelable(null);</div><div class="line">       mLayoutId = parcel.readInt();</div><div class="line">       mIsWidgetCollectionChild = parcel.readInt() == 1;</div><div class="line"></div><div class="line">       int count = parcel.readInt();</div><div class="line">       if (count &gt; 0) &#123;</div><div class="line">           mActions = new ArrayList&lt;Action&gt;(count);</div><div class="line">           for (int i=0; i&lt;count; i++) &#123;</div><div class="line">               int tag = parcel.readInt();</div><div class="line">               switch (tag) &#123;</div><div class="line">                   case SetOnClickPendingIntent.TAG:</div><div class="line">                       mActions.add(new SetOnClickPendingIntent(parcel));</div><div class="line">                       break;</div><div class="line">                   case SetDrawableParameters.TAG:</div><div class="line">                       mActions.add(new SetDrawableParameters(parcel));</div><div class="line">                       break;</div><div class="line">                    ...</div><div class="line">                   default:</div><div class="line">                       throw new ActionException(&quot;Tag &quot; + tag + &quot; not found&quot;);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; else &#123;</div><div class="line">       // MODE_HAS_LANDSCAPE_AND_PORTRAIT</div><div class="line">       mLandscape = new RemoteViews(parcel, mBitmapCache);</div><div class="line">       mPortrait = new RemoteViews(parcel, mBitmapCache);</div><div class="line">       mApplication = mPortrait.mApplication;</div><div class="line">       mLayoutId = mPortrait.getLayoutId();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // setup the memory usage statistics</div><div class="line">   mMemoryUsageCounter = new MemoryUsageCounter();</div><div class="line">   recalculateMemoryUsage();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用RemoteView的apply方法就在远程进程设置了相关内容了。我们AppWidget的远程进程是Launcher应用所在的进程。由AppWidgetHost管理这些。</p>
<h2 id="AppWidgetHost"><a href="#AppWidgetHost" class="headerlink" title="AppWidgetHost"></a>AppWidgetHost</h2><p>这个类是Android提供的供应用与AppWidget service交互的类，我们的AppWidgetProvider提供了Widget，而AppWidgetHost则是读取Widget，将它显示出来。一般在home screen中使用，也就是我们的桌面，Launcher。与之相关的还有个AppWidgetHostView，由AppWidgetHost创建，它与AppWidgetProvider对应。可以看一下AppWidgetHost的createView方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final AppWidgetHostView createView(Context context, int appWidgetId,</div><div class="line">       AppWidgetProviderInfo appWidget) &#123;</div><div class="line">   AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);</div><div class="line">   view.setOnClickHandler(mOnClickHandler);</div><div class="line">   view.setAppWidget(appWidgetId, appWidget);</div><div class="line">   synchronized (mViews) &#123;</div><div class="line">       mViews.put(appWidgetId, view);</div><div class="line">   &#125;</div><div class="line">   RemoteViews views;</div><div class="line">   try &#123;</div><div class="line">       views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);</div><div class="line">   &#125; catch (RemoteException e) &#123;</div><div class="line">       throw new RuntimeException(&quot;system server dead?&quot;, e);</div><div class="line">   &#125;</div><div class="line">   view.updateAppWidget(views);</div><div class="line"></div><div class="line">   return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个主要是在launcher应用使用，就不详细介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要是介绍AppWidget相关的一些类，分析里面的源码功能，以及实现方式。通过深入了解它的实现方式才能够更好地使用它，分析遇到的问题。下一篇将从源码角度上介绍一些方法的处理流程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/08/04/android-accessibility-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/04/android-accessibility-introduce/" itemprop="url">Android Accessibility使用及事件流程简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-04T00:00:00+08:00">
                2016-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Accessibility是Android从API 4开始提供的一个功能，它主要目的是帮助一些因为有视觉，听觉，身体障碍而无法完全使用触摸屏或铃声等的用户来使用Android的。而实际上现在很多开发者都用它来实现一些其他功能了，比如说微信抢红包，自动安装APK，强制停止应用等。下面来简单介绍一下它的相关使用及原理。</p>
<h3 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h3><p>它最主要的接口是类AccessibilityService。AccessibilityService是Service的子类，我们可以继承这个类并实现它的抽象方法来监视一个应用的界面元素状态的变化，比如focus变化，一个按钮被click等等。当有这些变化的时候，系统会将这些信息封装在AccessibilityEvent里面，回调AccessibilityService的onAccessibilityEvent(AccessibilityEvent)方法。我们可以实现onAccessibilityEvent来处理这些AccessibilityEvent。下面看一步一步地使用示例：</p>
<h4 id="实现AccessibilityService"><a href="#实现AccessibilityService" class="headerlink" title="实现AccessibilityService"></a>实现AccessibilityService</h4><p>这里使用ApiDemo当中将文字转换为语音的例子来介绍，这段代码在<a href="https://github.com/android/platform_development/blob/master/samples/ApiDemos/src/com/example/android/apis/accessibility/TaskBackService.java" target="_blank" rel="external"><sdk>/samples/<platform>/ApiDemos/src/com/example/android/apis/accessibility/TaskBackService</platform></sdk></a>，如何使用ApiDemo可以参考<a href="https://developer.android.com/samples/index.html" target="_blank" rel="external">Samples</a>。下面是简单介绍里面的核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line"> * This class demonstrates how an accessibility service can query</div><div class="line"></div><div class="line"> * window content to improve the feedback given to the user.</div><div class="line"></div><div class="line"> */</div><div class="line"></div><div class="line">public class TaskBackService extends AccessibilityService implements OnInitListener &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /** Tag for logging. */</div><div class="line"></div><div class="line">    private static final String LOG_TAG = &quot;TaskBackService/onAccessibilityEvent&quot;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /** Comma separator. */</div><div class="line"></div><div class="line">    private static final String SEPARATOR = &quot;, &quot;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /** The class name of TaskListView - for simplicity we speak only its items. */</div><div class="line"></div><div class="line">    private static final String TASK_LIST_VIEW_CLASS_NAME =</div><div class="line"></div><div class="line">        &quot;com.example.android.apis.accessibility.TaskListView&quot;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /** Flag whether Text-To-Speech is initialized. */</div><div class="line"></div><div class="line">    private boolean mTextToSpeechInitialized;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /** Handle to the Text-To-Speech engine. */</div><div class="line"></div><div class="line">    private TextToSpeech mTts;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    public void onServiceConnected() &#123;</div><div class="line"></div><div class="line">        // Initializes the Text-To-Speech engine as soon as the service is connected.</div><div class="line"></div><div class="line">        mTts = new TextToSpeech(getApplicationContext(), this);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * Processes an AccessibilityEvent, by traversing the View&apos;s tree and</div><div class="line"></div><div class="line">     * putting together a message to speak to the user.</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    public void onAccessibilityEvent(AccessibilityEvent event) &#123;</div><div class="line"></div><div class="line">        if (!mTextToSpeechInitialized) &#123;</div><div class="line"></div><div class="line">            Log.e(LOG_TAG, &quot;Text-To-Speech engine not ready.  Bailing out.&quot;);</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // This AccessibilityNodeInfo represents the view that fired the</div><div class="line"></div><div class="line">        // AccessibilityEvent. The following code will use it to traverse the</div><div class="line"></div><div class="line">        // view hierarchy, using this node as a starting point.</div><div class="line"></div><div class="line">        //</div><div class="line"></div><div class="line">        // NOTE: Every method that returns an AccessibilityNodeInfo may return null,</div><div class="line"></div><div class="line">        // because the explored window is in another process and the</div><div class="line"></div><div class="line">        // corresponding View might be gone by the time your request reaches the</div><div class="line"></div><div class="line">        // view hierarchy.</div><div class="line"></div><div class="line">        AccessibilityNodeInfo source = event.getSource();</div><div class="line"></div><div class="line">        if (source == null) &#123;</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // Grab the parent of the view that fired the event.</div><div class="line"></div><div class="line">        AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);</div><div class="line"></div><div class="line">        if (rowNode == null) &#123;</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // Using this parent, get references to both child nodes, the label and the checkbox.</div><div class="line"></div><div class="line">        AccessibilityNodeInfo labelNode = rowNode.getChild(0);</div><div class="line"></div><div class="line">        if (labelNode == null) &#123;</div><div class="line"></div><div class="line">            rowNode.recycle();</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        AccessibilityNodeInfo completeNode = rowNode.getChild(1);</div><div class="line"></div><div class="line">        if (completeNode == null) &#123;</div><div class="line"></div><div class="line">            rowNode.recycle();</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // Determine what the task is and whether or not it&apos;s complete, based on</div><div class="line"></div><div class="line">        // the text inside the label, and the state of the check-box.</div><div class="line"></div><div class="line">        if (rowNode.getChildCount() &lt; 2 || !rowNode.getChild(1).isCheckable()) &#123;</div><div class="line"></div><div class="line">            rowNode.recycle();</div><div class="line"></div><div class="line">            return;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        CharSequence taskLabel = labelNode.getText();</div><div class="line"></div><div class="line">        final boolean isComplete = completeNode.isChecked();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        String completeStr = null;</div><div class="line"></div><div class="line">        if (isComplete) &#123;</div><div class="line"></div><div class="line">            completeStr = getString(R.string.task_complete);</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            completeStr = getString(R.string.task_not_complete);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        String taskStr = getString(R.string.task_complete_template, taskLabel, completeStr);</div><div class="line"></div><div class="line">        StringBuilder utterance = new StringBuilder(taskStr);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // The custom ListView added extra context to the event by adding an</div><div class="line"></div><div class="line">        // AccessibilityRecord to it. Extract that from the event and read it.</div><div class="line"></div><div class="line">        final int records = event.getRecordCount();</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; records; i++) &#123;</div><div class="line"></div><div class="line">            AccessibilityRecord record = event.getRecord(i);</div><div class="line"></div><div class="line">            CharSequence contentDescription = record.getContentDescription();</div><div class="line"></div><div class="line">            if (!TextUtils.isEmpty(contentDescription )) &#123;</div><div class="line"></div><div class="line">                utterance.append(SEPARATOR);</div><div class="line"></div><div class="line">                utterance.append(contentDescription);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        // Announce the utterance.</div><div class="line"></div><div class="line">        mTts.speak(utterance.toString(), TextToSpeech.QUEUE_FLUSH, null);</div><div class="line"></div><div class="line">        Log.d(LOG_TAG, utterance.toString());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    private AccessibilityNodeInfo getListItemNodeInfo(AccessibilityNodeInfo source) &#123;</div><div class="line"></div><div class="line">        AccessibilityNodeInfo current = source;</div><div class="line"></div><div class="line">        while (true) &#123;</div><div class="line"></div><div class="line">            AccessibilityNodeInfo parent = current.getParent();</div><div class="line"></div><div class="line">            if (parent == null) &#123;</div><div class="line"></div><div class="line">                return null;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (TASK_LIST_VIEW_CLASS_NAME.equals(parent.getClassName())) &#123; //找到TaskListView</div><div class="line"></div><div class="line">                return current;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // NOTE: Recycle the infos. 记得回收AccessibilityNodeInfo</div><div class="line"></div><div class="line">            AccessibilityNodeInfo oldCurrent = current;</div><div class="line"></div><div class="line">            current = parent;</div><div class="line"></div><div class="line">            oldCurrent.recycle();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * &#123;@inheritDoc&#125;</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    public void onInterrupt() &#123;</div><div class="line"></div><div class="line">        /* do nothing */</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面这段代码是对TaskList的辅助。</p>
<h4 id="AccessibilityService的配置声明"><a href="#AccessibilityService的配置声明" class="headerlink" title="AccessibilityService的配置声明"></a>AccessibilityService的配置声明</h4><p>首先它跟普通的Service一样，需要在Manifest文件中声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;service android:name=&quot;.MyAccessibilityService&quot;&gt;</div><div class="line">     &lt;intent-filter&gt;</div><div class="line">         &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt;</div><div class="line">     &lt;/intent-filter&gt;</div><div class="line">     &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/taskbackconfig&quot; /&gt;</div><div class="line"></div><div class="line"> &lt;/service&gt;</div></pre></td></tr></table></figure></p>
<p>与其他Service不同的是里面有个元数据标志了配置资源—taskbackconfig。taskbackconfig里面的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">   android:accessibilityEventTypes=&quot;typeAllMask&quot;</div><div class="line">   android:packageNames=&quot;com.example.android.apis&quot;</div><div class="line">   android:accessibilityFeedbackType=&quot;feedbackSpoken&quot;</div><div class="line">   android:notificationTimeout=&quot;100&quot;</div><div class="line">   android:canRetrieveWindowContent=&quot;true&quot;</div><div class="line">   android:description=&quot;@string/accessibility_query_window_description&quot; /&gt;</div></pre></td></tr></table></figure>
<p>其中packageNames限制了监视的包名，accessibilityEventType表示该AccessibilityService想要收到的Event事件类型。accessibilityFeedbackType表示提供的feedback类型，canRetrieveWindowContent是否可以获取窗口的内容，description表示描述信息，在设置中辅助功能里面允许该应用进行辅助设置时，会显示在那个页面下面。</p>
<h3 id="事件处理流程简述"><a href="#事件处理流程简述" class="headerlink" title="事件处理流程简述"></a>事件处理流程简述</h3><p>Accessibility是能够获取到控件的消息，这些信息是从哪传递出来的呢？传递的整个过程是怎样的呢？</p>
<h4 id="从View开始"><a href="#从View开始" class="headerlink" title="从View开始"></a>从View开始</h4><p>事件是跟View相关的，它从View开始的，View实现了一个叫AccessibilityEventSource的接口，AccessibilityEventSource接口包含了两个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void sendAccessibilityEvent(int eventType);</div><div class="line"></div><div class="line">public void sendAccessibilityEventUnchecked(AccessibilityEvent event);</div></pre></td></tr></table></figure>
<p>这两个函数会用来发送AccessibilityEvent，比如在View收到点击事件时，当View的Focus状态变化时等等，View调用这两个接口来开启发送AccessibilityEvent。</p>
<h4 id="反向递归请求到ViewRootImpl"><a href="#反向递归请求到ViewRootImpl" class="headerlink" title="反向递归请求到ViewRootImpl"></a>反向递归请求到ViewRootImpl</h4><p>另外ViewGroup也实现了ViewParent接口，而ViewParent有一个接口函数<code>requestSendAccessibilityEvent</code>，在子View中，sendAccessibilityEvent方法最终会调用getParent().requestSendAccessibilityEvent，一层一层地往上调用，最终在ViewRootImpl里面使用AccessibilityManager的<code>sendAccessibilityEvent</code>方法binder机制将AccessibilityEvent发送给AccessibilityManagerService。</p>
<h4 id="AccessibilityManagerService-管理核心"><a href="#AccessibilityManagerService-管理核心" class="headerlink" title="AccessibilityManagerService 管理核心"></a>AccessibilityManagerService 管理核心</h4><p>AccessibilityManagerService是在SystemServer中初始化的，并且添加到ServiceManager中。AccessibilityManagerService在有包变化的时候（安装，卸载）更新AccessibilityService绑定，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void updateServicesLocked(UserState userState) &#123;</div><div class="line">   if (userState.mIsAccessibilityEnabled) &#123;</div><div class="line">       manageServicesLocked(userState);</div><div class="line">   &#125; else &#123;</div><div class="line">       unbindAllServicesLocked(userState);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送到AccessibilityService"><a href="#发送到AccessibilityService" class="headerlink" title="发送到AccessibilityService"></a>发送到AccessibilityService</h4><p>在出现新的AccessibilityService时会去绑定AccessibilityService获取绑定的结果IAccessibilityServiceClient(实际上是AccessibilityService中onBinder返回的IAccessibilityServiceClientWrapper的Proxy)，跟AccessibilityService通信相关的信息保存在AccessibilityManagerService.Service类当中。当AccessibilityManagerService收到Event后，会遍历所有的Service，并通过IAccessibilityServiceClient将Event发送给AccessibilityService。</p>
<p>从AccessibilityEvent事件产生到发送到AccessibilityService，整个流程就是这样了。整个过程如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160804232139269" alt="这里写图片描述"></p>
<p>这里就简单介绍一下流程，有机会再好好分析一下源码。</p>
<p>###总结</p>
<p>AccessibilityService给我们提供了很多方便，我们可以利用AccessibilityService做很多巧妙的事情。使用AccessibilityService主要步骤就是继承AccessibilityServcie服务，实现onAccessibilityEvent方法，配置好相关的内容，最后在AndroidMainfest声明相关配置。知道AccessibilityService怎么使用，最好也了解整个AccessibilityEvent事件流程，以能够对AccessibilityService有整体把握。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/07/20/android-sharedpreferences-sourcecode-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/20/android-sharedpreferences-sourcecode-analysis/" itemprop="url">Android SharedPreferences源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-20T00:00:00+08:00">
                2016-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们经常使用SharedPreferences保存一些简单的数据，比如Settings的数据。如果我们只是简单的使用，可能没什么问题，但是如果要用好它还是得明白它的实现方式，下面来从源码上来分析下SharedPreferences的缓存，异步读写实现，多线程，多进程访问。</p>
<h3 id="SharedPreferences简介"><a href="#SharedPreferences简介" class="headerlink" title="SharedPreferences简介"></a>SharedPreferences简介</h3><p>SharedPreferences是Android提供的一种使用XML文件保存内容的机制。其内部就是通过xml写入文件的。</p>
<p>SharedPreferences是一个接口类，这是使用它的一个基础，我们可以通过Context的getSharedPreference来获取SharedPreferences。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SharedPreferences sp = context.getSharedPreferences(&quot;name&quot;,Context.MODE_PRIVATE);</div></pre></td></tr></table></figure>
<p>第一个参数表示存储的文件名，第二个表示创建文件时的模式。</p>
<p>它提供了getInt, getLong, getFloat,getChar, getString 来读取int, long, float, char, String类型的数据，并且提供了一个Editor接口来用于写入对应的数据类型。Android在API14时又提供了Set<string>类型的数据写入读取。下面看一段简单实用示例：</string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SharedPreferences sp = context.getSharedPreferences(&quot;name&quot;,Context.MODE_PRIVATE);</div><div class="line"></div><div class="line">int val1 = sp.getInt(&quot;val1&quot;,0);</div><div class="line"></div><div class="line">SharedPreferences.Editor editor = sp.edit();</div><div class="line"></div><div class="line">editor.putInt(&quot;val1&quot;, val1+1);</div><div class="line"></div><div class="line">editor.apply();</div><div class="line"></div><div class="line">// editor.commit(); 跟apply方法是一样的，但是apply是异步写入。</div></pre></td></tr></table></figure>
<p>下面就针对上面这段代码流程，分析一下SharedPreferences的源码。</p>
<h3 id="获取SharedPreferences"><a href="#获取SharedPreferences" class="headerlink" title="获取SharedPreferences"></a>获取SharedPreferences</h3><p>我们通过context.getSharedPreferences方法获取SharedPreferences，而Context得真正实现者是ContextImpl，所以看看ContextImpl里面的<code>getSharedPreferences</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line"></div><div class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">   SharedPreferencesImpl sp;</div><div class="line">   synchronized (ContextImpl.class) &#123;</div><div class="line">       if (sSharedPrefs == null) &#123;</div><div class="line">           sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       final String packageName = getPackageName();</div><div class="line">       ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class="line">       if (packagePrefs == null) &#123;</div><div class="line">           packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line">           sSharedPrefs.put(packageName, packagePrefs);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // At least one application in the world actually passes in a null</div><div class="line">       // name.  This happened to work because when we generated the file name</div><div class="line">       // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">       if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">               Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">           if (name == null) &#123;</div><div class="line">               name = &quot;null&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       sp = packagePrefs.get(name);</div><div class="line">       if (sp == null) &#123;</div><div class="line">           File prefsFile = getSharedPrefsFile(name); //根据文件名，获取存储的文件</div><div class="line">           sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">           packagePrefs.put(name, sp);</div><div class="line">           return sp;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">       getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">       // If somebody else (some other process) changed the prefs</div><div class="line">       // file behind our back, we reload it.  This has been the</div><div class="line">       // historical (if undocumented) behavior.</div><div class="line">       sp.startReloadIfChangedUnexpectedly();       //在多进程模式或者目标sdk版本在HONEYCOMB以下版本每次读取缓存了的sp,Android会检查xml文件是否已经被重写了。</div><div class="line">   &#125;</div><div class="line">   return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码首先判断sSharedPrefs是否为空，如果为空则给他初始化。sSharedPrefs是一个用来缓存SharedPreferences的ArrayMap，它的key为包名，它的value为ArrayMap，这个ArrayMap保存的键值对是SharedPreferences文件名和对应的SharedPreferencesImpl（是SharedPreferences的实现类）。如果SharedPreferencesImpl已经存在，它会直接返回已经存在的SharedPreferencesImpl。如果是在多进程模式下，或者目标版本低于HONEYCOMB的时候，会检查是否需要重新从磁盘中加载文件。但是需要说的是MODE_MULTI_PROCESS模式已经被deprecated了，官方建议使用ContentProvider来处理多进程访问，其实我们项目中就遇到这么一个问题导致了一个BUG。</p>
<p>在重新创建SharedPreferencesImpl的时候，getSharedPreferences会调用getSharedPrefsFile来获取存储的xml文件，这个函数对xml文件名进行了组装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">public File getSharedPrefsFile(String name) &#123;</div><div class="line">   return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过getPreferencesDir()来获取shared_prefs目录，然后根据文件名加上xml后缀。Android没有提供直接访问shared_prefs目录的API，getPreferencesDir是一个私有类，我们如果想要直接访问这个目录，可以通过下面这段代码访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">String sharedPrefsDir = context.getCacheDir().getParent().getAbsolutePath()+&quot;/shared_prefs&quot;;</div></pre></td></tr></table></figure>
<h3 id="SharedPreferencesImpl构造函数"><a href="#SharedPreferencesImpl构造函数" class="headerlink" title="SharedPreferencesImpl构造函数"></a>SharedPreferencesImpl构造函数</h3><p>从上面的代码已经知道SharedPreferences具体的实现者是SharedPreferencesImpl。我们都知道Android的SharedPreferences对XML操作是使用DOM方式解析的（一开始就把整个XML给读取出来）。在SharedpreferencesImpl源码中，它的构造函数里面它就把XML文件给读取出来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SharedPreferencesImpl(File file, int mode) &#123;</div><div class="line">   mFile = file;</div><div class="line">   mBackupFile = makeBackupFile(file);</div><div class="line">   mMode = mode;</div><div class="line">   mLoaded = false;</div><div class="line">   mMap = null;</div><div class="line">   startLoadFromDisk();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的构造函数中startLoadFromDisk就是将xml给读取出来的。下面看看startLoadFromDisk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void startLoadFromDisk() &#123;</div><div class="line">   synchronized (this) &#123;</div><div class="line">       mLoaded = false;</div><div class="line">   &#125;</div><div class="line">   new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</div><div class="line">       public void run() &#123;</div><div class="line">           synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">               loadFromDiskLocked();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它使用了一个异步线程来读取xml，最终实现的函数是loadFromDiskLocked()，在读取的时候它必须获取SharedPreferencesImpl.this的锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void loadFromDiskLocked() &#123;</div><div class="line">...</div><div class="line">   Map map = null;</div><div class="line">   StructStat stat = null;</div><div class="line">   try &#123;</div><div class="line">       stat = Os.stat(mFile.getPath());</div><div class="line">       if (mFile.canRead()) &#123;</div><div class="line">           BufferedInputStream str = null;</div><div class="line">           try &#123;</div><div class="line">               str = new BufferedInputStream(</div><div class="line">                       new FileInputStream(mFile), 16*1024);</div><div class="line">               map = XmlUtils.readMapXml(str);</div><div class="line">...</div><div class="line"></div><div class="line">  mLoaded = true;</div><div class="line">  if (map != null) &#123;</div><div class="line">      mMap = map;</div><div class="line">      mStatTimestamp = stat.st_mtime;</div><div class="line">      mStatSize = stat.st_size;</div><div class="line">  &#125; else &#123;</div><div class="line">      mMap = new HashMap&lt;String, Object&gt;();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个函数里面省略了一些代码，想看全部的，可以直接去SharedPreferencesImpl文件看。这个函数最终调用了XmlUtils.readMapXml来调用，读取整个xml的内容，放到mMap当中。</p>
<h3 id="读取key对应的值"><a href="#读取key对应的值" class="headerlink" title="读取key对应的值"></a>读取key对应的值</h3><p>SharedPreferencesImpl的读取是非常简单的，因为在构造函数当中就已经读取整个xml文件的内容到mMap当中了，所以再次读取的时候直接从mMap当中读取就好了，但是得注意同步的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public int getInt(String key, int defValue) &#123;</div><div class="line">   synchronized (this) &#123;</div><div class="line">       awaitLoadedLocked();</div><div class="line">       Integer v = (Integer)mMap.get(key);</div><div class="line">       return v != null ? v : defValue;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数awaitLoadedLocked就是等待读取文件完成。因为如果读取具体元素的时候，读取文件线程却没有完成，那么必须等待文件读取完成，不然结果肯定会乱。</p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>SharedPreferences的写入是通过Editor来实现的，Editor接口在SharedPreferencesImpl具体实现是EditorImpl，在这看看它的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final class EditorImpl implements Editor &#123;</div><div class="line">   private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();</div><div class="line">   private boolean mClear = false;</div><div class="line"></div><div class="line"></div><div class="line">   public Editor putInt(String key, int value) &#123;</div><div class="line">       synchronized (this) &#123;</div><div class="line">           mModified.put(key, value);</div><div class="line">           return this;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   //... 省略了其他类型的value操作，和clear，remove函数。</div><div class="line"></div><div class="line"></div><div class="line">   public void apply() &#123;</div><div class="line">       final MemoryCommitResult mcr = commitToMemory();</div><div class="line">       final Runnable awaitCommit = new Runnable() &#123;</div><div class="line">               public void run() &#123;</div><div class="line">                   try &#123;</div><div class="line">                       mcr.writtenToDiskLatch.await();</div><div class="line">                   &#125; catch (InterruptedException ignored) &#123;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line"></div><div class="line">       QueuedWork.add(awaitCommit);</div><div class="line"></div><div class="line">       Runnable postWriteRunnable = new Runnable() &#123;</div><div class="line">               public void run() &#123;</div><div class="line">                   awaitCommit.run();</div><div class="line">                   QueuedWork.remove(awaitCommit);</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line"></div><div class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // enqueueDiskWrite会调用异步线程执行postWriteRunnable。</div><div class="line"></div><div class="line">       // Okay to notify the listeners before it&apos;s hit disk</div><div class="line">       // because the listeners should always get the same</div><div class="line">       // SharedPreferences instance back, which has the</div><div class="line">       // changes reflected in memory.</div><div class="line">       notifyListeners(mcr);</div><div class="line">   &#125;</div><div class="line">....省略了commitToMemory</div><div class="line">   public boolean commit() &#123;</div><div class="line">       MemoryCommitResult mcr = commitToMemory();</div><div class="line">       SharedPreferencesImpl.this.enqueueDiskWrite(</div><div class="line">           mcr, null /* sync write on this thread okay */); //第二个参数为null，enqueueDiskWrite会直接写入。</div><div class="line">       try &#123;</div><div class="line">           mcr.writtenToDiskLatch.await();</div><div class="line">       &#125; catch (InterruptedException e) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line">       notifyListeners(mcr);</div><div class="line">       return mcr.writeToDiskResult;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">... 省略了notifyListeners</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码上面可以看出，首先使用put写入的时候，只是写入到一个mModified里面，但是实际上还没写入SharedPreferencesImpl的mMap当中，更没有写入磁盘，只有当调用commit或者apply函数的时候才会开始写入。而apply是异步写入，而commit是在当前线程直接写入。commit在enqueueDiskWrite的第二个参数传入null，看看enqueueDiskWrite的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                             final Runnable postWriteRunnable) &#123;</div><div class="line">   final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">           public void run() &#123;</div><div class="line">               synchronized (mWritingToDiskLock) &#123;</div><div class="line">                   writeToFile(mcr);</div><div class="line">               &#125;</div><div class="line">               synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                   mDiskWritesInFlight--;</div><div class="line">               &#125;</div><div class="line">               if (postWriteRunnable != null) &#123;</div><div class="line">                   postWriteRunnable.run();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">   final boolean isFromSyncCommit = (postWriteRunnable == null); //如果postWriteRunnable就同步写入</div><div class="line"></div><div class="line">   // Typical #commit() path with fewer allocations, doing a write on</div><div class="line">   // the current thread.</div><div class="line">   if (isFromSyncCommit) &#123;</div><div class="line">       boolean wasEmpty = false;</div><div class="line">       synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">           wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">       &#125;</div><div class="line">       if (wasEmpty) &#123;</div><div class="line">           writeToDiskRunnable.run();</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是需要指出的是，两种方式首先都会先使用commitTomemory函数将修改的内容写入到SharedPreferencesImpl当中。看看commitToMemory的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private MemoryCommitResult commitToMemory() &#123;</div><div class="line">   MemoryCommitResult mcr = new MemoryCommitResult();</div><div class="line">   synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">       // We optimistically don&apos;t make a deep copy until</div><div class="line">       // a memory commit comes in when we&apos;re already</div><div class="line">       // writing to disk.</div><div class="line">       if (mDiskWritesInFlight &gt; 0) &#123;</div><div class="line">           // We can&apos;t modify our mMap as a currently</div><div class="line">           // in-flight write owns it.  Clone it before</div><div class="line">           // modifying it.</div><div class="line">           // noinspection unchecked</div><div class="line">           mMap = new HashMap&lt;String, Object&gt;(mMap);</div><div class="line">       &#125;</div><div class="line">       mcr.mapToWriteToDisk = mMap;</div><div class="line">       mDiskWritesInFlight++;</div><div class="line"></div><div class="line">       boolean hasListeners = mListeners.size() &gt; 0;</div><div class="line">       if (hasListeners) &#123;</div><div class="line">           mcr.keysModified = new ArrayList&lt;String&gt;();</div><div class="line">           mcr.listeners =</div><div class="line">                   new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       synchronized (this) &#123;</div><div class="line">           if (mClear) &#123;</div><div class="line">               if (!mMap.isEmpty()) &#123;</div><div class="line">                   mcr.changesMade = true;</div><div class="line">                   mMap.clear();</div><div class="line">               &#125;</div><div class="line">               mClear = false;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;  // 在这开始将修改的内容写入到mMap当中。</div><div class="line">               String k = e.getKey();</div><div class="line">               Object v = e.getValue();</div><div class="line">               // &quot;this&quot; is the magic value for a removal mutation. In addition,</div><div class="line">               // setting a value to &quot;null&quot; for a given key is specified to be</div><div class="line">               // equivalent to calling remove on that key.</div><div class="line">               if (v == this || v == null) &#123;</div><div class="line">                   if (!mMap.containsKey(k)) &#123;</div><div class="line">                       continue;</div><div class="line">                   &#125;</div><div class="line">                   mMap.remove(k);</div><div class="line">               &#125; else &#123;</div><div class="line">                   if (mMap.containsKey(k)) &#123;</div><div class="line">                       Object existingValue = mMap.get(k);</div><div class="line">                       if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;</div><div class="line">                           continue;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   mMap.put(k, v);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               mcr.changesMade = true;</div><div class="line">               if (hasListeners) &#123;</div><div class="line">                   mcr.keysModified.add(k);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           mModified.clear();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   return mcr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通知修改的变化"><a href="#通知修改的变化" class="headerlink" title="通知修改的变化"></a>通知修改的变化</h3><p>我们可以通过下面两个函数注册监视xml文件变化的通知，在这里我直接把函数源码给顺便贴出来了，因为比较简短：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) &#123;</div><div class="line">   synchronized(this) &#123;</div><div class="line">       mListeners.put(listener, mContent);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) &#123;</div><div class="line">   synchronized(this) &#123;</div><div class="line">       mListeners.remove(listener);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在前面分析了的函数commitToMemory中会返回修改的内容保存在MemoryCommitResult当中，然后使用使用notifyListener函数通知监听者。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SharedPreferences从功能上面来讲就是三个部分读取（一开始异步全部读取出来，get的时候，如果没有读取完，会等待），写入，监听SharedPreferences的变化。另外Android会使用ArrayMap对SharedPreferences进行缓存，以SharedPreferences的name作为key。需要进一步理解的是关于多线程，多进程时的使用。</p>
<p>首先从线程方面来看，从源码上看apply是使用异步线程写入磁盘，commit是同步写入磁盘。所以我们在主线程使用的commit的时候，需要考虑是否会出现ANR问题。我们不用担心apply异步写入会出现先写入的内容，在该线程之后读取会读取不到，因为它写入内存的时候没有使用异步线程，所以在主线程最好使用apply。所有的线程读取的时候都会加SharedPreferencesImpl.this锁，editor写入内存的时候（写入SharedPreferencesImpl.this.mMap）也会加SharedPreferencesImpl.this锁，另外editor调用put，clear, remove方法的时候都会加上EditorImpl.this锁，这些是线程安全的保证，只有在commit/apply后才会写入内存（mMap, xml内容缓存的map变量）和磁盘。</p>
<p>另外从多进程方面来看，SharedPreferences本身提供了MODE_MULTI_PROCESS的模式，但是现在已经deprecated了，不建议使用。MODE_MULTI_PROCESS也仅仅是每次读取缓存的SharedPreferencesImpl时重写读取一次磁盘（其实效率很低，而且从源码看，并不能很好地保持同步）。所以Android建议使用ContentProvider来保持多进程的访问。有人已经实现了，可以通过google搜索multi process sharedpreferences找到，因为我没看过那些，所以自己搜吧，我是直接看的公司的。</p>
<hr>
<p>理解，分析</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/06/23/android-sourcecode-visitor-htmldocument/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/23/android-sourcecode-visitor-htmldocument/" itemprop="url">Android源码访问者模式---HtmlDocument</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-23T00:00:00+08:00">
                2016-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>访问者模式是设计模式中相对比较复杂的设计模式，在Android源码中的UnifiedEmail项目中的HtmlDocument就使用了访问者模式，Email中的内容可以是Html文档，而Html文档需要解析保存，HtmlDocument就是html节点的一个容器，本文将介绍HtmlDocument与访问者模式。文中对访问者模式介绍的会相对简单，如果想理解好，建议去看一下Gof的描述，更侧重于与Android源码的结合（源码基于6.0.1_r30）。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>首先看一下访问者模式相关内容。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>表示一个作用于对象内部结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="http://houzhi.me/photo/uploads/big/708fc91d287fc3f86d78c9b843b4e131.png" alt="http://houzhi.me/photo/uploads/big/708fc91d287fc3f86d78c9b843b4e131.png"></p>
<p>上面就是访问者模式的简单UML图，通过定义一个外在的Visitor来访问ObjectStructor对象结构中的Element，这样可以变化访问者来访问对象结构中的元素，但又不会影响元素内部结构。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">abstract class Visitor&#123;</div><div class="line">      public abstract void visitorElement1(ConcreteElement1 element);</div><div class="line">      public abstract void visitorElement2(ConcreteElement2 element);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteVisitor1 extends Visitor&#123; </div><div class="line">      public abstract void visitorElement1(ConcreteElement1 element)&#123;</div><div class="line">           element.operate1();</div><div class="line">           // do other things.</div><div class="line">      &#125;</div><div class="line">      public abstract void visitorElement2(ConcreteElement2 element)&#123;</div><div class="line">           element.operate2();</div><div class="line">           // do other things.</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Element&#123;</div><div class="line">    public abstract void accept(Visitor visitor);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteElement1 extends Element&#123;</div><div class="line">    public void accept(Visitor visitor)&#123;</div><div class="line">        visitor.visitorElement1(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ConcreteElement2 extends Element&#123;</div><div class="line">    public void accept(Visitor visitor)&#123;</div><div class="line">        visitor.visitorElement2(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ObjectStructor&#123;</div><div class="line">    List&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();</div><div class="line"></div><div class="line">    elements.add(new ConcreteElement1());</div><div class="line">    elements.add(new ConcreteElement2());</div><div class="line"></div><div class="line">    public void accept(Visitor visitor)&#123;</div><div class="line">        for(Element element: elements)&#123;</div><div class="line">             element.accept(visitor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String [] args)&#123;</div><div class="line">         ConcreteVisitor1 visitor = new ConcreteVisitor1();</div><div class="line">         ObjectStructor stru = new ObjectStructor();</div><div class="line">         stru.accept(visitor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是一段简单的访问者模式的代码，访问者模式有几个特点：对象结构内部的元素不会变化，如果变化了，那么Visitor又得变了；对象结构内部元素有不同的接口；需要对对象内部元素有不同的不相关访问，而放在元素内部，又会”污染“元素。</p>
<h3 id="UnifiedEmail-中的HtmlDocument"><a href="#UnifiedEmail-中的HtmlDocument" class="headerlink" title="UnifiedEmail 中的HtmlDocument"></a>UnifiedEmail 中的HtmlDocument</h3><p><img src="http://houzhi.me/photo/uploads/big/e0c184b635d5991bfba5146e5aadd843.png" alt="http://houzhi.me/photo/uploads/big/e0c184b635d5991bfba5146e5aadd843.png"></p>
<p>上面就是整个HtmlDocument的观察者UML图，它是一个非常经典的观察者模式。HtmlDocument表示html文档，里面包含了Html的组成内容，它包含了Comment(注释)，Text(文本)，Tag(标签)，EndTag(结束标签)这些元素。</p>
<h3 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h3><p>所有的类都在UnifiedEmail项目的com.google.android.mail.common.html.parser包中。</p>
<h4 id="HtmlDocument"><a href="#HtmlDocument" class="headerlink" title="HtmlDocument"></a>HtmlDocument</h4><p>表示Html文档，它是Html节点的容器，包含了一个<code>List&lt;Node&gt; node</code>属性，这个属性就是包含了html的所有节点。另外它也包含了一些将html转换为String的接口:</p>
<ul>
<li>toHTML</li>
<li>toXHTML</li>
<li>toOriginalHTML</li>
</ul>
<p>它是Node元素的容器，访问者就是直接与HtmlDocument打交道。另外HtmlDocument是一个非常大的类，Node, Comment, Text, Tag, EndTag, Visitor都是HtmlDocument的静态内部类。并且它还包含了Comment，Text，Tag的静态创建方法。</p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>观察者基类，它有几个实现者:</p>
<ul>
<li>Builder: 这个是用来创建HtmlDocument的</li>
<li>HtmlTreeBuilder: 这个类是用来创建HtmlTree的，通过访问所有的节点元素，创建一个HtmlTree。</li>
<li>DebugPrinter: 这个使用来调试的，只是打印了节点元素的内容。</li>
<li>VisitorWrapper：　这是一个Visitor的装饰类。</li>
</ul>
<p>通过变化访问者（或创建新的访问者）来操作HtmlDocument的节点元素，而不是直接修改HtmlDocument节点元素，这样避免了修改节点元素内部内容。</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>基础的节点元素类，它是所有节点元素的父类，表示Html文档中的相关节点元素（标签，文本，注释等等）。在HtmlDocument中保存在一个List列表里面。</p>
<h4 id="HtmlTreeBuilder"><a href="#HtmlTreeBuilder" class="headerlink" title="HtmlTreeBuilder"></a>HtmlTreeBuilder</h4><p>HtmlTreeBuilder是一个访问者，HtmlTreeBuilder的作用是通过访问HtmlDocument中的节点来创建HtmlTree。HtmlTree是一个表示解析好了的，有较好的格式化了的html文本的对象。它提供了方法直接将html转换为文本，并且提供了查找文本标签的方法，比HtmlDocument格式化要更好些。</p>
<p>在HtmlTreeBuilder中有一段对节点元素的访问测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/** For testing */</div><div class="line">public static void main(String[] args) throws IOException &#123;</div><div class="line">  logger.setLevel(Level.FINEST);</div><div class="line"></div><div class="line">  String html = new String(ByteStreams.toByteArray(System.in));</div><div class="line">  HtmlParser parser = new HtmlParser();</div><div class="line">  HtmlDocument doc = parser.parse(html);</div><div class="line"></div><div class="line">  HtmlTreeBuilder builder = new HtmlTreeBuilder();</div><div class="line">  doc.accept(builder);</div><div class="line">  String outputHtml = builder.getTree().getHtml();</div><div class="line"></div><div class="line">  System.out.println(outputHtml);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HtmlParser"><a href="#HtmlParser" class="headerlink" title="HtmlParser"></a>HtmlParser</h4><p>在com.google.android.mail.common.html.parser包里面还有HtmlParser类，它是用来解析Html文档的，把Html文档文本解析为HtmlDocument。</p>
<h3 id="设计思考"><a href="#设计思考" class="headerlink" title="设计思考"></a>设计思考</h3><p>访问者模式适合结构对象中的元素不会经常变化，每个元素的接口又不会很一致，但是需要对针对每一种元素进行操作，而对这些元素又经常需要变化操作。而Html的节点就很适合这些特征，每个节点元素的接口其实是不一致的，但是他们总共也就那几种元素（Comment, Tag, EndTag,Text)，而有时候又需要添加一些新的操作。</p>
<p>如果说元素之间的接口都是一致的话，那么可以直接使用迭代器模式，迭代器模式代码结构更加简单。如果经常需要增加新的节点类型，那么对节点操作最好直接放在节点内部，因为增加新的节点类型，意味着访问者也要增加一种新的接口。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在UnifiedEmail中还有其他的使用了访问者模式的，比如<code>org.apache.james.mime4j.field.address.parser.AddressListParserVisitor</code>，<code>com.android.mail.utils.DequeMap.Visitor</code>。通过具体使用的源码来学习设计模式会更加有效率，当然最好是自己在实践中使用，通过设计模式来看代码结构会更加明朗，清晰，也能更好地看细节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/06/19/android-bitmap-introduce-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/19/android-bitmap-introduce-3/" itemprop="url">Android Bitmap深入介绍（三）--- 开源加载框架简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-19T00:00:00+08:00">
                2016-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="流行框架"><a href="#流行框架" class="headerlink" title="流行框架"></a>流行框架</h3><p>目前使用非常广泛的框架技术主要有Android Universal Image Loader，Picasso, Glide和Fresco，最开始出现的应该算是UIL(Universal Image Loader)，记得刚开始用图片加载框架的时候，主要就是使用UIL，UIL功能丰富。Picasso是Square搞出来的，Glide与Picasso比较类似，Google推荐Glide，Fresco是Facebook推出的一个图片加载库，这个库非常值得一看，里面有很多很有特色的地方,非常强大的一个开源库。除此之外Volley也是一个很好的图片加载框架，非常轻量。</p>
<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>这些框架基本都可以分成这么几个部分：执行引擎（Engine，或者说调度中心），请求生成部分，缓存部分，图片处理部分，图片显示部分。这基本涵盖了图片从网络或本地获取过来，显示给用户的整个流程。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>关于他们之间的比较，可以参考Trinea的文章<a href="http://www.trinea.cn/android/android-image-cache-compare/" target="_blank" rel="external">Android 三大图片缓存原理、特性对比</a>，下面简单介绍一下他们的优缺点：</p>
<ul>
<li><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">Android-Universal-Image-Loader</a>: 是最早的图片加载库，应用也最广泛，功能非常丰富。它支持下载监听，提供了很多缓存算法，可以在滚动中暂停加载</li>
<li><a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a>:<br>Square推出的开源库，它支持图片缓存监控，按照优先级来加载图片</li>
<li><a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a><br>Google推荐的图片加载开源库，支持gif（利用的是第三方包），webp，缩略图，video。提供了接口让用户使用自己需要的网络协议栈。另外一方面，Glide可以与Activity/Fragment的周期保持一致，并且提供了trimMemory供使用。</li>
<li><a href="https://github.com/facebook/fresco" target="_blank" rel="external">Fresco</a><br>facebook 推出的图片加载开源库，功能非常强大。主要有内存管理，渐进式加载，webp格式，gif，pipeline加载。</li>
</ul>
<h3 id="相关源码分析文章"><a href="#相关源码分析文章" class="headerlink" title="相关源码分析文章"></a>相关源码分析文章</h3><p>网络上面关于这些图片开源框架的源码分析还是挺多的，不过这些源码分析一般都仅供参考辅助，如果自己需要了解这些源码的内容，最好自己亲自去看看源码。</p>
<p>Android-Universal-Image-Loader: <a href="http://a.codekk.com/detail/Android/huxian99/Android%20Universal%20Image%20Loader%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="external">Android Universal Image Loader 源码分析</a></p>
<p>Picasso: <a href="http://blog.happyhls.me/category/android/picasso/" target="_blank" rel="external">http://blog.happyhls.me/category/android/picasso/</a><br><a href="http://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">http://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</a></p>
<p>Glide: <a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="external">Android Glide源码解析</a></p>
<p>Fresco: <a href="https://github.com/desmond1121/Fresco-Source-Analysis" target="_blank" rel="external">Fresco-Source-Analysis</a></p>
<h3 id="相关特性"><a href="#相关特性" class="headerlink" title="相关特性"></a>相关特性</h3><h4 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h4><p>目前Glide和Fresco都支持gif。对于gif，Fresco的处理跟我们对gif的理解是一致的，先将gif的所有帧解码出来，然后使用动画一帧一帧地放。具体是通过变化Drawable的绘制，每次绘制的时候，绘制对应的一帧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private boolean renderFrame(</div><div class="line">    Canvas canvas,</div><div class="line">    int frameNumber,</div><div class="line">    int frameMonotonicNumber) &#123;</div><div class="line">  CloseableReference&lt;Bitmap&gt; bitmapReference =</div><div class="line">      mAnimatedDrawableBackend.getBitmapForFrame(frameNumber);</div><div class="line">  if (bitmapReference != null) &#123;</div><div class="line">    canvas.drawBitmap(bitmapReference.get(), 0f, 0f, mPaint);</div><div class="line">    if (mLastDrawnFrame != null) &#123;</div><div class="line">      mLastDrawnFrame.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mIsRunning &amp;&amp; frameMonotonicNumber &gt; mLastDrawnFrameMonotonicNumber) &#123;</div><div class="line">      int droppedFrames = frameMonotonicNumber - mLastDrawnFrameMonotonicNumber - 1;</div><div class="line">      mAnimatedDrawableDiagnostics.incrementDrawnFrames(1);</div><div class="line">      mAnimatedDrawableDiagnostics.incrementDroppedFrames(droppedFrames);</div><div class="line">      if (droppedFrames &gt; 0) &#123;</div><div class="line">        FLog.v(TAG, &quot;(%s) Dropped %d frames&quot;, mLogId, droppedFrames);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    mLastDrawnFrame = bitmapReference;</div><div class="line">    mLastDrawnFrameNumber = frameNumber;</div><div class="line">    mLastDrawnFrameMonotonicNumber = frameMonotonicNumber;</div><div class="line">    FLog.v(TAG, &quot;(%s) Drew frame %d&quot;, mLogId, frameNumber);</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h4><p><a href="https://developers.google.com/speed/webp/" target="_blank" rel="external">WebP</a>是google推出的一种新的影像形式，他可以对图片进行有效地压缩又不影响图片的兼容性和实际清晰度，提高图片下载速度，在相同质量它压缩后的体积大概是jpg的40%。但是编码时间大概比jpg的长8倍。目前Facebook跟QQ空间都有使用WebP图片。</p>
<h4 id="渐进加载"><a href="#渐进加载" class="headerlink" title="渐进加载"></a>渐进加载</h4><p>这个是Fresco提供的功能，目前只支持jpg网络图片。可以在下图片的时候，让图片逐渐地由模糊变清晰渐渐地显示出来。jpeg格式的图片有两种方式，一种是直接编码的，另外一种是渐进式编码的，能够用于Fresco渐进加载的是要通过渐进式编码的jpeg图片。<a href="http://baike.baidu.com/view/7679.htm#5" target="_blank" rel="external">压缩标准</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/06/13/android-bitmap-introduce-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/13/android-bitmap-introduce-2/" itemprop="url">Android Bitmap深入介绍（二）--- 优化技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-13T00:00:00+08:00">
                2016-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇主要介绍Bitmap相关的一些优化技术，包括加载图片，图片内存管理,图片缓存。</p>
<h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><h4 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h4><p>我们在加载图片的时候，经常会遇到OOM的问题，也许我们测试的时候图片比较小，但是实际上使用的图片可能</p>
<p>会很大，我最好的方式就是在加载的时候就把图片缩小。Options提供了inJustDecodeBounds来先获取图片的大小，</p>
<p>如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line"></div><div class="line">options.inJustDecodeBounds = true;</div><div class="line"></div><div class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</div><div class="line"></div><div class="line">int imageHeight = options.outHeight;</div><div class="line"></div><div class="line">int imageWidth = options.outWidth;</div><div class="line"></div><div class="line">String imageType = options.outMimeType; // 图片的mimeType</div></pre></td></tr></table></figure>
<p>options.outHeight和options.outWidth会获取图片的宽和高，通过获取到图片的宽和高，就可以使用options的inSample来缩放图片，</p>
<p>在加载图片显示到屏幕的时候，我们最好跟屏幕的密度一致，所以可以通过inSample来设置最终要缩放到多少，另外一方面我们有时候只需要缩略图，也需要进行缩放。下面是Android提供的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int calculateInSampleSize(BitmapFactory.Options options,  int reqWidth, int reqHeight)&#123;</div><div class="line"></div><div class="line">    final int height = options.outHeight;</div><div class="line"></div><div class="line">    final int width  = options.outWidth;</div><div class="line"></div><div class="line">    int inSampleSize = 1 ;</div><div class="line"></div><div class="line">    if(reqWidth &lt; width || reqHeight &lt;height)&#123;</div><div class="line"></div><div class="line">        final int halfWidth = width / 2;</div><div class="line"></div><div class="line">        final int halfHeight = height / 2;</div><div class="line"></div><div class="line">           // Calculate the largest inSampleSize value that is a power of 2 and keeps both        // height and width larger than the requested height and width.   </div><div class="line"></div><div class="line">        while( (halfWidth / inSampleSize &gt; reqWidth &amp;&amp; halfHeight / inSampleSize &gt; reqHeight)&#123;</div><div class="line"></div><div class="line">            inSampleSize *= 2;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这个方法得到inSampleSize，然后通过将options的inJustDecodeBounds设置为false就可以利用BitmapFactory加载图片了，得到的图片是经过缩放了的。</p>
<h4 id="Bitmap-Config"><a href="#Bitmap-Config" class="headerlink" title="Bitmap.Config"></a>Bitmap.Config</h4><p>除了根据屏幕的情况，图片在屏幕中显示的大小来缩放图片，另外也可以通过options的inPreferredConfig设置图片的Config，使用RGB_565的图片肯定比RGB_8888占用的内存要小的。</p>
<h4 id="PNG-or-JPG"><a href="#PNG-or-JPG" class="headerlink" title="PNG or JPG"></a>PNG or JPG</h4><p>另外还需要考虑的一个问题是图片的格式，使用png图片还是jpg图片，jpg压缩率要高意味着解码的时候消耗的时间肯能会更高，它没有alpha通道，但是对于内置在apk里面的图片，如果图片小，那么apk的大小也会变小。另外如果图片的色值丰富的话，用可能有好点，色值单调可能用png好点（比如我们的icon）。</p>
<h3 id="图片内存管理"><a href="#图片内存管理" class="headerlink" title="图片内存管理"></a>图片内存管理</h3><p>在前面一篇有介绍过Android中图片的存储相关知识，在Android 2.3以及之前图片会存储在native内存中，Android推荐在Bitmap不再使用的时候，使用recycle方法回收Bitmap，因为图片存储在native内存当中，所以需要手动回收，另外也可以使用引用计数的方式在Bitmap的计数为0时，调用Bitmap的recycle方法。</p>
<p>下面是<a href="https://developer.android.com/training/displaying-bitmaps/manage-memory.html#recycle" target="_blank" rel="external">Android提供的一段引用计数的代码</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private int mCacheRefCount = 0;</div><div class="line">private int mDisplayRefCount = 0;</div><div class="line">...</div><div class="line">// Notify the drawable that the displayed state has changed.</div><div class="line">// Keep a count to determine when the drawable is no longer displayed.</div><div class="line">public void setIsDisplayed(boolean isDisplayed) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (isDisplayed) &#123;</div><div class="line">            mDisplayRefCount++;</div><div class="line">            mHasBeenDisplayed = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            mDisplayRefCount--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Check to see if recycle() can be called.</div><div class="line">    checkState();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Notify the drawable that the cache state has changed.</div><div class="line">// Keep a count to determine when the drawable is no longer being cached.</div><div class="line">public void setIsCached(boolean isCached) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (isCached) &#123;</div><div class="line">            mCacheRefCount++;</div><div class="line">        &#125; else &#123;</div><div class="line">            mCacheRefCount--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // Check to see if recycle() can be called.</div><div class="line">    checkState();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private synchronized void checkState() &#123;</div><div class="line">    // If the drawable cache and display ref counts = 0, and this drawable</div><div class="line">    // has been displayed, then recycle.</div><div class="line">    if (mCacheRefCount &lt;= 0 &amp;&amp; mDisplayRefCount &lt;= 0 &amp;&amp; mHasBeenDisplayed</div><div class="line">            &amp;&amp; hasValidBitmap()) &#123;</div><div class="line">        getBitmap().recycle();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private synchronized boolean hasValidBitmap() &#123;</div><div class="line">    Bitmap bitmap = getBitmap();</div><div class="line">    return bitmap != null &amp;&amp; !bitmap.isRecycled();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一方面也可以考虑使用inPurgeable，inPurgeable让Android在需要的时候可以回收像素，减少OOM。需要重新绘制的时候，又重新解码。其实这会导致更多的计算消耗。</p>
<p>在3.0之后开始放到Java层内存中，在3.0之后也增加了inBitmap。inBitmap的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Bitmap inBitmap ; //已经使用了的Bitmap</div><div class="line"></div><div class="line">BitmapFactory.Options optiosn = new BitmapFactory.Options();</div><div class="line"></div><div class="line">options.inBitmap = inBitmap ;</div><div class="line"></div><div class="line">Bitmap newBitmap = BitmapFactory.Options.decodeFile(filename, options);</div></pre></td></tr></table></figure>
<p>需要注意的时候在4.4之前不支持不同大小的图片使用inBitmap，4.4才开始支持不同的大小，只要inBitmap比需要新加载的图片更大。另外inBitmap其实可以与下一节介绍的缓存一起使用，可以使用缓存了的图片作为inBitmap来加载新的图片。<a href="https://developer.android.com/training/displaying-bitmaps/manage-memory.html#inBitmap" target="_blank" rel="external">这里</a>也有例子。</p>
<h3 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h3><p>如果都是每次使用BitmapFactory从sdcard读取Bitmap，那么将会非常浪费时间，因为从磁盘读取图片是非常慢的，而且有的图片需要经常使用，如果把图片缓存在内存当中将能够很好地节省图片读取的时间。这样图片缓存就出现了。</p>
<h4 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h4><p>LruCache是一个非常适合缓存图片的类，它是基于LinkedHashMap实现的。把最近经常使用的对象保存在LinkedHashMap里面，把最近没使用的从LinkedHashMap中移除。LinkedHashMap是一个LinkedList和HashMap一起实现的。需要注意一点的是在以前经常使用SoftReference或WeakReference来引用Bitmap来缓存，但是在2.3后，Android虚拟机的垃圾回收机制回收Soft和Weak引用更加积极了，也就是说它会很快就回收软引用和弱引用对象。</p>
<p>Android可以通过Runtime.getRuntime().getMaxMemory()获取最大内存，Android提供了一段小代码来使用LruCache:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Get max available VM memory, exceeding this amount will throw an</div><div class="line">// OutOfMemory exception. Stored in kilobytes as LruCache takes an</div><div class="line">// int in its constructor.</div><div class="line">final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">// Use 1/8th of the available memory for this memory cache.</div><div class="line">final int cacheSize = maxMemory / 8;</div><div class="line"></div><div class="line">mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</div><div class="line">    @Override</div><div class="line">    protected int sizeOf(String key, Bitmap bitmap) &#123;</div><div class="line">        // The cache size will be measured in kilobytes rather than</div><div class="line">        // number of items.</div><div class="line">        return bitmap.getByteCount() / 1024;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h4><p>我们的图片可能是从网络中下载下来的，但是我们的应用中可能也没办法把图片全部放进内存，我们需要把图片保存在Disk中，另外一方面我们也不想要每次都从网络中下载图片。LruDiskCache就提供了一种磁盘缓存。当然如果图片访问非常频繁，使用ContentProvider的话将会更好。</p>
<h4 id="Ashmem"><a href="#Ashmem" class="headerlink" title="Ashmem"></a>Ashmem</h4><p>除了一般的缓存方式，强大的Fresco在5.0之前利用ashmem来缓存图片，将图片保存在ashmem当中，这样就不会占用太多Java堆内存而导致出现OOM的情况。下面是一段简单的将图片存在ashmem中并且读取出来的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   private void testBitmapMemoryFile()&#123;</div><div class="line">//        Log.i(LOGTAG,&quot;&quot;+bitmap.getConfig().name());</div><div class="line">       InputStream is = getResources().openRawResource(R.raw.test4);</div><div class="line">       byte[] imgArr = new byte[10 * 1024 * 1024];</div><div class="line">       int imgBytes = 0;</div><div class="line">       try &#123;</div><div class="line">           while (is.available() &gt; 0) &#123;</div><div class="line">               int bytes = is.read(imgArr, imgBytes, 1024);</div><div class="line">               imgBytes += bytes;</div><div class="line">               Log.i(LOGTAG, &quot;bytes read:&quot; + bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            is.close();</div><div class="line">            Log.i(LOGTAG, &quot;bytes : &quot; + imgBytes);</div><div class="line">     ﻿      memoryFile = new MemoryFile(null, imgBytes);</div><div class="line">            OutputStream os = memoryFile.getOutputStream();</div><div class="line">    ﻿       os.write(imgArr, 0, imgBytes);</div><div class="line">            imgArr = null;</div><div class="line">            os.flush();</div><div class="line">    ﻿       os.close();</div><div class="line">    ﻿       </div><div class="line">            BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">            options.inPurgeable = true;</div><div class="line">            fd = getMemoryFileFd(memoryFile,null,options);</div><div class="line">            </div><div class="line">            if (fd == null) &#123;</div><div class="line">               memoryFile.close();</div><div class="line">               Log.e(LOGTAG, &quot;fd read error&quot;);</div><div class="line">               return;</div><div class="line">            &#125;</div><div class="line">            Log.i(LOGTAG, &quot;fd read ok&quot;);</div><div class="line">            bitmap =  BitmapFactory.decodeFileDescriptor(fd);</div><div class="line"></div><div class="line">            iv.setImageBitmap(bitmap);</div><div class="line">            memoryFile.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面的代码是将一张raw目录下面的图片保存到AshmemFile当中，然后再利用BitmapFactory读取图片。并且使用inPurgeable标志。AshmemFile和inPurgeable合起来使用。</p>
<h4 id="配置改变时缓存"><a href="#配置改变时缓存" class="headerlink" title="配置改变时缓存"></a>配置改变时缓存</h4><p>Activity可能会经常遇到旋转屏幕的情况，会被重新加载，另外在跳转的时候也可能会被finish掉，返回来又得重新加载。这种时候如果对于已经加载了的东西都全部重新加载那会非常耗费时间，这种时候保存Cache，不重新加载将会是一个非常的方式，比如在Fragment中使用了Cache，可以使用setRetainInstance(true)，避免重新创建Fragment，这样也能避免加载Fragment中的Cache。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要介绍了图片加载过程中的相关配置，比如利用Options的参数配置输出图片的大小，Bitmap.Config配置解码图片像素格式，以及如何使用PNG和JPG图片。另外介绍了图片缓存（LRUCache和AshmemFile）以及图片存储管理。</p>
<hr>
<p>参考</p>
<ol>
<li><a href="https://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">https://developer.android.com/training/displaying-bitmaps/index.html</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=0&amp;key=41ecb04b051110037b72d05bba1495f596e848534fc51afe877d63329a16dc24dc1d3606aaaba3745a05bfdb8c624a74&amp;ascene=0&amp;uin=Mjc3OTU3Nzk1&amp;devicetype=iMac+MacBookPro10%2C1+OSX+OSX+10.10.5+build%2814F27%29&amp;version=11020201&amp;pass_ticket=kK4%2F6316QveG8O0vFtthPfBeKkNjyaL4HapsUAokHL5mUKCgI5hKTIKMc3D8uyqk" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=0&amp;key=41ecb04b051110037b72d05bba1495f596e848534fc51afe877d63329a16dc24dc1d3606aaaba3745a05bfdb8c624a74&amp;ascene=0&amp;uin=Mjc3OTU3Nzk1&amp;devicetype=iMac+MacBookPro10%2C1+OSX+OSX+10.10.5+build%2814F27%29&amp;version=11020201&amp;pass_ticket=kK4%2F6316QveG8O0vFtthPfBeKkNjyaL4HapsUAokHL5mUKCgI5hKTIKMc3D8uyqk</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://houzhi.me/2016/06/07/android-bitmap-introduce-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="houzhi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinker">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/07/android-bitmap-introduce-1/" itemprop="url">Android Bitmap深入介绍（一）---基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-07T00:00:00+08:00">
                2016-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android应用开发中，我们经常需要跟图片打交道，而图片一个很麻烦的问题是占用内存非常大，经常导致OOM，了解Bitmap相关信息，不同sdk版本中Android图片处理的变化，以及一些优化处理的方式对我们平时开发中对图片的会非常有帮助。</p>
<p>我觉得需要了解好图片最基础的是需要知道图片基础信息，Bitmap内容，存储信息，以及加载。</p>
<h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>Bitmap的存储可以说包括两个部分，像素以及长,宽，颜色等描述信息。像素是Bitmap最占用内存的地方，长宽和像素位数是用来描述图片的，可以通过这些信息计算出图片的像素占用的内存大小。具体到Bitmap的API是下面这几个接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final int getWidth()</div><div class="line">public final int getHeight()</div><div class="line">public final Config getConfig()</div></pre></td></tr></table></figure>
<p>Config是一个枚举类型，表示图片像素类型，总共有下面几种类型：<code>ALPHA_8     (1),RGB_565     (3),ARGB_4444   (4),ARGB_8888   (5);</code>。表示每一个像素图片组成。实际上下面两种方式获取的数值是相等的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int b = 1;</div><div class="line">switch (bitmap.getConfig()) &#123;</div><div class="line">    case ALPHA_8:</div><div class="line">        b = 1;</div><div class="line">        break;</div><div class="line">    case ARGB_4444:</div><div class="line">        b = 2;</div><div class="line">        break;</div><div class="line">    case ARGB_8888:</div><div class="line">        b = 4;</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line">int bytes1 = bitmap.getWidth() * bitmap.getHeight() * b;</div><div class="line"></div><div class="line">int bytes2 = bitmap.getByteCount();　//从api12才有的接口</div></pre></td></tr></table></figure>
<p>这是由Bitmap相关参数可以计算出Bitmap所占用的像素数，实际上我们放入drawable里面的图片都是已经知道了图片的长宽以及像素组成的，但是直接在Android外面算出的图片像素数量与通过上面的代码计算会有出入的。因为Android对图片做了缩放，这个跟你将图片放入的drawable位置相关。</p>
<p>我们都知道android资源目录中会有drawable-hdpi, drawable-xhdpi，drawable-xxhdpi等目录。这里每个目录都会对应一个density。下面看BitmapFactory.decodeResource方法加载Bitmap的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test4, options);</div><div class="line">Log.i(LOGTAG, &quot;options: &quot; + options.inDensity + &quot;,&quot; + options.inTargetDensity);</div></pre></td></tr></table></figure>
<p>decodeResource就是Android内部对Resource的加载方式，这里就不从源码上面一步一步介绍了，它最终会调用decodeResourceStream方法，直接看decodeResourceStream：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static Bitmap decodeResourceStream(Resources res, TypedValue value,</div><div class="line">        InputStream is, Rect pad, Options opts) &#123;</div><div class="line">    if (opts == null) &#123;</div><div class="line">        opts = new Options();</div><div class="line">    &#125;</div><div class="line">    if (opts.inDensity == 0 &amp;&amp; value != null) &#123;</div><div class="line">        final int density = value.density;</div><div class="line">        if (density == TypedValue.DENSITY_DEFAULT) &#123;</div><div class="line">            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</div><div class="line">        &#125; else if (density != TypedValue.DENSITY_NONE) &#123;</div><div class="line">            opts.inDensity = density;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (opts.inTargetDensity == 0 &amp;&amp; res != null) &#123;</div><div class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</div><div class="line">    &#125;</div><div class="line">    return decodeStream(is, pad, opts);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>options.inDensity表示图片自身默认的像素密度，TypedValue会有一个density，对应着图片来自于哪个drawable目录，因为每一个drawable目录(drawable-hdpi,drawable-xhdpi,drawable-xxhdpi)都对应着一种屏幕，而屏幕就有density，TypedValue的density对应着DisplayMetrics的densityDpi,densityDpi表示每英尺的像素数。options.inTargetDensity是当前手机屏幕对应的densityDpi，最终的像素数是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bytes = 原始图片宽*(options.inDensity/options.inTargetDensity)*原始图片长*(options.inDensity/options.inTargetDensity)*每个像素点位数</div></pre></td></tr></table></figure>
<h3 id="存储与传输"><a href="#存储与传输" class="headerlink" title="存储与传输"></a>存储与传输</h3><p>Android图片在不同的sdk版本中存储的地方是不一样的。在2.3及2.3以前，图片像素是存储在native内存中。Android内存分为Java堆和native内存。Android会限制每个应用能使用的最大内存。但是Android对内存的限制是Java堆和native内存的和，把像素数据存放在native区，虚拟机无法自动进行垃圾回收，必须手动使用bitmap.recycle()导致很容易内存泄漏。因为Android的设备monitor也只能够看到Java堆的内存变化，这样其实也不方便调试Bitmap内存。比如在应用中新创建一个图片，根本无法在monitor中看到内存变化。</p>
<p>从3.0开始Android将图片保存在Java堆中，新加载一张图片的时候，也能够立刻从monitor反映出来。另外Java的垃圾回收机制也能够自动回收。然后在4.0后，图片又有了一些变化，那就是在parcel传输的时候，当图片很大时，它会使用ashmem来进行图片的传输，具体可以看我这篇文章<a href="http://blog.houzhi.me/2016/05/29/android-parcel-bitmap-2" target="_blank" rel="external">Android4.0之后Parcel传输Bitmap源码分析</a>。在6.0的时候，图片的存储又有了很大的变化，底层已经明显增加了将图片保存ashmem的接口了，具体可以可以看我这篇文章<a href="http://blog.houzhi.me/2016/05/24/android-bitmap-sourcecode-analysis" target="_blank" rel="external">Android6.0 Bitmap存储以及Parcel传输源码分析</a></p>
<h3 id="BitmapFactory"><a href="#BitmapFactory" class="headerlink" title="BitmapFactory"></a>BitmapFactory</h3><p>BitmapFactory是用来加载图片的，这个类主要分为三种图片的加载，先把它的API拿出来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static Bitmap decodeResourceStream(Resources res, TypedValue value,</div><div class="line">        InputStream is, Rect pad, Options opts) </div><div class="line">public static Bitmap decodeResource(Resources res, int id, Options opts) </div><div class="line">public static Bitmap decodeResource(Resources res, int id) </div><div class="line"></div><div class="line">public static Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts) &#123;</div><div class="line">public static Bitmap decodeByteArray(byte[] data, int offset, int length) &#123;</div><div class="line">   </div><div class="line">public static Bitmap decodeFile(String pathName, Options opts) </div><div class="line">public static Bitmap decodeFile(String pathName)</div><div class="line">public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) </div><div class="line">public static Bitmap decodeStream(InputStream is) </div><div class="line"></div><div class="line">public static Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</div><div class="line">public static Bitmap decodeFileDescriptor(FileDescriptor fd)</div></pre></td></tr></table></figure>
<p>我们直接看BitmapFactory提供的nativeDecode接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage,</div><div class="line">        Rect padding, Options opts);</div><div class="line">private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd,</div><div class="line">        Rect padding, Options opts);</div><div class="line">private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts);</div><div class="line">private static native Bitmap nativeDecodeByteArray(byte[] data, int offset,</div><div class="line">        int length, Options opts);</div></pre></td></tr></table></figure>
<p>BitmapFactory对File的decode都会转换为InputStream采用nativeDecodeStream来decode，对Resource的decode会采用decodeAsset，而如果FileDesciptor可以转换为native的fd,会通过nativeDecodeFileDescriptor来decode，另外ByteArray会直接采用nativeDecodeByteArray来decode。<strong><em>需要注意的是，对Resource的decode，BitmapFactory会设置Option的相关参数，最终进行相应的缩放，图片的大小会跟原图有所区别。</em></strong> 具体的内容建议去看看BitmapFactory，了解每种方式的区别，才能够更好地使用接口，选择的时候采用更有效率的方法。</p>
<h3 id="BitmapFactory-Options"><a href="#BitmapFactory-Options" class="headerlink" title="BitmapFactory.Options"></a>BitmapFactory.Options</h3><p>下面看一下Options类，我们在加载的时候，可以通过这个参数对图片进行一些处理，前面已经说了inDensity和inTargetDensity。下面看看其他的参数。</p>
<h4 id="inPurgeable"><a href="#inPurgeable" class="headerlink" title="inPurgeable"></a>inPurgeable</h4><p>这个参数的用途是当需要使用Bitmap的时候再加载Bitmap，不需要的时候回收Bitmap。在4.1中，使用inPurgeable，加载图片后内存基本不会增高，而不使用inPurgeable加载图片后内存会有明显的增加。</p>
<h4 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h4><p>这是表示采样大小，长和宽会对应乘以1/inSampleSize。用于将图片缩小加载出来的，以免站占用太大内存，适合缩略图。</p>
<h4 id="inJustDecodeBounds"><a href="#inJustDecodeBounds" class="headerlink" title="inJustDecodeBounds"></a>inJustDecodeBounds</h4><p>这个设置了true后，用于获取图片的宽度长度信息。下面是个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options = new BitmapFactory.Options();</div><div class="line">options.inJustDecodeBounds = true;</div><div class="line">Bitmap bmp = BitmapFactory.decodeFile(path, options);</div><div class="line">// options.outWidth 和 options.outHeight就能够获取结果</div></pre></td></tr></table></figure>
<h4 id="inBitmap"><a href="#inBitmap" class="headerlink" title="inBitmap"></a>inBitmap</h4><p>在Android 3.0开始引入了inBitmap设置，通过设置这个参数，在图片加载的时候可以使用之前已经创建了的Bitmap，以便节省内存，避免再次创建一个Bitmap。在Android4.4，新增了允许inBitmap设置的图片与需要加载的图片的大小不同的情况，只要inBitmap的图片比当前需要加载的图片大就好了。</p>
<h4 id="inPreferredConfig"><a href="#inPreferredConfig" class="headerlink" title="inPreferredConfig"></a>inPreferredConfig</h4><p>用于配置图片解码方式，对应的类型Bitmap.Config。如果非null，则会使用它来解码图片</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇先主要介绍了Bitmap相关基本的信息，Bitmap，BitmapFactory和Options类，以及bitmap的存储。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">houzhi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">houzhi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
